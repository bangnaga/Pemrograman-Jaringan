{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Dashboard Buku Ajar Pemrograman Jaringan","text":"<p>Selamat datang di Dashboard Buku Ajar Pemrograman Jaringan. Dokumen ini berfungsi sebagai peta konten (Map of Content) untuk memudahkan navigasi antar bab dan topik.</p>","tags":["Dashboard","MOC","PemrogramanJaringan"]},{"location":"#peta-konsep-flowchart","title":"Peta Konsep (Flowchart)","text":"<pre><code>graph TD\n    Start((\"Mulai\")) --&gt; Pengantar[[\"00. Pengantar\"]]\n    Pengantar --&gt; Bab1[[\"Bab 1: Konsep Dasar\"]]\n    Bab1 --&gt; Bab2[[\"Bab 2: Socket API\"]]\n    Bab2 --&gt; Bab3[[\"Bab 3: TCP Chat App\"]]\n    Bab2 --&gt; Bab4[[\"Bab 4: UDP Streaming\"]]\n\n    subgraph Core [\"Core Network Programming\"]\n    Bab3 --&gt; Bab5[[\"Bab 5: Error Handling &amp; Framing\"]]\n    Bab4 --&gt; Bab5\n    Bab5 --&gt; Bab6[[\"Bab 6: Threading\"]]\n    Bab6 --&gt; Bab7[\"Bab 7: Serialisasi JSON/Pickle\"](&lt;\"Bab 7: Serialisasi JSON/Pickle\".md&gt;)\n    Bab7 --&gt; Bab8[\"Bab 8: Asynchronous I/O\"](&lt;\"Bab 8: Asynchronous I/O\".md&gt;)\n    Bab8 --&gt; Bab9[\"Bab 9: Multiplexing select/poll\"](&lt;\"Bab 9: Multiplexing select/poll\".md&gt;)\n    end\n\n    subgraph Web [\"Web &amp; Application Layer\"]\n    Bab9 --&gt; Bab10[[\"Bab 10: HTTP &amp; Web Server\"]]\n    Bab10 --&gt; Bab11[[\"Bab 11: REST API\"]]\n    Bab11 --&gt; Bab12[[\"Bab 12: WebSocket Real-time\"]]\n    end\n\n    subgraph Advanced [\"Advanced &amp; Security\"]\n    Bab12 --&gt; Bab13[[\"Bab 13: Network Security\"]]\n    Bab13 --&gt; Bab14[[\"Bab 14: IoT &amp; MQTT\"]]\n    Bab14 --&gt; Bab15[[\"Bab 15: Capstone Project\"]]\n    end\n\n    Bab15 --&gt; Pustaka[[\"Daftar Pustaka\"]]\n    Bab15 --&gt; Glosarium[[\"Glosarium\"]]</code></pre>","tags":["Dashboard","MOC","PemrogramanJaringan"]},{"location":"#daftar-isi-link-cepat","title":"Daftar Isi &amp; Link Cepat","text":"","tags":["Dashboard","MOC","PemrogramanJaringan"]},{"location":"#pendahuluan","title":"Pendahuluan","text":"<ul> <li>00_Metadata_Buku - Informasi Buku</li> <li>00_Pengantar - Kata Pengantar &amp; Tinjauan</li> </ul>","tags":["Dashboard","MOC","PemrogramanJaringan"]},{"location":"#materi-inti","title":"Materi Inti","text":"<ul> <li>Naskah_Bab_1 - Konsep Dasar Pemrograman Jaringan</li> <li>Naskah_Bab_2 - Socket API Dasar</li> <li>Naskah_Bab_3 - Protokol TCP (Aplikasi Chat)</li> <li>Naskah_Bab_4 - Protokol UDP (Streaming &amp; Broadcasting)</li> <li>Naskah_Bab_5 - Error Handling &amp; Framing Data</li> <li>Naskah_Bab_6 - Concurrency Part I - Threading</li> <li>Naskah_Bab_7 - Serialisasi Data (JSON &amp; Pickle)</li> <li>Naskah_Bab_8 - Asynchronous I/O (Concurrency Part II)</li> <li>Naskah_Bab_9 - I/O Multiplexing (<code>select</code> &amp; <code>poll</code>)</li> </ul>","tags":["Dashboard","MOC","PemrogramanJaringan"]},{"location":"#materi-lanjut-web","title":"Materi Lanjut &amp; Web","text":"<ul> <li>Naskah_Bab_10 - Protokol HTTP &amp; Web Server</li> <li>Naskah_Bab_11 - REST API &amp; Web Services</li> <li>Naskah_Bab_12 - Real-time Communication (WebSocket)</li> <li>Naskah_Bab_13 - Keamanan Jaringan (Network Security)</li> <li>Naskah_Bab_14 - Arsitektur Sistem Terdistribusi &amp; IoT (MQTT)</li> <li>Naskah_Bab_15 - Penutup &amp; Proyek Akhir (Capstone Project)</li> </ul>","tags":["Dashboard","MOC","PemrogramanJaringan"]},{"location":"#referensi","title":"Referensi","text":"<ul> <li>16_Daftar_Pustaka</li> <li>17_Glosarium</li> </ul> <p>Statistik: Total Bab: 15 Topik Utama: Socket, TCP/IP, Concurrency, HTTP, Security, IoT.</p>","tags":["Dashboard","MOC","PemrogramanJaringan"]},{"location":"00_Metadata_Buku/","title":"BUKU AJAR","text":"","tags":["Metadata","BukuAjar","Info"]},{"location":"00_Metadata_Buku/#pemrograman-jaringan","title":"PEMROGRAMAN JARINGAN","text":"<p>Disusun Oleh: Ucok, S.Kom., MT</p> <p>Program Studi Teknik Informatika Fakultas Ilmu Komputer Universitas Indonesia Timur 2026</p>","tags":["Metadata","BukuAjar","Info"]},{"location":"00_Metadata_Buku/#kata-pengantar","title":"KATA PENGANTAR","text":"<p>Puji syukur kehadirat Tuhan Yang Maha Esa, karena atas rahmat dan karunia-Nya, Buku Ajar mata kuliah Pemrograman Jaringan ini dapat diselesaikan dengan baik.</p> <p>Buku ajar ini disusun sebagai panduan utama bagi mahasiswa Program Studi Teknik Informatika dalam memahami konsep dan implementasi komunikasi data antar komputer. Dimulai dari dasar-dasar Socket Programming, protokol TCP/IP, hingga topik lanjut seperti Concurrency, Asynchronous I/O, dan Network Security.</p> <p>Materi dalam buku ini mengedepankan pendekatan Project-Based Learning (PjBL), di mana mahasiswa tidak hanya belajar teori, tetapi langsung mengimplementasikannya dalam kode program Python yang nyata. Setiap bab dilengkapi dengan latihan praktikum dan tugas mandiri untuk mengasah keterampilan problem solving.</p> <p>Penulis menyadari bahwa buku ini masih jauh dari sempurna. Oleh karena itu, kritik dan saran yang membangun sangat diharapkan demi penyempurnaan karya ini di masa mendatang.</p> <p>Semoga buku ajar ini bermanfaat bagi mahasiswa dan pembaca sekalian.</p> <p>Makassar, Januari 2026</p> <p>Penulis</p>","tags":["Metadata","BukuAjar","Info"]},{"location":"00_Metadata_Buku/#daftar-isi","title":"DAFTAR ISI","text":"<ul> <li>Tinjauan Mata Kuliah</li> <li>Bab 1: Konsep Dasar Pemrograman Jaringan</li> <li>Bab 2: Socket API Dasar</li> <li>Bab 3: Protokol TCP (Aplikasi Chat)</li> <li>Bab 4: Protokol UDP (Streaming &amp; Broadcasting)</li> <li>Bab 5: Error Handling &amp; Framing Data</li> <li>Bab 6: Concurrency Part I - Threading</li> <li>Bab 7: Serialisasi Data (JSON &amp; Pickle)</li> <li>Bab 8: Asynchronous I/O (Concurrency Part II)</li> <li>Bab 9: I/O Multiplexing (<code>select</code> &amp; <code>poll</code>)</li> <li>Bab 10: Protokol HTTP &amp; Web Server</li> <li>Bab 11: REST API &amp; Web Services</li> <li>Bab 12: Real-time Communication (WebSocket)</li> <li>Bab 13: Keamanan Jaringan (Network Security)</li> <li>Bab 14: Arsitektur Sistem Terdistribusi &amp; IoT (MQTT)</li> <li>Bab 15: Penutup &amp; Proyek Akhir (Capstone Project)</li> <li>Daftar Pustaka</li> <li>Glosarium</li> </ul> <p>Navigasi: [[00_Dashboard]] | 00_Pengantar</p>","tags":["Metadata","BukuAjar","Info"]},{"location":"00_Pengantar/","title":"Kata Pengantar","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"00_Pengantar/#pengantar-dan-prasyarat-mata-kuliah","title":"Pengantar dan Prasyarat Mata Kuliah","text":"<p>Selamat datang di mata kuliah Pemrograman Jaringan (Network Programming). Dokumen ini berisi informasi awal yang penting sebelum Anda memulai petualangan coding di dunia jaringan komputer.</p>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"00_Pengantar/#1-deskripsi-mata-kuliah","title":"1. Deskripsi Mata Kuliah","text":"<p>Mata kuliah ini dirancang untuk menjembatani teori jaringan komputer dengan praktik pengembangan aplikasi. Jika di mata kuliah \"Jaringan Komputer\" Anda belajar bagaimana kabel dan router bekerja, di sini Anda akan belajar cara membuat aplikasi yang berjalan di atas infrastruktur tersebut.</p> <p>Anda akan mulai dari level terendah (Socket API), naik ke protokol transport (TCP/UDP), menangani concurrency (Threading/Async), hingga level aplikasi modern (HTTP, WebSocket, IoT, dan Security).</p>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"00_Pengantar/#2-mengapa-belajar-pemrograman-jaringan","title":"2. Mengapa Belajar Pemrograman Jaringan?","text":"<p>Di era Cloud Computing dan IoT saat ini, hampir tidak ada aplikasi yang berdiri sendiri (standalone). *   Aplikasi HP Anda terhubung ke Server. *   Game Web terhubung ke Multiplayer Server. *   Smart Home terhubung ke Cloud. Kemampuan membangun sistem yang saling berkomunikasi adalah skill fundamental bagi Software Engineer modern.</p>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"00_Pengantar/#3-prasyarat-prerequisites","title":"3. Prasyarat (Prerequisites)","text":"<p>Agar tidak \"tersesat\" di tengah jalan, pastikan Anda telah memiliki bekal berikut:</p>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"00_Pengantar/#a-hard-skills-wajib","title":"a. Hard Skills (Wajib)","text":"<ol> <li>Dasar Jaringan Komputer:<ul> <li>Memahami konsep IP Address &amp; Port.</li> <li>Memahami perbedaan mendasar TCP vs UDP.</li> <li>Familiar dengan Model OSI/TCP-IP.</li> </ul> </li> <li>Algoritma &amp; Pemrograman Python:<ul> <li>Lancar menggunakan sintaks dasar (Variabel, Loop, If-Else).</li> <li>Paham konsep Function dan Exception Handling (<code>try-except</code>).</li> <li>(Disarankan) Paham Konsep OOP (<code>Class</code> &amp; <code>Object</code>).</li> </ul> </li> <li>Command Line Interface (CLI):<ul> <li>Tidak takut layar hitam (Terminal/CMD).</li> <li>Bisa menggunakan perintah dasar jaringan: <code>ping</code>, <code>ipconfig</code>/<code>ifconfig</code>, <code>telnet</code>.</li> </ul> </li> </ol>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"00_Pengantar/#b-tools-lingkungan-kerja","title":"b. Tools &amp; Lingkungan Kerja","text":"<ol> <li>Laptop/PC: Windows, Linux, atau macOS.</li> <li>Python 3.x: Wajib terinstall dan terdaftar di PATH Environment Variable.</li> <li>Code Editor: Visual Studio Code (Rekomendasi), PyCharm, atau Sublime Text.</li> <li>Packet Analyzer (Optional): Wireshark (untuk melihat \"isi perut\" data jaringan).</li> </ol>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"00_Pengantar/#4-peta-jalan-pembelajaran-roadmap","title":"4. Peta Jalan Pembelajaran (Roadmap)","text":"<p>Buku ajar ini disusun secara bertahap: *   Fundamental: Bab 1 - 4 (Konsep, Socket, TCP, UDP). *   Concurrency: Bab 6, 8, 9 (Multi-threading, Async, Multiplexing). *   Data &amp; Error: Bab 5, 7 (Framing, JSON). *   Web &amp; Modern: Bab 10 - 12 (HTTP, REST, WebSocket). *   Advanced: Bab 13 - 15 (Security, IoT, Final Project).</p> <p>Navigasi: 00_Metadata_Buku | [[00_Dashboard]] | Naskah_Bab_1</p>","tags":["Pengantar","Prasyarat","Roadmap","PemrogramanJaringan","Python","NetworkProgramming","Bab0"]},{"location":"16_Daftar_Pustaka/","title":"DAFTAR PUSTAKA","text":"<ol> <li>Rhodes, B., &amp; Goerzen, J. (2014). Foundations of Python Network Programming (3rd ed.). Apress.</li> <li>Kurose, J. F., &amp; Ross, K. W. (2021). Computer Networking: A Top-Down Approach (8th ed.). Pearson.</li> <li>Wouters, J. (2019). Learning Python Network Programming. Packt Publishing.</li> <li>Doherty, J. (2020). Python Network Programming Techniques. Packt Publishing.</li> <li>Python Software Foundation. (2025). Python 3.12 Documentation. https://docs.python.org/3/</li> <li>Mozilla Developer Network (MDN). (2025). Web Technologies for Developers. https://developer.mozilla.org/</li> </ol> <p>Navigasi: Naskah_Bab_15 | [[00_Dashboard]] | 17_Glosarium</p>","tags":["Referensi","Pustaka","Resources"]},{"location":"17_Glosarium/","title":"GLOSARIUM","text":"<ul> <li>API (Application Programming Interface): Antarmuka yang memungkinkan dua aplikasi perangkat lunak untuk saling berkomunikasi.</li> <li>Asynchronous: Model eksekusi di mana sebuah tugas tidak memblokir tugas lain, memungkinkan multitasking dalam satu thread.</li> <li>Blocking I/O: Operasi Input/Output yang menghentikan eksekusi program hingga operasi tersebut selesai.</li> <li>Client-Server: Arsitektur jaringan di mana klien meminta layanan dan server menyediakan layanan.</li> <li>Concurrency: Kemampuan program untuk menangani beberapa tugas secara tumpang tindih dalam satu rentang waktu.</li> <li>Handshake: Proses negosiasi awal antara dua pihak (misal: Client dan Server) sebelum pertukaran data dimulai.</li> <li>HTTP (HyperText Transfer Protocol): Protokol standar untuk mentransfer dokumen hypermedia di World Wide Web.</li> <li>IoT (Internet of Things): Jaringan perangkat fisik yang tertanam dengan sensor dan software untuk bertukar data via internet.</li> <li>IP Address: Label numerik yang ditetapkan untuk setiap perangkat yang terhubung ke jaringan komputer.</li> <li>JSON (JavaScript Object Notation): Format pertukaran data ringan yang mudah dibaca manusia dan mesin.</li> <li>Latency: Penundaan waktu antara pengiriman permintaan dan penerimaan respons.</li> <li>Localhost: Nama host standar yang diberikan ke alamat loopback local (127.0.0.1).</li> <li>MQTT: Protokol pesan ringan untuk sensor dan perangkat mobile kecil (IoT).</li> <li>Port: Titik akhir virtual komunikasi dalam sistem operasi untuk membedakan proses/layanan spesifik.</li> <li>Protocol: Aturan standar yang memungkinkan perangkat elektronik untuk berkomunikasi satu sama lain.</li> <li>REST (Representational State Transfer): Gaya arsitektur perangkat lunak untuk menyediakan standar antara sistem komputer di web.</li> <li>Socket: Titik akhir (endpoint) komunikasi dua arah antara dua program di jaringan.</li> <li>SSL/TLS: Protokol kriptografi yang dirancang untuk memberikan keamanan komunikasi melalui jaringan komputer.</li> <li>Thread: Unit eksekusi terkecil dalam sebuah proses.</li> <li>UDP (User Datagram Protocol): Protokol komunikasi tanpa koneksi yang memprioritaskan kecepatan di atas keandalan.</li> <li>WebSocket: Protokol komunikasi komputer yang menyediakan saluran komunikasi full-duplex melalui koneksi TCP tunggal.</li> </ul> <p>Navigasi: 16_Daftar_Pustaka | [[00_Dashboard]]</p>","tags":["Glosarium","Istilah","Definisi"]},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/","title":"BUKU AJAR","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#pemrograman-jaringan","title":"PEMROGRAMAN JARINGAN","text":"<p>Disusun Oleh: Ucok, S.Kom., MT</p> <p>Program Studi Teknik Informatika Fakultas Ilmu Komputer Universitas Indonesia Timur 2026</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kata-pengantar","title":"KATA PENGANTAR","text":"<p>Puji syukur kehadirat Tuhan Yang Maha Esa, karena atas rahmat dan karunia-Nya, Buku Ajar mata kuliah Pemrograman Jaringan ini dapat diselesaikan dengan baik.</p> <p>Buku ajar ini disusun sebagai panduan utama bagi mahasiswa Program Studi Teknik Informatika dalam memahami konsep dan implementasi komunikasi data antar komputer. Dimulai dari dasar-dasar Socket Programming, protokol TCP/IP, hingga topik lanjut seperti Concurrency, Asynchronous I/O, dan Network Security.</p> <p>Materi dalam buku ini mengedepankan pendekatan Project-Based Learning (PjBL), di mana mahasiswa tidak hanya belajar teori, tetapi langsung mengimplementasikannya dalam kode program Python yang nyata. Setiap bab dilengkapi dengan latihan praktikum dan tugas mandiri untuk mengasah keterampilan problem solving.</p> <p>Penulis menyadari bahwa buku ini masih jauh dari sempurna. Oleh karena itu, kritik dan saran yang membangun sangat diharapkan demi penyempurnaan karya ini di masa mendatang.</p> <p>Semoga buku ajar ini bermanfaat bagi mahasiswa dan pembaca sekalian.</p> <p>Makassar, Januari 2026</p> <p>Penulis</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#daftar-isi","title":"DAFTAR ISI","text":"<ul> <li>Tinjauan Mata Kuliah</li> <li>Bab 1: Konsep Dasar Pemrograman Jaringan</li> <li>Bab 2: Socket API Dasar</li> <li>Bab 3: Protokol TCP (Aplikasi Chat)</li> <li>Bab 4: Protokol UDP (Streaming &amp; Broadcasting)</li> <li>Bab 5: Error Handling &amp; Framing Data</li> <li>Bab 6: Concurrency Part I - Threading</li> <li>Bab 7: Serialisasi Data (JSON &amp; Pickle)</li> <li>Bab 8: Asynchronous I/O (Concurrency Part II)</li> <li>Bab 9: I/O Multiplexing (<code>select</code> &amp; <code>poll</code>)</li> <li>Bab 10: Protokol HTTP &amp; Web Server</li> <li>Bab 11: REST API &amp; Web Services</li> <li>Bab 12: Real-time Communication (WebSocket)</li> <li>Bab 13: Keamanan Jaringan (Network Security)</li> <li>Bab 14: Arsitektur Sistem Terdistribusi &amp; IoT (MQTT)</li> <li>Bab 15: Penutup &amp; Proyek Akhir (Capstone Project)</li> <li>Daftar Pustaka</li> <li>Glosarium</li> </ul> <p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#pengantar-dan-prasyarat-mata-kuliah","title":"Pengantar dan Prasyarat Mata Kuliah","text":"<p>Selamat datang di mata kuliah Pemrograman Jaringan (Network Programming). Dokumen ini berisi informasi awal yang penting sebelum Anda memulai petualangan coding di dunia jaringan komputer.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#1-deskripsi-mata-kuliah","title":"1. Deskripsi Mata Kuliah","text":"<p>Mata kuliah ini dirancang untuk menjembatani teori jaringan komputer dengan praktik pengembangan aplikasi. Jika di mata kuliah \"Jaringan Komputer\" Anda belajar bagaimana kabel dan router bekerja, di sini Anda akan belajar cara membuat aplikasi yang berjalan di atas infrastruktur tersebut.</p> <p>Anda akan mulai dari level terendah (Socket API), naik ke protokol transport (TCP/UDP), menangani concurrency (Threading/Async), hingga level aplikasi modern (HTTP, WebSocket, IoT, dan Security).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#2-mengapa-belajar-pemrograman-jaringan","title":"2. Mengapa Belajar Pemrograman Jaringan?","text":"<p>Di era Cloud Computing dan IoT saat ini, hampir tidak ada aplikasi yang berdiri sendiri (standalone). *   Aplikasi HP Anda terhubung ke Server. *   Game Web terhubung ke Multiplayer Server. *   Smart Home terhubung ke Cloud. Kemampuan membangun sistem yang saling berkomunikasi adalah skill fundamental bagi Software Engineer modern.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#3-prasyarat-prerequisites","title":"3. Prasyarat (Prerequisites)","text":"<p>Agar tidak \"tersesat\" di tengah jalan, pastikan Anda telah memiliki bekal berikut:</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-hard-skills-wajib","title":"a. Hard Skills (Wajib)","text":"<ol> <li>Dasar Jaringan Komputer:<ul> <li>Memahami konsep IP Address &amp; Port.</li> <li>Memahami perbedaan mendasar TCP vs UDP.</li> <li>Familiar dengan Model OSI/TCP-IP.</li> </ul> </li> <li>Algoritma &amp; Pemrograman Python:<ul> <li>Lancar menggunakan sintaks dasar (Variabel, Loop, If-Else).</li> <li>Paham konsep Function dan Exception Handling (<code>try-except</code>).</li> <li>(Disarankan) Paham Konsep OOP (<code>Class</code> &amp; <code>Object</code>).</li> </ul> </li> <li>Command Line Interface (CLI):<ul> <li>Tidak takut layar hitam (Terminal/CMD).</li> <li>Bisa menggunakan perintah dasar jaringan: <code>ping</code>, <code>ipconfig</code>/<code>ifconfig</code>, <code>telnet</code>.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-tools-lingkungan-kerja","title":"b. Tools &amp; Lingkungan Kerja","text":"<ol> <li>Laptop/PC: Windows, Linux, atau macOS.</li> <li>Python 3.x: Wajib terinstall dan terdaftar di PATH Environment Variable.</li> <li>Code Editor: Visual Studio Code (Rekomendasi), PyCharm, atau Sublime Text.</li> <li>Packet Analyzer (Optional): Wireshark (untuk melihat \"isi perut\" data jaringan).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#4-peta-jalan-pembelajaran-roadmap","title":"4. Peta Jalan Pembelajaran (Roadmap)","text":"<p>Buku ajar ini disusun secara bertahap: *   Fundamental: Bab 1 - 4 (Konsep, Socket, TCP, UDP). *   Concurrency: Bab 6, 8, 9 (Multi-threading, Async, Multiplexing). *   Data &amp; Error: Bab 5, 7 (Framing, JSON). *   Web &amp; Modern: Bab 10 - 12 (HTTP, REST, WebSocket). *   Advanced: Bab 13 - 15 (Security, IoT, Final Project).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-1-konsep-dasar-pemrograman-jaringan","title":"Bab 1: Konsep Dasar Pemrograman Jaringan","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan arsitektur protokol jaringan (Model OSI dan TCP/IP) dan relevansinya dalam pengembangan aplikasi. 2.  Mengidentifikasi komponen vital komunikasi jaringan: IP Address, Port, dan Socket. 3.  Mendemonstrasikan penggunaan library dasar Python untuk diagnosa informasi jaringan lokal.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#11-pendahuluan","title":"1.1 Pendahuluan","text":"<p>Pemrograman Jaringan (Network Programming) adalah seni menulis perangkat lunak yang memungkinkan proses-proses komputer yang berbeda untuk berkomunikasi satu sama lain melalui jaringan. Materi ini akan menjadi fondasi bagi Anda untuk memahami bagaimana internet bekerja, mulai dari aplikasi chat sederhana hingga sistem skala besar yang terdistribusi (Distributed Systems).</p> <p>Analogi di Dunia Nyata: Bayangkan Anda mengirim paket belanja online. *   Aplikasi (Shopee/Tokopedia): Adalah program yang Anda buat. *   Jasa Ekspedisi (JNE/J&amp;T): Adalah Jaringan Komputer yang mengurus pengantaran tanpa Anda perlu tahu detail rute truknya. Tugas kita sebagai Network Programmer adalah memastikan paket (data) diserahkan ke kurir dengan alamat yang benar dan dikemas dengan aman.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#12-model-referensi-komunikasi","title":"1.2 Model Referensi Komunikasi","text":"<p>Dalam dunia industri IT (terutama bagi Network Engineer dan SysAdmin), pemahaman layer sangat vital untuk troubleshooting. Jika website down, apakah masalah di kabel (Physical), IP conflict (Network), atau kode program error (Application)?</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram Perbandingan Side-by-Side antara Model OSI 7 Layer dan TCP/IP 4 Layer]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-model-osi-7-layer","title":"a. Model OSI (7 Layer)","text":"<p>Model konseptual yang membagi komunikasi jaringan menjadi 7 lapisan: 1.  Physical: Media transmisi (Kabel LAN, Fiber Optic, Sinyal WiFi). 2.  Data Link: Identitas perangkat keras (MAC Address), Switching. 3.  Network: Pengalamatan logis (IP Address), Routing antar jaringan. 4.  Transport: Pengiriman data reliabel vs cepat (TCP/UDP), Port numbers. 5.  Session: Manajemen sesi komunikasi. 6.  Presentation: Format data (Enkripsi SSL/TLS, Kompresi). 7.  Application: Protokol yang langsung berinteraksi dengan user (HTTP, DNS, FTP).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-model-tcpip-4-layer","title":"b. Model TCP/IP (4 Layer)","text":"<p>Model yang lebih praktis dan menjadi standar Internet saat ini: 1.  Network Access: Gabungan Physical &amp; Data Link. 2.  Internet: Setara Network (IP). 3.  Transport: TCP &amp; UDP. 4.  Application: Gabungan Session, Presentation, &amp; Application.</p> <p>Fokus Mata Kuliah ini ada di Layer Transport (Socket Programming) dan Layer Application.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#13-entitas-jaringan-ip-port-dan-socket","title":"1.3 Entitas Jaringan: IP, Port, dan Socket","text":"<p>Untuk membuat aplikasi jaringan, kita memerlukan \"Alamat Tujuan\" dan \"Pintu Masuk\".</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Socket sebagai kombinasi IP Address dan Port Number pada dua komputer yang terhubung]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#1-ip-address-alamat-gedung","title":"1. IP Address (Alamat Gedung)","text":"<p>Alamat unik yang mengidentifikasi host/komputer di jaringan. *   IPv4: <code>192.168.1.1</code> (Format umum saat ini). *   Localhost: <code>127.0.0.1</code> (Alamat loopback, ibarat bicara pada diri sendiri). Penting untuk testing aplikasi tanpa internet.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#2-port-number-nomor-ruanganekstensi","title":"2. Port Number (Nomor Ruangan/Ekstensi)","text":"<p>Angka 16-bit (0-65535) yang membedakan layanan/aplikasi dalam satu komputer. Satu komputer bisa menjalankan Web Server (Port 80) dan Database (Port 3306) sekaligus. *   Well-known Ports (0-1023): Direservasi sistem (HTTP=80, HTTPS=443, SSH=22). Jangan gunakan ini untuk aplikasi latihan Anda kecuali Anda punya akses Administrator. *   Registered/Dynamic Ports (1024+): Aman digunakan untuk aplikasi buatan kita (misal: 5000, 8080, 12345).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#3-socket-wadah-komunikasi","title":"3. Socket (Wadah Komunikasi)","text":"<p>Titik akhir (endpoint) komunikasi dua arah. Rumus: <code>Socket = IP Address + Port Number</code></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#14-persiapan-environment","title":"1.4 Persiapan Environment","text":"<p>Kita akan menggunakan Python 3 karena pustaka jaringannya (<code>socket</code>) adalah standar industri dan cross-platform (bisa jalan di Windows/Linux/Mac). IDE yang disarankan: Visual Studio Code atau PyCharm.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#cek-instalasi","title":"Cek Instalasi","text":"<p>Pastikan Python terinstal dan terbaca di terminal: <pre><code>python --version\n# Hubungkan perangkat ke WiFi/LAN agar mendapat IP Address yang valid.\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#15-latihan-cek-identitas-jaringan-network-diagnostic","title":"1.5 Latihan: Cek Identitas Jaringan (Network Diagnostic)","text":"<p>Mari kita buat alat diagnosa sederhana. Script ini berguna saat Anda mendeploy aplikasi ke Server Cloud (AWS/GCP) untuk memastikan aplikasi berjalan di Hostname yang benar.</p> <p>Buka file <code>latihan_1_net_check.py</code>.</p> <pre><code>import socket\n\ndef check_net_info():\n    print(\"=== Network Information Tool ===\")\n    try:\n        # 1. Mengambil Hostname (Nama Komputer)\n        # Bermanfaat untuk log file agar tahu server mana yang memproses request\n        hostname = socket.gethostname()\n\n        # 2. Mengambil IP Address Lokal\n        # Fungsi ini melakukan resolusi DNS lokal\n        ip_address = socket.gethostbyname(hostname)\n\n        print(f\"Hostname  : {hostname}\")\n        print(f\"IP Address: {ip_address}\")\n\n    except socket.error as e:\n        # Best Practice: Selalu tangani potensi error jaringan\n        print(f\"Gagal mengambil informasi jaringan: {e}\")\n\nif __name__ == \"__main__\":\n    check_net_info()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#analisis-kode","title":"Analisis Kode","text":"<ul> <li><code>import socket</code>: Mengimpor modul inti Python untuk komunikasi jaringan.</li> <li><code>socket.gethostname()</code>: Meminta OS memberitahu nama komputer saat ini.</li> <li><code>socket.gethostbyname()</code>: Menerjemahkan nama komputer menjadi alamat IP.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#troubleshooting-common-issues","title":"Troubleshooting (Common Issues)","text":"<ul> <li>Output IP <code>127.0.0.1</code>: Ini berarti komputer tidak terhubung ke jaringan eksternal/WiFi, atau file <code>/etc/hosts</code> (di Linux/Mac) memetakan hostname ke localhost.</li> <li>VPN Aktif: Kadang IP yang muncul adalah IP Virtual dari VPN, bukan IP fisik LAN.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#16-tugas-mandiri-problem-solving","title":"1.6 Tugas Mandiri (Problem Solving)","text":"<p>Kerjakan tugas berikut untuk menguji pemahaman Anda:</p> <ol> <li> <p>Verifikasi Manual: Jalankan script di atas, lalu bandingkan hasilnya dengan perintah asli OS:</p> <ul> <li>Windows: Buka CMD, ketik <code>ipconfig</code>.</li> <li>Linux/Mac: Buka Terminal, ketik <code>ip addr</code> atau <code>ifconfig</code>.</li> <li>Analisis: Apakah IP-nya sama? Jika berbeda, mengapa? (Petunjuk: Sebuah komputer bisa memiliki banyak Network Interface Card/NIC).</li> </ul> </li> <li> <p>DNS Lookup Sederhana: Modifikasi kode di atas agar tidak mengecek hostname sendiri, melainkan mengecek IP dari website terkenal (misal: <code>google.com</code> atau <code>mikrotik.co.id</code>).</p> <ul> <li>Hint: Ganti parameter <code>hostname</code> pada fungsi <code>gethostbyname()</code> dengan string domain.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-1","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 1","text":"<p>File: <code>latihan_1_net_check.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef check_net_info():\n    print(\"--- Network Information Tool ---\")\n    try:\n        # Mengambil Hostname (Nama Komputer)\n        hostname = socket.gethostname()\n\n        # Mengambil IP Address Lokal komputer ini\n        # Note: Ini biasanya mengambil IP interface utama\n        ip_address = socket.gethostbyname(hostname)\n\n        print(f\"Hostname  : {hostname}\")\n        print(f\"IP Address: {ip_address}\")\n\n    except Exception as e:\n        print(f\"Terjadi kesalahan: {e}\")\n\nif __name__ == \"__main__\":\n    check_net_info()\n</code></pre></p> <p>File: <code>latihan_1_sapa.py</code> <pre><code># Credit: Fikom UIT\ndef main():\n    print(\"Halo, Mahasiswa Fikom UIT!\")\n    nama = input(\"Siapa nama Anda? \")\n    print(f\"Selamat belajar Python, {nama}!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-2-socket-api-dasar","title":"Bab 2: Socket API Dasar","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Mengoperasikan fungsi-fungsi utama dalam Socket API (<code>bind</code>, <code>listen</code>, <code>accept</code>, <code>connect</code>, <code>send</code>, <code>recv</code>). 2.  Mendemonstrasikan mekanisme pertukaran data sederhana antara Client dan Server. 3.  Menganalisis perbedaan perilaku antara Blocking I/O dan Non-Blocking I/O. 4.  Menerapkan encoding dan decoding yang tepat untuk transmisi data jaringan.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#21-pengantar-jembatan-antara-aplikasi-dan-jaringan","title":"2.1 Pengantar: Jembatan antara Aplikasi dan Jaringan","text":"<p>Pada Bab 1, kita telah membedah lapisan-lapisan teoritis jaringan (OSI Layer). Di Bab ini, kita akan turun ke lapangan praktik. Pertanyaan mendasarnya adalah: Bagaimana cara kode program Python kita \"berbicara\" dengan kartu jaringan (Network Interface Card)?</p> <p>Jawabannya adalah Socket API.</p> <p>Bayangkan Socket API sebagai sebuah \"Pintu Elektrik\" atau \"Stopkontak\". *   Di dunia nyata, jika Anda ingin menyalakan TV, Anda tidak perlu tahu bagaimana listrik dibangkitkan di PLTU. Anda cukup colokkan kabel ke stopkontak standar. *   Di dunia pemrograman, jika Anda ingin mengirim data ke internet, Anda tidak perlu memprogram sinyal listrik di kabel LAN. Anda cukup \"mencolokkan\" aplikasi Anda ke Socket API yang disediakan oleh Sistem Operasi. Modul <code>socket</code> di Python adalah antarmuka standar tersebut.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#22-anatomi-hubungan-client-server","title":"2.2 Anatomi Hubungan Client-Server","text":"<p>Sebagian besar aplikasi jaringan modern (Web, Email, Database) bekerja dengan arsitektur Client-Server. Memahami peran keduanya sangat krusial sebelum menulis baris kode pertama.</p> <p>Mari kita gunakan Analogi Resepsionis Hotel untuk memahami alur kerjanya:</p> <p>[Gambar: Ilustrasi kartun yang membandingkan alur Socket dengan alur tamu check-in di hotel]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-sisi-server-the-passive-listener","title":"A. Sisi Server (The Passive Listener)","text":"<p>Server bertindak seperti sebuah Hotel yang harus siap sedia 24 jam. Ia bersifat pasif, artinya ia menunggu, bukan mencari. Langkah-langkah logis yang harus dilakukan Server:</p> <ol> <li><code>socket()</code> - Membangun Gedung: Server membuat objek socket. Ini seperti mendirikan bangunan hotel.</li> <li><code>bind()</code> - Mengklaim Alamat: Server menentukan di mana ia beroperasi (IP Address) dan di pintu nomor berapa (Port). Tanpa bind, tamu (client) tidak akan tahu ke mana harus datang.</li> <li><code>listen()</code> - Membuka Layanan: Server menyatakan dirinya \"BUKA\" dan siap menerima antrean tamu. Parameter backlog menentukan berapa panjang antrean yang diperbolehkan di lobi sebelum satpam menolak tamu baru.</li> <li><code>accept()</code> - Resepsionis Menjawab: Ini adalah momen kritis. Saat ada tamu datang, resepsionis (server) menyapanya.<ul> <li>Penting: Fungsi ini menghasilkan koneksi khusus (socket baru) untuk tamu tersebut. Jadi, resepsionis utama tetap standby di meja depan, sementara tamu tadi dilayani oleh pelayan khusus di koneksi yang baru terbentuk.</li> </ul> </li> <li><code>recv()</code> / <code>send()</code> - Percakapan: Terjadi pertukaran informasi (data).</li> <li><code>close()</code> - Tamu Pulang: Sesi berakhir, kamar dibersihkan.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-sisi-client-the-active-initiator","title":"B. Sisi Client (The Active Initiator)","text":"<p>Client bertindak seperti Tamu Hotel. Ia bersifat aktif karena dialah yang memulai inisiatif untuk datang. Langkah-langkahnya lebih sederhana:</p> <ol> <li><code>socket()</code>: Tamu bersiap (keluar rumah).</li> <li><code>connect()</code>: Tamu mendatangi alamat hotel (IP Server) dan mengetuk pintu tertentu (Port Server).</li> <li><code>send()</code> / <code>recv()</code>: Tamu berbicara dengan resepsionis.</li> <li><code>close()</code>: Tamu pulang.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#23-konsep-blocking-vs-non-blocking-io","title":"2.3 Konsep Blocking vs Non-Blocking I/O","text":"<p>Salah satu jebakan terbesar bagi pemula di pemrograman jaringan adalah sifat dasar socket yang Blocking.</p> <p>Apa itu Blocking? Bayangkan Anda menelepon Customer Service bank. Anda harus menunggu (holding) sambil mendengarkan musik sampai ada CS yang mengangkat. Selama menunggu, Anda tidak bisa melakukan hal lain. Anda terpaku di situ. *   Dalam kode: Saat program memanggil <code>accept()</code> atau <code>recv()</code>, program akan berhenti total (hang/freeze) di baris tersebut sampai ada data yang masuk. Jika tidak ada yang connect selama 1 jam, program diam selama 1 jam.</p> <p>Konteks Industri: Untuk server yang melayani jutaan user (seperti WhatsApp), sifat blocking ini berbahaya. Jika server sibuk melayani User A dan \"memblokir\" diri, maka User B, C, dan D tidak akan terlayani. Solusinya adalah Non-Blocking I/O atau Concurrency yang akan kita bahas mendalam di Bab 6 dan 8.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#24-encoding-decoding-bahasa-data","title":"2.4 Encoding &amp; Decoding: Bahasa Data","text":"<p>Jaringan komputer tidak mengerti huruf 'A', 'B', atau emoji. Jaringan hanya mengerti arus listrik on/off yang direpresentasikan sebagai Bytes (urutan angka biner).</p> <p>Oleh karena itu, ada aturan wajib: \"String harus di-Encode sebelum dikirim, dan Bytes harus di-Decode setelah diterima.\"</p> <ul> <li>String (Human Readable): \"Halo Dunia\"</li> <li>Proses Encode (UTF-8): Mengubah \"Halo\" menjadi <code>b'\\x48\\x61\\x6c\\x6f'</code> (Bytes).</li> <li>Kabel Jaringan: Mengirim bytes tersebut.</li> <li>Proses Decode: Menerjemahkan kembali bytes menjadi \"Halo\".</li> </ul> <p>Jika Anda lupa melakukan ini, Python akan melempar <code>TypeError: a bytes-like object is required, not 'str'</code>.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#25-studi-kasus-hello-world-socket","title":"2.5 Studi Kasus: Hello World Socket","text":"<p>Mari kita implementasikan teori di atas ke dalam kode nyata. Kita akan membuat sistem komunikasi satu arah sederhana.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#strategi-kode","title":"Strategi Kode","text":"<p>Kita butuh dua terminal terpisah. 1.  Terminal 1 (Server): Dijalankan duluan. Ia akan stuck di posisi <code>accept()</code> menunggu tamu. 2.  Terminal 2 (Client): Dijalankan kemudian. Begitu ia jalan, Server akan \"bangun\", memproses pesan, lalu keduanya selesai.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#implementasi-server-latihan_2_serverpy","title":"Implementasi Server (<code>latihan_2_server.py</code>)","text":"<p>Perhatikan komentar pada kode untuk memahami state program di tiap baris.</p> <pre><code>import socket\n\n# 1. Membuat Soket (Domain: IPv4, Tipe: TCP)\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 2. Binding (Mengikat ke alamat localhost port 12345)\n# localhost artinya server hanya bisa diakses dari komputer ini saja (aman untuk latihan)\nserver_socket.bind(('localhost', 12345))\n\n# 3. Listening (Mempersiapkan antrian, max 1 antrian)\nserver_socket.listen(1)\nprint(\"Server: Saya siap dan sedang menunggu tamu di port 12345...\")\n\n# 4. Accepting (BLOCKING CALL)\n# Program akan BERHENTI di sini sampai ada Client yang connect.\nconn, addr = server_socket.accept()\nprint(f\"Server: Tamu datang dari alamat {addr}\")\n\n# 5. Komunikasi Data\n# Terima data mentah (bytes), lalu decode ke string\nmsg = conn.recv(1024).decode('utf-8')\nprint(f\"Server: Tamu berkata '{msg}'\")\n\n# Kirim balasan (jangan lupa encode ke bytes)\nconn.send(\"Halo Tamu, salam kenal!\".encode('utf-8'))\n\n# 6. Menutup Koneksi\nconn.close()\nprint(\"Server: Sesi selesai.\")\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#implementasi-client-latihan_2_clientpy","title":"Implementasi Client (<code>latihan_2_client.py</code>)","text":"<pre><code>import socket\n\n# 1. Membuat Soket\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 2. Connect (Mengetuk pintu server)\n# Pastikan IP dan Port SAMA PERSIS dengan server\nprint(\"Client: Mencoba menghubungi server...\")\nclient_socket.connect(('localhost', 12345))\n\n# 3. Kirim Pesan\npesan = \"Halo Server! Ini percobaan pertama saya.\"\nclient_socket.send(pesan.encode('utf-8')) # Encode string ke bytes\n\n# 4. Terima Balasan\nresponse = client_socket.recv(1024).decode('utf-8') # Decode bytes ke string\nprint(f\"Client: Mendapat balasan '{response}'\")\n\n# 5. Tutup\nclient_socket.close()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#26-tugas-mandiri-critical-thinking","title":"2.6 Tugas Mandiri (Critical Thinking)","text":"<p>Cobalah eksperimen berikut untuk menguji pemahaman Anda:</p> <ol> <li>Analisis Error: Jalankan <code>client.py</code> TANPA menjalankan <code>server.py</code> terlebih dahulu. Catat pesan error yang muncul. Mengapa error itu terjadi secara logis? (Refleksikan langkah <code>connect</code>).</li> <li>Modifikasi Protokol: Ubah kode agar Client bisa mengirim dua kali pesan sebelum Server membalas. Apakah Server perlu memanggil <code>recv()</code> dua kali juga? Apa yang terjadi jika Server hanya <code>recv()</code> satu kali?</li> <li>Investigasi Port: Coba ubah Port di server menjadi <code>80</code>. Kemungkinan besar akan gagal/acces denied (terutama di Linux/Mac/Windows Admin). Mengapa Port 80 spesial? (Hubungkan dengan materi Well-known Ports di Bab 1).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-2","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 2","text":"<p>File: <code>latihan_2_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef run_client():\n    # 1. Membuat object socket\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 2. Connect ke server\n    host = 'localhost'\n    port = 5000\n\n    try:\n        print(f\"Mencoba menghubungkan ke {host}:{port}...\")\n        client_socket.connect((host, port))\n        print(\"Terhubung!\")\n\n        # 3. Send data\n        pesan = \"Halo Server, ini Client Fikom!\"\n        client_socket.send(pesan.encode('utf-8'))\n\n        # 4. Receive response\n        data = client_socket.recv(1024)\n        print(f\"Respon Server: {data.decode('utf-8')}\")\n\n    except ConnectionRefusedError:\n        print(\"Koneksi ditolak! Pastikan Server sudah berjalan.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        # 5. Close\n        client_socket.close()\n\nif __name__ == \"__main__\":\n    run_client()\n</code></pre></p> <p>File: <code>latihan_2_kalkulator.py</code> <pre><code># Credit: Fikom UIT\ndef kalkulator():\n    print(\"--- Kalkulator Sederhana ---\")\n    a = float(input(\"Angka 1: \"))\n    b = float(input(\"Angka 2: \"))\n\n    print(f\"Hasil Tambah: {a + b}\")\n    print(f\"Hasil Kurang: {a - b}\")\n    print(f\"Hasil Kali: {a * b}\")\n    if b != 0:\n        print(f\"Hasil Bagi: {a / b}\")\n    else:\n        print(\"Tidak bisa membagi dengan nol\")\n\nif __name__ == \"__main__\":\n    kalkulator()\n</code></pre></p> <p>File: <code>latihan_2_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef run_server():\n    # 1. Membuat object socket\n    # AF_INET = IPv4, SOCK_STREAM = TCP\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 2. Bind (Mengikat ke alamat IP dan Port)\n    host = 'localhost' # Bisa juga '0.0.0.0' untuk menerima dari luar network\n    port = 5000\n    server_socket.bind((host, port))\n\n    # 3. Listen (Mulai mendengarkan)\n    # Angka 1 berarti antrian koneksi maksimum (backlog)\n    server_socket.listen(1)\n    print(f\"Server berjalan di {host}:{port}, menunggu client...\")\n\n    # 4. Accept (Menerima koneksi - BLOCKING)\n    # conn = objek socket baru khusus untuk client ini\n    # addr = alamat client (ip, port)\n    conn, addr = server_socket.accept()\n    print(f\"Koneksi diterima dari: {addr}\")\n\n    # 5. Receive &amp; Send\n    try:\n        data = conn.recv(1024) # Buffer size 1024 bytes\n        message = data.decode('utf-8')\n        print(f\"Client mengirim: {message}\")\n\n        reply = f\"Server menerima: {message}\"\n        conn.send(reply.encode('utf-8'))\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        # 6. Close connection\n        conn.close()\n        server_socket.close()\n        print(\"Koneksi ditutup.\")\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-3-protokol-tcp-aplikasi-chat","title":"Bab 3: Protokol TCP (Aplikasi Chat)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan karakteristik utama protokol TCP (Reliability, Ordering, Handshake) dan perbedaannya dengan komunikasi data biasa. 2.  Menerapkan logika perulangan (looping) dalam komunikasi socket untuk menciptakan koneksi persisten. 3.  Membangun aplikasi Chat Sederhana dua arah (Client-Server) menggunakan protokol TCP. 4.  Mendiagnosa keterbatasan model Blocking I/O pada komunikasi real-time.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#31-pendahuluan-dari-kirim-surat-ke-telepon","title":"3.1 Pendahuluan: Dari \"Kirim Surat\" ke \"Telepon\"","text":"<p>Pada bab sebelumnya, aplikasi kita bekerja seperti mengirim surat: Client mengirim pesan, Server menerima, membalas, lalu koneksi ditutup (hang up). Selesai.</p> <p>Namun, komunikasi dunia nyata jarang sekali sesingkat itu. Bayangkan jika setiap kali Anda ingin bicara satu kalimat dengan teman, Anda harus menutup telepon dan menelepon ulang. Sangat tidak efisien, bukan?</p> <p>Di Bab 3 ini, kita akan meningkatkan level aplikasi kita dari sekadar \"Hello World\" menjadi Aplikasi Chat. Kuncinya adalah Persistensi: menjaga pintu komunikasi tetap terbuka sampai salah satu pihak benar-benar ingin berhenti.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#32-karakteristik-inti-tcp","title":"3.2 Karakteristik Inti TCP","text":"<p>Transmission Control Protocol (TCP) adalah tulang punggung internet modern. Web (HTTP), Email (SMTP), dan Transfer File (FTP) semuanya berjalan di atas TCP. Mengapa? Karena TCP memiliki sifat Connection-Oriented.</p> <p>Analogi Panggilan Telepon: Sebelum kita bisa bicara (kirim data), nomor harus ditekan dan penerima harus mengangkat (Handshake). Selama pembicaraan, jika suara putus-putus, kita akan meminta lawan bicara mengulang (Retransmission). Data sampai secara berurutan.</p> <p>Empat Pilar TCP: 1.  Reliable (Andal): Menjamin paket sampai. Jika paket hilang di tengah jalan, TCP otomatis mengirim ulang tanpa programmer perlu menulis kode tambahan. Konteks Industri: Ini vital untuk aplikasi perbankan. Transfer uang Rp1 Miliar tidak boleh hilang 1 bit pun. 2.  Ordered (Berurutan): Paket <code>A, B, C</code> dikirim, maka akan diterima sebagai <code>A, B, C</code>. Bukan <code>C, A, B</code>. 3.  Stream-oriented: Data mengalir seperti air. Tidak ada batas jelas antar \"paket\", sehingga kita perlu teknik Framing (dibahas di Bab 5). 4.  Flow Control: Mencegah server overload dengan mengerem pengiriman jika penerima kewalahan.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#33-mekanisme-koneksi-the-3-way-handshake","title":"3.3 Mekanisme Koneksi: The 3-Way Handshake","text":"<p>Bagaimana TCP memastikan koneksi siap? Ia menggunakan prosedur salaman 3 tahap yang terkenal:</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram Sequence 3-Way Handshake (SYN -&gt; SYN-ACK -&gt; ACK)]</p> <ul> <li>Langkah 1 (SYN): \"Halo, saya mau bicara, boleh?\" (Client -&gt; Server)</li> <li>Langkah 2 (SYN-ACK): \"Boleh, saya siap. Kamu siap?\" (Server -&gt; Client)</li> <li>Langkah 3 (ACK): \"Oke, kita mulai!\" (Client -&gt; Server)</li> </ul> <p>Proses ini terjadi di belakang layar saat kita memanggil fungsi <code>connect()</code> di Python dan <code>accept()</code> meresponsnya.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#34-studi-kasus-membangun-aplikasi-chat-persistent-connection","title":"3.4 Studi Kasus: Membangun Aplikasi Chat (Persistent Connection)","text":"<p>Tantangan teknis terbesar dari aplikasi chat bukan pada pengiriman datanya, melainkan pada Logika Kontrol Alur (Control Flow).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#strategi-algoritma","title":"Strategi Algoritma","text":"<p>Jika di Bab 2 kita hanya menggunakan <code>conn.recv()</code> sekali, sekarang kita harus membungkusnya dalam: 1.  Infinite Loop (<code>while True</code>): Agar Server dan Client terus menerus mendengarkan pesan baru. 2.  Exit Condition: Harus ada \"kata kunci\" (misal: \"bye\") untuk memecahkan loop tersebut dan keluar (break).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#implementasi-server-chat-latihan_3_chat_serverpy","title":"Implementasi Server Chat (<code>latihan_3_chat_server.py</code>)","text":"<p>Dalam kode ini, perhatikan bagaimana blok <code>while True</code> menjaga koneksi tetap hidup.</p> <pre><code>import socket\n\n# Persiapan Socket (Sama seperti Bab 2)\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('localhost', 5000))\nserver.listen(1)\nprint(\"=== Chat Server Siap Berjalan ===\")\n\n# Menunggu tamu pertama\nconn, addr = server.accept()\nprint(f\"[!] Client {addr} bergabung ke dalam sesi chat.\")\n\n# INTI CHAT: Loop komunikasi\nwhile True:\n    try:\n        # 1. Terima Pesan (Akan BLOCKING/diam di sini sampai data masuk)\n        data = conn.recv(1024).decode('utf-8')\n\n        # 2. Cek Kondisi Keluar\n        # Jika data kosong (koneksi putus) atau user ketik 'bye'\n        if not data or data.lower() == 'bye':\n            print(\"[!] Client meminta mengakhiri sesi.\")\n            break\n\n        print(f\"Client &gt; {data}\")\n\n        # 3. Kirim Balasan\n        reply = input(\"Server (Anda) &gt; \")\n        conn.send(reply.encode('utf-8'))\n\n        # Cek jika Server yang ingin keluar\n        if reply.lower() == 'bye':\n            print(\"[!] Anda mengakhiri sesi.\")\n            break\n\n    except Exception as e:\n        print(f\"Error Terjadi: {e}\")\n        break\n\n# Bersih-bersih koneksi\nconn.close()\nserver.close()\nprint(\"=== Aplikasi Ditutup ===\")\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#keterbatasan-efek-chat-walkie-talkie","title":"Keterbatasan: Efek Chat \"Walkie-Talkie\"","text":"<p>Jika Anda menjalankan kode di atas, Anda akan menyadari fenomena aneh: \"Anda tidak bisa mengirim pesan sebelum lawan bicara membalas pesan terakhir Anda.\"</p> <ul> <li> <p>Penyebab Logis: Fungsi <code>input()</code> dan <code>recv()</code> bersifat Blocking.</p> <ul> <li>Saat kode sampai di baris <code>input()</code>, program server diam menunggu ketikan Dosen. Ia tidak bisa mengeksekusi <code>recv()</code> untuk menerima pesan mahasiswa.</li> <li>Akibatnya, komunikasi menjadi seperti Walkie-Talkie (Gantian ngomong), bukan seperti Telepon/WhatsApp (Bisa ngomong barengan).</li> </ul> </li> <li> <p>Solusi Industri: Untuk membuat Real-time Chat yang sesungguhnya (Duplex), kita membutuhkan Concurrency (Threading) yang akan menjadi topik utama di Bab 6.</p> </li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#35-tugas-mandiri-eksplorasi","title":"3.5 Tugas Mandiri (Eksplorasi)","text":"<p>Untuk memperdalam pemahaman, kerjakan tantangan berikut:</p> <ol> <li>Analisis Flow: Jalankan Server. Jalankan Client. Ketik pesan di Client, tapi JANGAN balas dulu di Server. Coba kirim pesan KEDUA dari Client. Apa yang terjadi? Pesan kedua tidak akan muncul di Server sampai pesan pertama dibalas. Mengapa? (Jelaskan berdasarkan konsep Buffer dan Blocking).</li> <li>Modifikasi Keamanan: Tambahkan logika autentikasi sederhana. Saat Client pertama kali connect, Server meminta \"Password\". Jika salah, Server langsung <code>conn.close()</code>. Jika benar, baru masuk <code>while True</code>.</li> <li>Implementasi Client: Kode di atas baru sisi Server. Tugas Anda adalah menulis ulang kode <code>latihan_3_chat_client.py</code> dengan logika <code>while True</code> yang serupa agar Client juga bisa membalas terus menerus.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-3","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 3","text":"<p>File: <code>latihan_3_chat_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef chat_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    print(\"=== Chat Client (TCP) ===\")\n\n    try:\n        client.connect(('localhost', 5000))\n        print(\"Terhubung ke Server! Silakan kirim pesan.\")\n\n        while True:\n            # Kirim pesan duluan\n            pesan = input(\"Anda (Client): \")\n            client.send(pesan.encode('utf-8'))\n\n            if pesan.lower() == 'bye':\n                print(\"[!] Anda mengakhiri obrolan.\")\n                break\n\n            # Tunggu balasan server\n            print(\"Menunggu balasan server...\")\n            response = client.recv(1024).decode('utf-8')\n\n            if not response or response.lower() == 'bye':\n                print(\"\\n[!] Server mengakhiri obrolan.\")\n                break\n\n            print(f\"\\nServer: {response}\")\n\n    except ConnectionRefusedError:\n        print(\"[!] Gagal connect. Server belum nyala?\")\n    except ConnectionResetError:\n        print(\"\\n[!] Koneksi terputus.\")\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    chat_client()\n</code></pre></p> <p>File: <code>latihan_3_chat_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef chat_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('localhost', 5000))\n    server.listen(1)\n    print(\"=== Chat Server (TCP) ===\")\n    print(\"Menunggu lawan bicara...\")\n\n    conn, addr = server.accept()\n    print(f\"Terhubung dengan {addr}\")\n\n    while True:\n        try:\n            # Terima pesan dari client\n            data = conn.recv(1024).decode('utf-8')\n\n            # Cek jika koneksi putus atau client bilang bye\n            if not data or data.lower() == 'bye':\n                print(\"\\n[!] Client mengakhiri obrolan.\")\n                break\n\n            print(f\"\\nClient: {data}\")\n\n            # Balas pesan\n            response = input(\"Anda (Server): \")\n            conn.send(response.encode('utf-8'))\n\n            if response.lower() == 'bye':\n                print(\"[!] Anda mengakhiri obrolan.\")\n                break\n\n        except ConnectionResetError:\n            print(\"\\n[!] Koneksi diputus paksa oleh client.\")\n            break\n\n    conn.close()\n    server.close()\n\nif __name__ == \"__main__\":\n    chat_server()\n</code></pre></p> <p>File: <code>latihan_3_grade.py</code> <pre><code># Credit: Fikom UIT\ndef cek_grade(nilai):\n    if nilai &gt;= 85:\n        return \"A\"\n    elif nilai &gt;= 70:\n        return \"B\"\n    elif nilai &gt;= 60:\n        return \"C\"\n    else:\n        return \"D\"\n\nif __name__ == \"__main__\":\n    n = int(input(\"Masukkan Nilai Angka: \"))\n    print(f\"Grade Anda: {cek_grade(n)}\")\n</code></pre></p> <p>File: <code>latihan_3_loop.py</code> <pre><code># Credit: Fikom UIT\nprint(\"--- Deret Ganjil ---\")\nfor i in range(1, 10, 2):\n    print(i, end=\" \")\nprint()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-4-protokol-udp-streaming-broadcasting","title":"Bab 4: Protokol UDP (Streaming &amp; Broadcasting)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membedakan karakteristik fundamental antara protokol TCP dan UDP dalam konteks keandalan dan kecepatan. 2.  Menganalisis skenario penggunaan yang tepat untuk UDP (Real-time Streaming, IoT, DNS). 3.  Mengimplementasikan aplikasi pengiriman data sensor menggunakan soket UDP (<code>SOCK_DGRAM</code>). 4.  Mendemonstrasikan perilaku connectionless dan fire-and-forget melalui pengujian kode.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#41-pendahuluan-filosofi-fire-and-forget","title":"4.1 Pendahuluan: Filosofi \"Fire and Forget\"","text":"<p>Jika TCP adalah \"Panggilan Telepon\" yang membutuhkan persetujuan kedua belah pihak sebelum bicara, maka UDP (User Datagram Protocol) adalah seperti mengirim Kartu Pos atau Penyiar Radio.</p> <p>Dalam analogi Kartu Pos: *   Anda menulis pesan, menempel perangko, dan memasukkannya ke kotak pos. *   Anda tidak tahu apakah kartu pos itu sampai besok, lusa, atau hilang di jalan. *   Anda tidak menunggu balasan untuk mengirim kartu pos berikutnya. *   Penerima tidak perlu \"sign in\" (handshake) untuk menerima kiriman Anda.</p> <p>Filosofi ini disebut \"Fire and Forget\" (Tembak dan Lupakan). Mungkin terdengar ceroboh, tapi dalam dunia jaringan, kecepatan seringkali lebih berharga daripada kesempurnaan.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#42-karakteristik-teknis-udp","title":"4.2 Karakteristik Teknis UDP","text":"<p>Mengapa kita membutuhkan protokol yang \"tidak bisa diandalkan\" (unreliable)? Karena TCP terlalu \"berat\" dan lambat untuk beberapa kasus.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Header TCP (Gemuk/Banyak Field) vs Header UDP (Kurus/Sedikit Field)]</p> <p>Karakteristik Utama: 1.  Connectionless: Tidak ada prosedur Handshake (SYN-ACK). Pengirim langsung menyemburkan data ke IP tujuan. 2.  Unreliable (Best Effort): Paket yang hilang tidak akan dikirim ulang. Paket yang datang rusak akan langsung dibuang. 3.  Low Overhead: Header UDP hanya 8 bytes, sedangkan TCP minimal 20 bytes. Ini membuat UDP sangat hemat bandwidth dan proses CPU. 4.  No Ordering: Paket ke-1 bisa saja sampai belakangan daripada Paket ke-2.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#43-studi-kasus-industri-kapan-pakai-udp","title":"4.3 Studi Kasus Industri: Kapan Pakai UDP?","text":"<p>Keputusan menggunakan UDP biasanya didasarkan pada pertanyaan: \"Apakah fatal jika ada sedikit data yang hilang?\"</p> <ol> <li> <p>Video Streaming &amp; VoIP (Zoom/YouTube Live):</p> <ul> <li>Jika 1 frame video hilang, layar hanya berkedip sedikit (glitch). TCP akan memaksa video pause (buffering) untuk mengambil paket yang hilang itu. UDP membiarkannya lewat agar video tetap real-time.</li> <li>Prinsip: Latency (kelancaran) &gt; Completeness (kelengkapan).</li> </ul> </li> <li> <p>Game Online (FPS/MOBA):</p> <ul> <li>Posisi musuh harus diupdate 60 kali per detik. Jika posisi detik ke-5 hilang, tidak masalah karena posisi detik ke-6 segera datang.</li> </ul> </li> <li> <p>IoT (Internet of Things):</p> <ul> <li>Sensor suhu mengirim data tiap detik. Sensor bertenaga baterai butuh protokol yang hemat energi (paket kecil).</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#44-perbedaan-implementasi-tcp-vs-udp","title":"4.4 Perbedaan Implementasi: TCP vs UDP","text":"<p>Mari bandingkan kode Python untuk kedua protokol ini. Perbedaan utamanya ada pada Tipe Socket dan Cara Mengirim.</p> Fitur TCP (Stream) UDP (Datagram) Konstanta Python <code>socket.SOCK_STREAM</code> <code>socket.SOCK_DGRAM</code> Koneksi Wajib <code>connect()</code> / <code>accept()</code> Tidak Ada (Langsung kirim) Fungsi Kirim <code>send()</code> (ke koneksi yang sudah ada) <code>sendto()</code> (wajib sebut alamat tujuan tiap kali kirim) Fungsi Terima <code>recv()</code> <code>recvfrom()</code> (mengembalikan data + alamat pengirim)"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#45-praktikum-simulasi-sensor-suhu-iot","title":"4.5 Praktikum: Simulasi Sensor Suhu IoT","text":"<p>Kita akan mensimulasikan lingkungan Industri 4.0. *   Sender (Client): Sebuah sensor suhu cerdas yang membaca data lingkungan dan menembakkannya ke server pusat setiap detik. *   Receiver (Server): Komputer pusat yang menampung data dari berbagai sensor.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-kode-receiver-server","title":"A. Kode Receiver (Server)","text":"<p>Server UDP sangat sederhana karena tidak perlu memelihara status koneksi/antrean client.</p> <pre><code># latihan_4_udp_receiver.py\nimport socket\n\n# 1. Gunakan SOCK_DGRAM untuk UDP\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# 2. Bind ke IP/Port tertentu (Agar paket tahu mau masuk lewat pintu mana)\n# 0.0.0.0 berarti menerima dari semua IP (bukan cuma localhost)\nsock.bind(('0.0.0.0', 9999))\n\nprint(\"=== UDP Monitoring Server Berjalan ===\")\nprint(\"Menunggu data sensor...\")\n\nwhile True:\n    # 3. recvfrom: Menerima paket DARI SIAPA SAJA\n    # Return value: (bytes_data, (ip_pengirim, port_pengirim))\n    data, addr = sock.recvfrom(1024)\n\n    # Decoding dan Display\n    pesan = data.decode('utf-8')\n    print(f\"[Sensor {addr}] Melaporkan: {pesan}\")\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-kode-sender-clientsensor","title":"B. Kode Sender (Client/Sensor)","text":"<p>Perhatikan bahwa Sensor tidak melakukan <code>connect</code>. Ia hanya butuh alamat tujuan.</p> <pre><code># latihan_4_udp_sender.py\nimport socket\nimport time\nimport random\n\n# PENTING: Gunakan SOCK_DGRAM\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Alamat Server Pusat\nTARGET_IP = 'localhost' # Ganti IP ini jika server ada di komputer lain\nTARGET_PORT = 9999\nTARGET_ADDR = (TARGET_IP, TARGET_PORT)\n\nprint(f\"=== Sensor Aktif. Mengirim data ke {TARGET_ADDR} ===\")\n\ntry:\n    while True:\n        # Simulasi pembacaan suhu (20-35 derajat Celcius)\n        suhu = random.randint(20, 35)\n        kelembaban = random.randint(40, 90)\n\n        # Format data: CSV sederhana atau JSON string\n        payload = f\"TEMP:{suhu}C|HUM:{kelembaban}%\"\n\n        # Kirim Paket (Fire!)\n        # Perhatikan kita harus menyertakan TARGET_ADDR di setiap pengiriman\n        sock.sendto(payload.encode('utf-8'), TARGET_ADDR)\n\n        print(f\"Mengirim -&gt; {payload}\")\n\n        # Sensor tidur sejenak untuk hemat baterai\n        time.sleep(1) \n\nexcept KeyboardInterrupt:\n    print(\"\\nSensor dimatikan.\")\n    sock.close()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#46-tugas-mandiri-eksperimen-fire-and-forget","title":"4.6 Tugas Mandiri (Eksperimen \"Fire and Forget\")","text":"<p>Lakukan percobaan berikut untuk membuktikan sifat UDP:</p> <ol> <li> <p>Pengujian Connectionless:</p> <ul> <li>Jalankan <code>sender.py</code> DULUAN tanpa menjalankan <code>receiver.py</code>.</li> <li>Apakah sender error? (Berbeda dengan TCP Client yang akan kena <code>ConnectionRefused</code>).</li> <li>Analisis: Ke mana perginya paket-paket tersebut?</li> </ul> </li> <li> <p>Broadcast/Multi-sensor:</p> <ul> <li>Jalankan satu <code>receiver.py</code>.</li> <li>Buka 3 terminal baru, jalankan <code>sender.py</code> di ketiganya secara bersamaan.</li> <li>Perhatikan output server. Apakah server bingung? Atau ia bisa menerima data dari ketiga sensor secara bergantian? Inilah kelebihan UDP dalam menangani many-to-one communication tanpa threading yang rumit (walaupun tetap antre di buffer).</li> </ul> </li> <li> <p>Cross-Machine:</p> <ul> <li>Jika ada teman satu jaringan WiFi, minta dia jalankan Receiver (ganti bind ke <code>0.0.0.0</code>). Cek IP-nya.</li> <li>Di laptop Anda, ubah <code>TARGET_IP</code> di Sender ke IP teman Anda.</li> <li>Lihat apakah data sensor Anda muncul di layarnya.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-4","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 4","text":"<p>File: <code>latihan_4_data_mhs.py</code> <pre><code># Credit: Fikom UIT\nmahasiswa = []\n\ndef tambah_mhs(nama, nim):\n    mhs = {\"nama\": nama, \"nim\": nim}\n    mahasiswa.append(mhs)\n\ndef tampilkan_semua():\n    print(f\"--- Data Mahasiswa ({len(mahasiswa)} orang) ---\")\n    for m in mahasiswa:\n        print(f\"NIM: {m['nim']} - Nama: {m['nama']}\")\n\nif __name__ == \"__main__\":\n    tambah_mhs(\"Andi\", \"A11.2025.001\")\n    tambah_mhs(\"Budi\", \"A11.2025.002\")\n    tampilkan_semua()\n</code></pre></p> <p>File: <code>latihan_4_udp_receiver.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef udp_receiver():\n    # Perhatikan: SOCK_DGRAM untuk UDP\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    # Tetap perlu bind agar bisa menerima data di port tertentu\n    ip = 'localhost'\n    port = 9999\n    try:\n        sock.bind((ip, port))\n        print(f\"UDP Server Listening on {ip}:{port}\")\n\n        while True:\n            # recvfrom mengembalikan (data, address_pengirim)\n            # Berbeda dengan recv() TCP yg cuma return data\n            data, addr = sock.recvfrom(1024)\n            print(f\"[{addr}] Data Masuk: {data.decode('utf-8')}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nServer dihentikan.\")\n    finally:\n        sock.close()\n\nif __name__ == \"__main__\":\n    udp_receiver()\n</code></pre></p> <p>File: <code>latihan_4_udp_sender.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport time\nimport random\n\ndef udp_sender():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    # UDP tidak perlu connect()\n    target_ip = 'localhost'\n    target_port = 9999\n    target_addr = (target_ip, target_port)\n\n    print(f\"Mulai mengirim data dummy ke {target_addr}...\")\n    print(\"Tekan Ctrl+C untuk berhenti.\")\n\n    try:\n        packet_count = 0\n        while True:\n            packet_count += 1\n            # Simulasi data sensor\n            suhu = random.randint(20, 40)\n            kelembapan = random.randint(40, 80)\n\n            payload = f\"#{packet_count} | Suhu: {suhu}C, Hum: {kelembapan}%\"\n\n            # sendto butuh argumen alamat tujuan setiap kali kirim\n            sock.sendto(payload.encode('utf-8'), target_addr)\n\n            print(f\"Sent: {payload}\")\n            time.sleep(1) # Kirim setiap 1 detik\n\n    except KeyboardInterrupt:\n        print(\"\\nPengiriman data dihentikan.\")\n    finally:\n        sock.close()\n\nif __name__ == \"__main__\":\n    udp_sender()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-5-error-handling-framing-data","title":"Bab 5: Error Handling &amp; Framing Data","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Mendiagnosa fenomena Sticky Packet dan Packet Fragmentation dalam komunikasi TCP. 2.  Menerapkan teknik Framing (Delimiter dan Length-Prefixed) untuk menjamin integritas data. 3.  Mengimplementasikan mekanisme Error Handling yang robust (Timeout, Try-Except) untuk menangani kegagalan jaringan. 4.  Memperbaiki kode komunikasi socket yang rentan terhadap putus koneksi tiba-tiba.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#51-pendahuluan-ilusi-kesempurnaan-tcp","title":"5.1 Pendahuluan: Ilusi Kesempurnaan TCP","text":"<p>Di Bab 3, kita belajar bahwa TCP itu reliable (dijamin sampai). Namun, ada satu jebakan besar: TCP menjamin Bytes sampai, tapi tidak menjamin Pesan sampai sebagai satu kesatuan utuh.</p> <p>Banyak programmer pemula berasumsi: *   \"Jika saya <code>send('Hello')</code> lalu <code>send('World')</code>, maka penerima akan <code>recv()</code> dapat 'Hello' lalu <code>recv()</code> dapat 'World'.\"</p> <p>Kenyataan Pahit: Penerima bisa saja mendapatkan: 1.  <code>HelloWorld</code> (Digabung/Sticky Packet) 2.  <code>He</code>, <code>lloWor</code>, <code>ld</code> (Terpecah/Fragmented)</p> <p>Mengapa? Karena TCP adalah Stream Oriented.</p> <p>Analogi Pipa Air: Bayangkan Anda menuangkan segelas air merah (Pesan A) dan segelas air biru (Pesan B) ke dalam satu pipa panjang. Di ujung pipa, air merah dan biru akan bercampur atau mengalir berkesinambungan. Penerima di ujung pipa tidak tahu mana batas antara gelas pertama dan kedua. Tugas kitalah sebagai programmer untuk memberi \"sekat\" atau wadah pada air tersebut. Sekat inilah yang disebut Framing.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#52-fenomena-sticky-packet-tcp-coalescing","title":"5.2 Fenomena \"Sticky Packet\" (TCP Coalescing)","text":"<p>Sticky Packet terjadi karena efisiensi jaringan. Algoritma TCP (seperti Nagle's Algorithm) menahan pengiriman data-data kecil dan menggumpalkannya menjadi satu paket besar agar hemat bandwidth.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Sender mengirim [A] [B] [C], tapi Receiver menerima [ABC] atau [AB] [C]]</p> <p>Dampak fatal jika tidak ditangani: *   Aplikasi Chat: Pesan user menumpuk jadi satu kalimat panjang tak terbaca. *   Game: Perintah \"Maju\" dan \"Tembak\" lumer jadi satu, karakter game diam saja.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#53-solusi-teknik-framing","title":"5.3 Solusi: Teknik Framing","text":"<p>Framing adalah seni membungkus data agar penerima tahu: \"Oh, pesan dimulai di sini dan berakhir di sini.\"</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#strategi-1-delimiter-tanda-pemisah","title":"Strategi 1: Delimiter (Tanda Pemisah)","text":"<p>Kita menyepakati karakter khusus sebagai tanda \"Stop\". Contoh paling umum adalah <code>\\n</code> (Enter/Newline). *   Format: <code>Pesan1\\nPesan2\\n</code> *   Cara Kerja: Penerima membaca byte demi byte sampai ketemu <code>\\n</code>. *   Kelemahan: Pesan itu sendiri tidak boleh mengandung <code>\\n</code> (bisa bikin bingung).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#strategi-2-length-prefixed-header-panjang","title":"Strategi 2: Length-Prefixed (Header Panjang)","text":"<p>Kita mengirimkan panjang data (angka) sebelum mengirim datanya. *   Format: <code>[4 BYTE BUFFER SIZE][DATA ASLI]</code> *   Contoh: Kirim \"Halo\" (4 huruf).     *   Header: <code>0004</code> (integer 4 byte)     *   Body: <code>Halo</code> *   Kelebihan: Sangat robust, bisa mengirim data binary (foto/suara).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#54-praktikum-mengatasi-sticky-packet-dengan-delimiter","title":"5.4 Praktikum: Mengatasi Sticky Packet dengan Delimiter","text":"<p>Dalam Python, kita bisa menggunakan fitur <code>makefile()</code> pada objek socket untuk mengubahnya menjadi objek file. Ini memungkinkan kita menggunakan metode <code>readline()</code> yang otomatis membaca sampai karakter <code>\\n</code>. Sangat praktis!</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-kode-server-robust-framing","title":"A. Kode Server (Robust Framing)","text":"<p>Perhatikan penggunaan blok <code>with conn</code> dan <code>makefile</code>.</p> <pre><code># latihan_5_sticky_server.py\nimport socket\n\ndef run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # SO_REUSEADDR agar port bisa langsung dipaka ulang setelah server mati\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    server.bind(('localhost', 5555))\n    server.listen(5)\n    print(\"=== Server Framing Siap (Port 5555) ===\")\n\n    while True:\n        try:\n            conn, addr = server.accept()\n            print(f\"[!] Koneksi dari {addr}\")\n\n            # MEMBUAT FILE OBJECT DARI SOCKET\n            # Mode 'r' = Read, encoding utf-8\n            # Ini memungkinkan kita pakai 'for line in stream'\n            with conn:\n                stream = conn.makefile('r', encoding='utf-8')\n\n                # Loop ini otomatis membaca per baris (\\n)\n                # Jika tidak ada \\n, dia menunggu (buffer)\n                for line in stream:\n                    line = line.strip() # Hapus \\n di ujung\n                    if not line: break\n\n                    print(f\"Terima Pesan Utuh: {line}\")\n\n                    # Balas juga dengan framing \\n\n                    conn.send(f\"ACK: {line}\\n\".encode('utf-8'))\n\n            print(f\"[!] {addr} terputus.\")\n\n        except Exception as e:\n            print(f\"Error Server: {e}\")\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-kode-client-sticky-simulator","title":"B. Kode Client (Sticky Simulator)","text":"<p>Kita akan sengaja mengirim banyak pesan dengan sangat cepat untuk memaksa terjadinya Sticky Packet.</p> <pre><code># latihan_5_sticky_client.py\nimport socket\nimport time\n\ndef run_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('localhost', 5555))\n\n    print(\"=== Uji Coba Sticky Packet ===\")\n    print(\"Mengirim 10 pesan secepat kilat...\")\n\n    # Payload pesan diakhiri \\n sebagai delimiter\n    pesan = \"HaloServer\\n\"\n\n    # Kirim 10x berturut-turut tanpa jeda\n    # Tanpa framing di server, ini pasti akan diterima sebagai satu blob raksasa\n    for i in range(10):\n        data = f\"PesanKe-{i+1}|{pesan}\"\n        client.send(data.encode('utf-8'))\n\n    print(\"Selesai mengirim. Cek terminal Server!\")\n    client.close()\n\nif __name__ == \"__main__\":\n    run_client()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#55-error-handling-yang-wajib-ada","title":"5.5 Error Handling yang Wajib Ada","text":"<p>Selain framing, aplikasi jaringan harus tahan banting (Resilient). 1.  Timeout: Apa yang terjadi jika server hang?     *   Solusi: <code>sock.settimeout(10.0)</code> -&gt; Jika 10 detik diam, raise Exception. 2.  Connection Reset: Apa yang terjadi jika kabel client dicabut paksa?     *   Solusi: Wajib bungkus <code>send/recv</code> dalam blok <code>try...except (ConnectionResetError, BrokenPipeError)</code>.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#56-tugas-mandiri-debugging-network","title":"5.6 Tugas Mandiri (Debugging Network)","text":"<ol> <li>Analisis Log: Jalankan Server dan Client di atas. Perhatikan output Server. Apakah pesan tercetak satu per satu dengan rapi?<ul> <li>Tantangan: Coba hapus <code>\\n</code> di kode Client, lalu jalankan. Lihat apa yang terjadi di server (Server akan diam menunggu/hang karena <code>readline</code> tidak pernah menemukan \"Enter\").</li> </ul> </li> <li>Implementasi Timeout: Tambahkan <code>client.settimeout(2.0)</code> pada kode client, lalu buat server tidur (<code>time.sleep(3)</code>) sebelum membalas. Tangkap error timeout tersebut dengan <code>try-except</code>.</li> <li>Studi Kasus: Mengapa protokol HTTP menggunakan Content-Length di headernya? Diskusikan hubungannya dengan materi Framing Length-Prefixed.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-5","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 5","text":"<p>File: <code>latihan_5_fungsi.py</code> <pre><code># Credit: Fikom UIT\ndef luas_persegi_panjang(panjang, lebar):\n    return panjang * lebar\n\ndef sapa(nama=\"Teman\"):\n    print(f\"Halo, {nama}!\")\n\nif __name__ == \"__main__\":\n    l = luas_persegi_panjang(10, 5)\n    print(f\"Luas: {l}\")\n    sapa()\n</code></pre></p> <p>File: <code>latihan_5_sticky_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport time\n\ndef sticky_packet_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('localhost', 5000))\n\n    # CASE 1: Kirim pesan \"nempel\" (Sticky Packet)\n    # Kita kirim banyak pesan sekaligus tanpa delay\n    print(\"Mengirim 5 pesan sekaligus...\")\n\n    # Perhatikan: Setiap pesan DIAKHIRI '\\n' sebagai delimiter\n    paket_besar = \"\"\n    for i in range(5):\n        paket_besar += f\"PesanKe-{i+1}\\n\"\n\n    # Kirim sekaligus dalam satu kali send()\n    # Di sisi jaringan, ini akan jadi satu blok data\n    client.send(paket_besar.encode('utf-8'))\n\n    # Baca balasan satu per satu\n    socket_file = client.makefile('r', encoding='utf-8')\n    try:\n        for _ in range(5):\n            response = socket_file.readline().strip()\n            print(f\"Jawab Server: {response}\")\n    except Exception as e:\n        print(f\"Error baca: {e}\")\n\n    client.close()\n\nif __name__ == \"__main__\":\n    sticky_packet_client()\n</code></pre></p> <p>File: <code>latihan_5_sticky_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef sticky_packet_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('localhost', 5000))\n    server.listen(1)\n    print(\"=== Sticky Packet Server (Delimiter Mode) ===\")\n\n    conn, addr = server.accept()\n    print(f\"Connected: {addr}\")\n\n    # Teknik: Menggunakan makefile() agar bisa pakai readline()\n    # Ini cara termudah menangani framing berbasis delimiter '\\n'\n    socket_file = conn.makefile('r', encoding='utf-8')\n\n    conn.settimeout(10.0) # Jika 10 detik diam, anggap putus\n\n    try:\n        while True:\n            # readline() akan terus membaca sampai ketemu '\\n'\n            # Ini otomatis menangani fragmentasi atau penggabungan paket\n            line = socket_file.readline()\n\n            if not line:\n                break # Koneksi putus\n\n            # Hilangkan whitespace/newline di ujung\n            cleaned_msg = line.strip()\n            print(f\"Terima Pesan Utuh: {cleaned_msg}\")\n\n            # Kirim balasan juga harus pakai delimiter\n            conn.send(f\"ACK: {cleaned_msg}\\n\".encode('utf-8'))\n\n    except socket.timeout:\n        print(\"Timeout! Client terlalu lama diam.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        socket_file.close() # Penting menutup reader wrapper\n        conn.close()\n        server.close()\n\nif __name__ == \"__main__\":\n    sticky_packet_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-6-concurrency-part-i-threading","title":"Bab 6: Concurrency Part I - Threading","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membandingkan arsitektur Iterative Server (Single Thread) dengan Concurrent Server (Multi-threaded). 2.  Menerapkan modul <code>threading</code> Python untuk menangani multiple clients secara simultan. 3.  Mengidentifikasi potensi bahaya Race Condition pada sumber daya bersama (Shared Resources). 4.  Membangun aplikasi Chat Room yang stabil dengan mekanisme sinkronisasi data (Locking).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#61-limitasi-server-single-thread","title":"6.1 Limitasi Server Single-Thread","text":"<p>Bayangkan sebuah restoran yang hanya memiliki satu pelayan. 1.  Tamu A datang, pelayan mencatat pesanan, ke dapur, masak, lalu menyajikan. 2.  Selama proses itu, Tamu B, C, dan D harus mengantre di luar pintu. Pelayan tidak bisa menyapa mereka sebelum Tamu A selesai makan dan pulang.</p> <p>Inilah gambaran server yang kita buat di Bab 1-5. Disebut Iterative Server. Model ini aman dan mudah, tapi tidak scalable. Di dunia nyata, user tidak mau menunggu user lain selesai chatting baru bisa login.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#62-solusi-concurrency-dengan-threading","title":"6.2 Solusi Concurrency dengan Threading","text":"<p>Concurrency adalah seni mengerjakan banyak hal \"sekaligus\". Dalam Python, cara termudah adalah menggunakan Threading.</p> <p>Analogi Dapur Restoran (Multi-thread): *   Process (Restoran): Adalah wadah utamanya. Punya memori (bahan makanan) yang sama. *   Main Thread (Manager): Tugasnya hanya berdiri di pintu depan, menyambut tamu (<code>accept()</code>), dan memanggil pelayan baru. *   Worker Thread (Pelayan Tambahan): Setiap kali ada tamu masuk, Manager mempekerjakan satu pelayan khusus untuk melayani tamu itu sampai pulang. *   Jika ada 100 tamu, akan ada 100 pelayan yang bekerja berbarengan dalam satu restoran.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Main Thread yang melakukan spawn Worker Thread untuk setiap Client 1, 2, 3]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#63-bahaya-laten-race-condition","title":"6.3 Bahaya Laten: Race Condition","text":"<p>Kekuatan Threading adalah memori bersama (Shared Memory), tapi itu juga kelemahan terbesarnya. Jika dua thread mencoba mengubah data yang sama secara bersamaan, data bisa rusak. Ini disebut Race Condition.</p> <p>Contoh Kasus Rekening Bank: *   Saldo Awal: Rp 100.000. *   Thread A (Topup) membaca saldo: 100rb. *   Thread B (Tarik Tunai) membaca saldo: 100rb (karena A belum selesai update). *   Thread A menambah 50rb -&gt; Simpan 150rb. *   Thread B menarik 20rb -&gt; Simpan 80rb (Menimpa hasil kerja A!). *   Hasil Akhir: Saldo jadi 80rb. Padahal seharusnya 130rb.</p> <p>Solusinya? Locking (Gembok). Sebelum menyentuh data sensitif, thread harus mengunci data tersebut agar thread lain menunggu.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#64-praktikum-chat-room-multi-client-broadcast-system","title":"6.4 Praktikum: Chat Room Multi-Client (Broadcast System)","text":"<p>Kita akan membuat server \"WhatsApp Group\" sederhana. *   Fitur: Setiap pesan dari Client A akan diteruskan (broadcast) ke Client B, C, dan D. *   Tantangan: Daftar <code>clients</code> adalah Shared Resource. Kita harus hati-hati saat menambah/menghapus anggota agar tidak tabrakan dengan proses broadcast.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kode-server-latihan_6_thread_serverpy","title":"Kode Server (<code>latihan_6_thread_server.py</code>)","text":"<p>Pelajari bagaimana kita memisahkan logika <code>handle_client</code> ke fungsi sendiri.</p> <pre><code>import socket\nimport threading\n\n# List global untuk menampung semua koneksi aktif\n# Ini adalah SHARED RESOURCE\nclients = []\nclients_lock = threading.Lock() # Gembok pengaman\n\ndef broadcast(message, sender_conn):\n    \"\"\"Mengirim pesan ke semua client KECUALI pengirimnya sendiri\"\"\"\n    # Kita kunci dulu sebelum iterasi agar list tidak berubah di tengah jalan\n    with clients_lock:\n        for client in clients:\n            if client != sender_conn:\n                try:\n                    client.send(message)\n                except:\n                    # Jika gagal kirim, anggap putus (akan dibersihkan nanti)\n                    client.close()\n                    # Menghapus di sini agak tricky saat iterasi, \n                    # jadi biasanya kita skip dulu.\n                    pass\n\ndef handle_client(conn, addr):\n    \"\"\"Fungsi Tugas untuk setiap Worker Thread\"\"\"\n    print(f\"[NEW CONNECTION] {addr} connected.\")\n\n    # Masukkan tamu baru ke buku tamu (dengan aman)\n    with clients_lock:\n        clients.append(conn)\n\n    try:\n        conn.send(\"Selamat datang di Chat Room!\".encode('utf-8'))\n\n        while True:\n            # Tunggu pesan (Blocking di thread ini saja, tidak ganggu thread lain)\n            message = conn.recv(1024)\n            if not message:\n                break\n\n            # Format pesan: \"[IP]: Isi Pesan\"\n            msg_decoded = message.decode('utf-8')\n            output = f\"[{addr[1]}]: {msg_decoded}\"\n            print(output)\n\n            # Sebarkan pesan\n            broadcast(output.encode('utf-8'), conn)\n\n    except Exception as e:\n        print(f\"[ERROR] {addr}: {e}\")\n    finally:\n        # Bersih-bersih saat tamu pulang\n        print(f\"[DISCONNECT] {addr} keluar.\")\n        with clients_lock:\n            if conn in clients:\n                clients.remove(conn)\n        conn.close()\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 5555))\n    server.listen()\n    print(\"[SERVER STARTED] Menunggu di port 5555...\")\n\n    while True:\n        # 1. Main Thread standby di sini\n        conn, addr = server.accept()\n\n        # 2. Begitu ada tamu, buat Thread baru\n        thread = threading.Thread(target=handle_client, args=(conn, addr))\n\n        # 3. Jalankan Thread (Start dan lupakan)\n        # Daemon=True artinya thread ini akan mati otomatis jika program utama mati\n        thread.daemon = True \n        thread.start()\n\n        print(f\"[ACTIVE CONNECTIONS] {threading.active_count() - 1}\")\n\nif __name__ == \"__main__\":\n    start_server()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kode-client","title":"Kode Client","text":"<p>Anda bisa menggunakan kembali kode Client Chat Bab 3 atau Client Telnet (Putty). Keduanya kompatibel karena protokolnya hanya TCP raw text.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#65-tugas-mandiri-critical-analysis","title":"6.5 Tugas Mandiri (Critical Analysis)","text":"<ol> <li>Observasi Thread: Jalankan Server. Buka 3 Client. Lihat output di server <code>[ACTIVE CONNECTIONS]</code>. Apakah angkanya sesuai?</li> <li>Stress Test: Apa yang terjadi jika 1000 client masuk bersamaan?<ul> <li>Analisis: Python Threading punya batas (overhead memori OS). Untuk skala masif (10.000+ user), Threading tidak efisien. Di sinilah kita nanti membutuhkan Asynchronous I/O (Bab 8).</li> </ul> </li> <li>Identifikasi Race Condition: Coba hapus semua baris <code>with clients_lock:</code> di kode server. Jalankan script \"bomber\" yang menyambungkan dan memutus 100 koneksi secepat mungkin. Kemungkinan besar program akan crash dengan error seperti <code>RuntimeError: dictionary changed size during iteration</code>. Ini bukti nyata Race Condition!</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-6","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 6","text":"<p>File: <code>latihan_6_file_io.py</code> <pre><code># Credit: Fikom UIT\ndef tulis_log(pesan):\n    try:\n        with open(\"log.txt\", \"a\") as f:\n            f.write(pesan + \"\\n\")\n        print(\"Log berhasil ditulis.\")\n    except Exception as e:\n        print(f\"Gagal menulis file: {e}\")\n\nif __name__ == \"__main__\":\n    tulis_log(\"Sistem dimulai...\")\n    tulis_log(\"User login.\")\n</code></pre></p> <p>File: <code>latihan_6_thread_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport threading\n\n# Global variables\nCLIENTS = [] # Menyimpan daftar koneksi aktif\nLOCK = threading.Lock() # Untuk mencegah race condition saat akses list\n\ndef broadcast(message, sender_conn=None):\n    \"\"\"\n    Mengirim pesan ke SEMUA client yang terhubung,\n    kecuali si pengirim (opsional).\n    \"\"\"\n    with LOCK: # Kunci akses agar tidak bentrok\n        for conn in CLIENTS:\n            if conn != sender_conn:\n                try:\n                    conn.send(message)\n                except:\n                    # Jika gagal kirim, mungkin koneksi sudah putus/rusak\n                    conn.close()\n                    # Kita remove nanti atau biarkan handle_client yang urus\n                    pass\n\ndef handle_client(conn, addr):\n    \"\"\"\n    Fungsi yang akan dijalankan oleh setiap Thread.\n    Menangani komunikasi unik dengan satu client.\n    \"\"\"\n    print(f\"[NEW] {addr} connected.\")\n\n    # Masukkan ke daftar global\n    with LOCK:\n        CLIENTS.append(conn)\n\n    broadcast(f\"\\n[INFO] {addr} bergabung ke chat room!\\n\".encode('utf-8'), conn)\n\n    try:\n        conn.send(\"Selamat datang di Fikom Chat Room!\\n\".encode('utf-8'))\n        while True:\n            data = conn.recv(1024)\n            if not data:\n                break # Client putus\n\n            msg = data.decode('utf-8')\n            # Format pesan broadast\n            final_msg = f\"[{addr[1]}] says: {msg}\"\n            broadcast(final_msg.encode('utf-8'), conn)\n\n    except Exception as e:\n        print(f\"[ERR] {addr}: {e}\")\n    finally:\n        # Bersih-bersih saat client disconnect\n        with LOCK:\n            if conn in CLIENTS:\n                CLIENTS.remove(conn)\n\n        broadcast(f\"\\ninfo: {addr} telah keluar.\\n\".encode('utf-8'))\n        conn.close()\n        print(f\"[DISCONNECT] {addr} disconnected.\")\n\ndef run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # SO_REUSEADDR agar port langsung bisa dipakai lagi setelah stop\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    server.bind(('0.0.0.0', 6000)) # Port 6000\n    server.listen(5)\n    print(\"=== Multi-Threaded Chat Server Running on Port 6000 ===\")\n\n    while True:\n        # Main Thread hanya fokus menerima tamu\n        conn, addr = server.accept()\n\n        # Buat thread baru untuk melayani tamu tersebut\n        # target=fungsi yg dijalankan, args=argumen fungsi tsb\n        thread = threading.Thread(target=handle_client, args=(conn, addr))\n        thread.start()\n\n        print(f\"[ACTIVE CONNECTIONS] {threading.active_count() - 1}\")\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-7-serialisasi-data-json-pickle","title":"Bab 7: Serialisasi Data (JSON &amp; Pickle)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan konsep Serialization dan Deserialization serta urgensinya dalam pertukaran data jaringan. 2.  Membandingkan format data JSON (Universal) dan Pickle (Python-Specific) berdasarkan kelebihan dan risiko keamanannya. 3.  Menerapkan modul <code>json</code> untuk mengirim dan menerima struktur data kompleks (Dictionary, List). 4.  Merancang protokol aplikasi berbasis Request-Response sederhana.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#71-pendahuluan-masalah-bahasa-antar-komputer","title":"7.1 Pendahuluan: Masalah \"Bahasa\" Antar Komputer","text":"<p>Sampai sejauh ini, kita hanya mengirim data berupa string mentah (<code>\"Hello World\"</code>). Namun, aplikasi nyata membutuhkan data yang terstruktur. Bagaimana jika kita ingin mengirim data Mahasiswa yang berisi <code>Nama</code>, <code>NIM</code>, <code>Nilai</code>, dan <code>Daftar Mata Kuliah</code> sekaligus?</p> <p>Socket tidak mengerti apa itu \"List\", \"Dictionary\", atau \"Object Class\". Socket hanya mengerti Bytes. Jika kita memaksakan mengirim objek Python <code>{'nama': 'Budi'}</code>, socket akan menolak dengan error <code>TypeError</code>.</p> <p>Analogi Furniture IKEA (Flat-pack): *   Objek Python (Lemari Jadi): Sebuah struktur data yang utuh, memakan tempat, dan kompleks. Tidak bisa dimasukkan ke dalam kotak pengiriman (kabel jaringan) begitu saja. *   Serialisasi (Pembongkaran): Lemari dibongkar menjadi papan-papan datar (bytes/string) dan dimasukkan ke kardus. Sekarang ia bisa dikirim lewat kurir (jaringan). *   Deserialisasi (Perakitan): Di rumah penerima, papan-papan datar tadi dirakit kembali menjadi Lemari utuh sesuai petunjuk manual.</p> <p>Proses mengubah Objek menjadi Bytes disebut Marshalling/Serialization. Kebalikannya disebut Unmarshalling/Deserialization.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#72-format-data-json-vs-pickle","title":"7.2 Format Data: JSON vs Pickle","text":"<p>Ada dua cara populer di Python untuk melakukan \"packing\" ini.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Bagan alur Serialisasi (Objek -&gt; JSON String -&gt; Bytes) dan Deserialisasi]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-json-javascript-object-notation","title":"A. JSON (JavaScript Object Notation)","text":"<p>Ini adalah standar emas dunia web modern. Hampir semua bahasa (Java, PHP, Go, C#) mengerti JSON. *   Karakteristik: Berbasis Teks, Terbaca Manusia (Human Readable). *   Tipe Data: Terbatas pada String, Number, Boolean, List, dan Dictionary (Object). Tidak bisa menyimpan fungsi atau class khusus. *   Penggunaan: Pertukaran data antar aplikasi berbeda (misal: Backend Python dengan Frontend Web React).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-pickle-python-object-serialization","title":"B. Pickle (Python Object Serialization)","text":"<p>Format eksklusif milik Python. *   Karakteristik: Berbasis Biner (Binary), Tidak terbaca manusia, Sangat Kuat. *   Tipe Data: Bisa menyimpan hampir APA SAJA di Python (Custom Classes, Functions, bahkan object Socket itu sendiri - walau tidak disarankan). *   Peringatan Keamanan (CRITICAL):     &gt; JANGAN PERNAH melakukan <code>pickle.load()</code> pada data yang dikirim oleh pihak yang tidak dikenal. File pickle yang jahat bisa berisi kode untuk menghapus harddisk Anda saat dibuka.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#73-studi-kasus-protokol-database-mahasiswa","title":"7.3 Studi Kasus: Protokol Database Mahasiswa","text":"<p>Mari kita bangun server database sederhana. Protokolnya adalah sebagai berikut: 1.  Request: Client mengirim JSON berisi <code>{ \"command\": \"CARI\", \"nim\": \"101\" }</code>. 2.  Response: Server mencari di dictionary, lalu membalas dengan JSON <code>{ \"status\": \"OK\", \"data\": { ... } }</code> atau <code>{ \"status\": \"ERROR\", \"pesan\": \"Tidak ditemukan\" }</code>.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kode-server-latihan_7_json_serverpy","title":"Kode Server (<code>latihan_7_json_server.py</code>)","text":"<p>Perhatikan bagaimana kita menggunakan <code>json.loads</code> untuk membaca perintah dan <code>json.dumps</code> untuk membalas.</p> <pre><code>import socket\nimport json\n\n# Database dummy dalam memori\nDATABASE = {\n    \"101\": {\"nama\": \"Budi Santoso\", \"prodi\": \"Teknik Informatika\", \"ipk\": 3.75},\n    \"102\": {\"nama\": \"Siti Aminah\", \"prodi\": \"Sistem Informasi\", \"ipk\": 3.90},\n    \"103\": {\"nama\": \"Andi Wijaya\", \"prodi\": \"Teknik Komputer\", \"ipk\": 3.50}\n}\n\ndef run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 6000))\n    server.listen(5)\n    print(\"=== Database Server (JSON) Berjalan di Port 6000 ===\")\n\n    while True:\n        client, addr = server.accept()\n        print(f\"[!] Koneksi dari {addr}\")\n\n        try:\n            # 1. Terima data byte\n            request_bytes = client.recv(4096)\n            if not request_bytes: break\n\n            # 2. Deserialisasi (Bytes -&gt; String -&gt; Dict)\n            request_str = request_bytes.decode('utf-8')\n            print(f\"DEBUG REQ: {request_str}\")\n\n            # Parsing JSON (Bisa error jika format salah)\n            request_data = json.loads(request_str)\n\n            # 3. Logika Bisnis (Cek Command)\n            command = request_data.get('command')\n            nim = request_data.get('nim')\n\n            response = {}\n\n            if command == 'GET_MHS':\n                if nim in DATABASE:\n                    response = {\n                        \"status\": \"SUKSES\", \n                        \"data\": DATABASE[nim]\n                    }\n                else:\n                    response = {\"status\": \"GAGAL\", \"pesan\": \"NIM tidak ditemukan\"}\n            else:\n                response = {\"status\": \"ERROR\", \"pesan\": \"Perintah tidak dikenali\"}\n\n            # 4. Serialisasi (Dict -&gt; String JSON -&gt; Bytes)\n            response_bytes = json.dumps(response).encode('utf-8')\n            client.send(response_bytes)\n\n        except json.JSONDecodeError:\n            error_msg = json.dumps({\"status\": \"ERROR\", \"pesan\": \"Format JSON Invalid\"}).encode()\n            client.send(error_msg)\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            client.close()\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kode-client-latihan_7_json_clientpy","title":"Kode Client (<code>latihan_7_json_client.py</code>)","text":"<pre><code>import socket\nimport json\n\ndef cek_mahasiswa(nim):\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('localhost', 6000))\n\n    # 1. Persiapkan Request (Dict)\n    request = {\n        \"command\": \"GET_MHS\",\n        \"nim\": nim\n    }\n\n    # 2. Serialisasi &amp; Kirim\n    print(f\"Mengirim Request untuk NIM: {nim}...\")\n    client.send(json.dumps(request).encode('utf-8'))\n\n    # 3. Terima &amp; Deserialisasi\n    response_bytes = client.recv(4096)\n    response = json.loads(response_bytes.decode('utf-8'))\n\n    # 4. Tampilkan Hasil\n    print(\"Respon Server:\", json.dumps(response, indent=2))\n    client.close()\n\nif __name__ == \"__main__\":\n    # Test cases\n    cek_mahasiswa(\"101\") # Ada\n    cek_mahasiswa(\"999\") # Tidak ada\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#74-tugas-mandiri-eksplorasi-format","title":"7.4 Tugas Mandiri (Eksplorasi Format)","text":"<ol> <li>Tambah Fitur: Modifikasi Server dan Client agar bisa menjalankan perintah <code>ADD_MHS</code> untuk menambah data baru ke dictionary <code>DATABASE</code>.</li> <li>Eksperimen Pickle: Buat script terpisah yang mencoba mengirimkan objek Class Python (misal <code>class Mahasiswa</code>) menggunakan modul <code>pickle</code>. Buktikan bahwa server yang menggunakan <code>pickle.loads</code> bisa membaca objek tersebut beserta method-methodnya.</li> <li>Analisis Keamanan: Mengapa JSON lebih disukai daripada Pickle untuk Public API? (Hubungkan dengan fakta bahwa JSON adalah teks murni yang pasif, sedangkan Pickle adalah eksekusi kode).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-7","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 7","text":"<p>File: <code>latihan_7_class.py</code> <pre><code># Credit: Fikom UIT\nclass Mahasiswa:\n    def __init__(self, nama, nim):\n        self.nama = nama\n        self.nim = nim\n\n    def perkenalan(self):\n        print(f\"Halo, saya {self.nama}, NIM {self.nim}\")\n\nif __name__ == \"__main__\":\n    m1 = Mahasiswa(\"Siti\", \"12345\")\n    m1.perkenalan()\n</code></pre></p> <p>File: <code>latihan_7_json_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport json\n\ndef json_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    try:\n        client.connect(('localhost', 7000))\n\n        print(\"Menu Request:\")\n        print(\"1. Cari Mahasiswa (101, 102, 103)\")\n        nim_input = input(\"Masukkan NIM: \")\n\n        # Buat Dictionary Request\n        request_packet = {\n            \"command\": \"GET_MHS\",\n            \"nim\": nim_input\n        }\n\n        # Serialisasi ke String JSON\n        json_str = json.dumps(request_packet)\n\n        # Kirim\n        client.send(json_str.encode('utf-8'))\n\n        # Terima Balasan\n        raw_response = client.recv(4096).decode('utf-8')\n\n        # Deserialisasi Balasan\n        response_dict = json.loads(raw_response)\n\n        print(\"\\n--- Respon Server ---\")\n        if response_dict['status'] == 'OK':\n            mhs = response_dict['data']\n            print(f\"Nama : {mhs['nama']}\")\n            print(f\"Prodi: {mhs['prodi']}\")\n            print(f\"IPK  : {mhs['ipk']}\")\n        else:\n            print(f\"Error: {response_dict.get('msg')}\")\n\n    except Exception as e:\n        print(f\"Error connection: {e}\")\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    json_client()\n</code></pre></p> <p>File: <code>latihan_7_json_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport json\n\n# Database dummy\nDATABASE = {\n    \"101\": {\"nama\": \"Andi Saputra\", \"prodi\": \"Informatika\", \"ipk\": 3.75},\n    \"102\": {\"nama\": \"Budi Santoso\", \"prodi\": \"Sistem Informasi\", \"ipk\": 3.40},\n    \"103\": {\"nama\": \"Citra Lestari\", \"prodi\": \"Informatika\", \"ipk\": 3.90}\n}\n\ndef json_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('localhost', 7000))\n    server.listen(5)\n    print(\"=== JSON Database Server Running on Port 7000 ===\")\n\n    while True:\n        conn, addr = server.accept()\n        print(f\"Connection from {addr}\")\n\n        try:\n            # Terima data (asumsi max 4096 bytes)\n            raw_data = conn.recv(4096).decode('utf-8')\n            if not raw_data:\n                continue\n\n            print(f\"Request Raw: {raw_data}\")\n\n            # 1. Deserialisasi (String JSON -&gt; Dict Python)\n            try:\n                request = json.loads(raw_data)\n            except json.JSONDecodeError:\n                response = {\"status\": \"ERROR\", \"msg\": \"Invalid JSON Format\"}\n                conn.send(json.dumps(response).encode('utf-8'))\n                conn.close()\n                continue\n\n            # 2. Proses Logika\n            command = request.get(\"command\")\n            nim = request.get(\"nim\")\n\n            response = {}\n            if command == \"GET_MHS\":\n                data = DATABASE.get(nim)\n                if data:\n                    response = {\"status\": \"OK\", \"data\": data}\n                else:\n                    response = {\"status\": \"NOT_FOUND\", \"msg\": f\"NIM {nim} tidak ditemukan\"}\n            else:\n                 response = {\"status\": \"ERROR\", \"msg\": \"Unknown Command\"}\n\n            # 3. Serialisasi Balasan (Dict -&gt; JSON String -&gt; Bytes)\n            json_reply = json.dumps(response)\n            conn.send(json_reply.encode('utf-8'))\n\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            conn.close()\n\nif __name__ == \"__main__\":\n    json_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-8-asynchronous-io-concurrency-part-ii","title":"Bab 8: Asynchronous I/O (Concurrency Part II)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membandingkan efisiensi Multi-threading vs Asynchronous I/O dalam menangani beban kerja tinggi (C10k Problem). 2.  Menjelaskan arsitektur Event Loop dan peran Coroutines (<code>async</code>/<code>await</code>) dalam manajemen tugas. 3.  Mengimplementasikan server non-blocking menggunakan pustaka <code>asyncio</code> Python. 4.  Mendiagnosa kesalahan umum dalam pemrograman async seperti Blocking Code yang mematikan Event Loop.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#81-pendahuluan-mengapa-threading-saja-tidak-cukup","title":"8.1 Pendahuluan: Mengapa Threading Saja Tidak Cukup?","text":"<p>Di Bab 6, kita menggunakan Threading untuk melayani banyak klien. Setiap tamu diberi satu pelayan khusus. Cara ini efektif, namun mahal. Bayangkan jika tamu yang datang ada 10.000 orang. *   Apakah restoran sanggup menggaji 10.000 pelayan? *   Apakah dapur muat menampung 10.000 pelayan?</p> <p>Dalam komputer, setiap Thread membutuhkan memori (Stack) sekitar 8MB. <code>10.000 thread x 8MB = 80.000MB (80GB) RAM</code>. Server akan langsung crash sebelum sempat melayani. Masalah ini dikenal sebagai C10k Problem (Problem 10.000 Koneksi).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#82-konsep-asynchronous-the-super-tuner","title":"8.2 Konsep Asynchronous: The Super Tuner","text":"<p>Asynchronous I/O menawarkan pendekatan berbeda: Single Thread, tapi Super Cepat.</p> <p>Analogi Grandmaster Catur (Simultan): Bayangkan seorang Juara Dunia Catur (Server) melawan 50 orang amatir (Clients) sekaligus. 1.  Grandmaster mendatangi Meja 1, melangkah, lalu langsung pindah ke Meja 2. 2.  Ia tidak menunggu Lawan 1 berpikir. Ia memanfaatkan waktu \"mikikirnya\" Lawan 1 untuk melayani Lawan 2, 3, dst. 3.  Dalam waktu singkat, ia bisa melayani 50 langkah tanpa diam sama sekali.</p> <p>Dalam analogi ini: *   Grandmaster = Event Loop (Prosesor Utama). *   Waktu Lawan Berpikir = I/O Latency (Menunggu database/network). *   Langkah Catur = Task kecil yang dieksekusi CPU.</p> <p>Dengan model ini, Satu Thread bisa melayani ribuan koneksi selama ia tidak pernah \"menunggu\" (blocking).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#83-arsitektur-asyncio-python","title":"8.3 Arsitektur Asyncio Python","text":"<p>Sejak Python 3.5, kita memiliki sintaks <code>async</code> dan <code>await</code>.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Event Loop yang berputar mengambil task dari antrian, menjalankannya sebentar, lalu menaruhnya kembali jika task itu butuh I/O]</p> <p>Tiga Istilah Kunci: 1.  Event Loop: Manajer yang tidak kenal lelah. Dia berteriak: \"Siapa yang datanya sudah siap? Oke kamu! Sekarang kamu!\" 2.  Coroutine (<code>async def</code>): Fungsi yang bisa di-pause. Jika dia butuh data jaringan, dia bilang ke Event Loop: \"Bro, saya mau tunggu data dulu, saya pause ya. Lanjutin kerjaan lain gih.\" 3.  Await (<code>await</code>): Titik di mana fungsi menyerahkan kontrol kembali ke Event Loop.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#84-praktikum-high-performance-async-server","title":"8.4 Praktikum: High-Performance Async Server","text":"<p>Kita akan menulis server yang mampu menangani ribuan koneksi dengan RAM sangat kecil. Kita akan menggunakan API level tinggi <code>asyncio.start_server</code> yang jauh lebih bersih daripada menggunakan socket mentah.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kode-server-latihan_8_async_serverpy","title":"Kode Server (<code>latihan_8_async_server.py</code>)","text":"<pre><code>import asyncio\n\nasync def handle_client(reader, writer):\n    \"\"\"\n    Coroutine ini akan dijalankan untuk SETIAP client yang connect.\n    Bayangkan ini sebagai 'Langkah Catur' untuk satu meja.\n    \"\"\"\n    addr = writer.get_extra_info('peername')\n    print(f\"[BARU] Koneksi dari {addr}\")\n\n    try:\n        while True:\n            # 1. Baca Data (Non-Blocking)\n            # keyword 'await' artinya: \"Tunggu data masuk, tapi JANGAN BLOKIR server.\"\n            # \"Silakan server urus client lain dulu. Kalau data sudah ada, bangunkan saya.\"\n            data = await reader.read(100) # Baca maksimal 100 byte\n\n            if not data:\n                print(f\"[PUTUS] {addr} menutup koneksi.\")\n                break\n\n            message = data.decode().strip()\n            print(f\"[{addr}] Mengirim: {message}\")\n\n            # 2. Proses &amp; Balas\n            response = f\"Echo: {message}\\n\"\n            writer.write(response.encode())\n\n            # 3. Pastikan data terkirim (Drain buffer)\n            await writer.drain()\n\n    except Exception as e:\n        print(f\"[ERROR] {addr}: {e}\")\n    finally:\n        writer.close()\n        await writer.wait_closed() # Pastikan socket benar-benar tutup\n\nasync def main():\n    # Membuat Server Async\n    server = await asyncio.start_server(\n        handle_client, '127.0.0.1', 8888)\n\n    addrs = ', '.join(str(sock.getsockname()) for sock in server.sockets)\n    print(f'=== Async Server Berjalan di {addrs} ===')\n\n    # Biarkan server berjalan selamanya\n    async with server:\n        await server.serve_forever()\n\nif __name__ == '__main__':\n    # Memulai Event Loop\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\nServer Dimatikan.\")\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#85-analisis-kode","title":"8.5 Analisis Kode","text":"<p>Perhatikan bedanya dengan Bab 6 (Threading): *   Tidak ada <code>threading.Thread</code>: Kita tidak membuat thread baru. Semua berjalan di Main Thread. *   Magic Keyword <code>await</code>: Inilah kuncinya. Setiap kali ada <code>await</code>, fungsi itu \"mengalah\" dan membiarkan Event Loop mengerjakan hal lain. *   Reader/Writer: Asyncio membungkus socket mentah menjadi objek Stream yang lebih mudah dikelola.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#86-bahaya-blocking-code-di-dunia-async","title":"8.6 Bahaya: Blocking Code di Dunia Async","text":"<p>Apa yang terjadi jika Anda memasukkan kode ini di dalam fungsi <code>handle_client</code>? <pre><code>import time\ntime.sleep(5)  # BAHAYA!!! \n</code></pre> BENCANA. <code>time.sleep</code> adalah fungsi Blocking. Dia akan memberhentikan seluruh Event Loop. Artinya, selama 5 detik itu, TIDAK ADA SATUPUN dari 10.000 client yang bisa dilayani. Server mati total. Solusi: Gunakan <code>await asyncio.sleep(5)</code>. Ini versi non-blocking yang ramah event loop.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#87-tugas-mandiri-stress-test","title":"8.7 Tugas Mandiri (Stress Test)","text":"<ol> <li>Jalankan Server Async.</li> <li>Buktikan Konsep: Buka dua terminal Client. Kirim pesan dari Client A, lalu Client B. Keduanya harusnya lancar tanpa jeda.</li> <li>Hancurkan Server: Sisipkan <code>time.sleep(10)</code> di dalam Loop <code>handle_client</code>. Coba connect pakai Client A. Lalu coba connect Client B. Client B tidak akan bisa connect selama 10 detik. Ini membuktikan bahwa Asyncio itu Single Threaded.</li> <li>Eksplorasi: Bandingkan penggunaan RAM antara <code>latihan_6_thread_server.py</code> dan <code>latihan_8_async_server.py</code> saat menghadapi 100 koneksi (gunakan Task Manager/htop). Asyncio harusnya jauh lebih hemat.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-8","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 8","text":"<p>File: <code>latihan_8_async_server.py</code> <pre><code># Credit: Fikom UIT\nimport asyncio\nimport socket\n\n# Asyncio membutuhkan definisi fungsi dengan 'async def'\nasync def handle_client(reader, writer):\n    # Dapatkan alamat client\n    addr = writer.get_extra_info('peername')\n    print(f\"[NEW] {addr} connected.\")\n\n    writer.write(f\"Halo {addr}, selamat datang di Async Server!\\n\".encode())\n    await writer.drain() # Pastikan data terkirim\n\n    try:\n        while True:\n            # await: \"Tunggu data masuk, tapi sambil nunggu, kerjakan yang lain\"\n            data = await reader.read(100)\n            if not data:\n                break\n\n            message = data.decode().strip()\n            print(f\"[{addr}] Received: {message}\")\n\n            # Echo balik\n            response = f\"Echo: {message}\\n\"\n            writer.write(response.encode())\n            await writer.drain()\n\n    except Exception as e:\n        print(f\"Error {addr}: {e}\")\n    finally:\n        print(f\"[CLOSE] {addr} closed.\")\n        writer.close()\n        await writer.wait_closed()\n\nasync def main():\n    # Membuat server dengan API High-Level asyncio\n    server = await asyncio.start_server(\n        handle_client, '127.0.0.1', 8888)\n\n    addr = server.sockets[0].getsockname()\n    print(f'=== Asyncio Server Serving on {addr} ===')\n\n    # Server forever loop\n    async with server:\n        await server.serve_forever()\n\nif __name__ == \"__main__\":\n    try:\n        # Menjalankan Event Loop\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\nServer Stopped.\")\n</code></pre></p> <p>File: <code>latihan_8_cek_ip.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\nhostname = socket.gethostname()\nip = socket.gethostbyname(hostname)\n\nprint(f\"Hostname: {hostname}\")\nprint(f\"IP Address: {ip}\")\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-9-io-multiplexing-select-poll","title":"Bab 9: I/O Multiplexing (<code>select</code> &amp; <code>poll</code>)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan mekanisme dasar kernel OS dalam memantau deskriptor file (file descriptors) menggunakan <code>select</code>. 2.  Membedakan antara Blocking I/O, Non-Blocking I/O, dan I/O Multiplexing. 3.  Mengimplementasikan server konkruen hemat memori menggunakan modul <code>select</code> tanpa threading. 4.  Mendiagnosa batasan skalabilitas <code>select</code> dibanding mekanisme modern seperti <code>epoll</code> (Linux) atau IOCP (Windows).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#91-pendahuluan-membongkar-magic-asyncio","title":"9.1 Pendahuluan: Membongkar \"Magic\" Asyncio","text":"<p>Di Bab 8, kita menggunakan <code>asyncio</code> yang terasa \"ajaib\". Satu orang (thread) bisa menangani ribuan tugas. Tapi bagaimana caranya? Di Bab ini, kita akan membongkar mesin di balik layar tersebut. Kita akan belajar cara kerja \"Manual\"-nya. Teknik ini disebut I/O Multiplexing.</p> <p>Analogi Satpam CCTV: *   Blocking (Bab 2): Satpam berdiri di depan Pintu 1. Jika ada orang di Pintu 10, dia tidak tahu. *   Threading (Bab 6): Anda merekrut 100 Satpam untuk menjaga 100 pintu. Mahal dan ruangan penuh sesak. *   I/O Multiplexing (Bab 9): Hanya ada Satu Satpam, tapi dia duduk di ruang kontrol dengan 100 Layar CCTV. Dia diam saja sampai melihat ada gerakan di salah satu layar. Jika Pintu 5 bergerak, dia merespons Pintu 5. Jika Pintu 80 bergerak, dia ke Pintu 80.</p> <p>Inilah inti dari fungsi <code>select()</code>: Sebuah syscall (panggilan sistem) yang meminta OS untuk \"Tolong awasi 100 socket ini, dan bangunkan saya hanya jika ada yang datanya siap.\"</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#92-arsitektur-select","title":"9.2 Arsitektur <code>select</code>","text":"<p>Fungsi <code>select</code> menerima tiga daftar socket: 1.  Readable (<code>rlist</code>): Daftar socket yang ingin dipantau apakah \"Ada data masuk?\". 2.  Writable (<code>wlist</code>): Daftar socket yang ingin dipantau apakah \"Buffer kosong/siap dikirimi data?\". 3.  Exceptional (<code>xlist</code>): Daftar socket yang error.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram blok fungsi select() yang menerima input list socket dan mengeluarkan output list socket yang aktif]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#93-praktikum-chat-server-low-level","title":"9.3 Praktikum: Chat Server \"Low Level\"","text":"<p>Kita akan membangun ulang Chat Server Bab 6 (Threading), tapi kali ini tanpa Thread sama sekali. Kita akan melihat betapa efisiennya kode ini dari segi penggunaan Memori (RAM), karena tidak ada overhead stack per-thread.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#logika-algoritma","title":"Logika Algoritma","text":"<ol> <li>Buat List <code>SOCKET_LIST</code> yang awalnya hanya berisi Server Socket utama.</li> <li>Masuk Infinite Loop:<ul> <li>Panggil <code>read_sockets, _, _ = select(SOCKET_LIST, [], [])</code>.</li> <li>Looping <code>read_sockets</code>:<ul> <li>Jika itu Server Socket Master: Berarti ada tamu baru (<code>accept</code>). Tambahkan tamu ke <code>SOCKET_LIST</code>.</li> <li>Jika itu Client Socket: Berarti ada pesan (<code>recv</code>).<ul> <li>Jika pesan ada: Broadcast ke yang lain.</li> <li>Jika pesan kosong: Client putus, hapus dari <code>SOCKET_LIST</code>.</li> </ul> </li> </ul> </li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kode-server-latihan_9_select_serverpy","title":"Kode Server (<code>latihan_9_select_server.py</code>)","text":"<pre><code>import socket\nimport select\nimport sys\n\ndef run_chat_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.bind(('0.0.0.0', 9000))\n    server_socket.listen(10)\n\n    # List untuk menampung semua socket yang sedang dipantau oleh 'Satpam'\n    socket_list = [server_socket]\n\n    # Dictionary opsional untuk menyimpan nama user (jika mau)\n    clients = {} \n\n    print(f\"=== Select Server (Single Thread) berjalan di port 9000 ===\")\n\n    while True:\n        # Panggilan ke OS: \"Tolong pantau socket_list ini\"\n        # Fungsi ini akan BLOCKING sampai minimal ada satu socket yang aktif\n        read_sockets, _, exception_sockets = select.select(socket_list, [], socket_list)\n\n        for sock in read_sockets:\n            # KASUS 1: Ada tamu baru mengetuk pintu Server Utama\n            if sock == server_socket:\n                sockfd, addr = server_socket.accept()\n                socket_list.append(sockfd) # Daftarkan tamu baru ke CCTV\n                clients[sockfd] = addr\n                print(f\"[BARU] Client {addr} bergabung\")\n\n            # KASUS 2: Ada pesan dari salah satu Client\n            else:\n                try:\n                    data = sock.recv(1024)\n                    if data:\n                        # Ada pesan, sebarkan (Broadcast)\n                        pesan = f\"[{clients[sock]}]: {data.decode()}\\n\"\n                        # Kirim ke semua orang kecuali server dan pengirimnya sendiri\n                        for client_sock in socket_list:\n                            if client_sock != server_socket and client_sock != sock:\n                                try:\n                                    client_sock.send(pesan.encode())\n                                except:\n                                    client_sock.close()\n                                    if client_sock in socket_list:\n                                        socket_list.remove(client_sock)\n                    else:\n                        # Data kosong artinya koneksi diputus normal (FIN)\n                        if sock in socket_list:\n                            socket_list.remove(sock)\n                        print(f\"[KELUAR] Client {clients[sock]} pergi\")\n                        sock.close()\n                        del clients[sock]\n\n                except:\n                    # Error koneksi (Force Close)\n                    if sock in socket_list:\n                        socket_list.remove(sock)\n                    sock.close()\n                    continue\n\n        # Handle Exception sockets (Error)\n        for sock in exception_sockets:\n            socket_list.remove(sock)\n            sock.close()\n\nif __name__ == \"__main__\":\n    sys.exit(run_chat_server())\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#94-perbandingan-performa","title":"9.4 Perbandingan Performa","text":"Fitur Threading (Bab 6) Select (Bab 9) Asyncio (Bab 8) Logic Mudah (Sequential) Sulit (Event Driven) Menengah (Async/Await) RAM Boros (Stack/Thread) Sangat Hemat Hemat CPU Context Switching Cost Efficient Efficient Limit OS Thread Limit <code>FD_SETSIZE</code> (biasanya 1024) Hampir Unlimited"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#batasan-select","title":"Batasan <code>select</code>","text":"<p>Meskipun cepat, <code>select</code> punya kelemahan klasik: ia hanya sanggup memantau maksimal 1024 koneksi di Windows (dan beberapa Linux lama). Inilah alasan mengapa <code>asyncio</code> modern menggunakan <code>epoll</code> (Linux) atau <code>IOCP</code> (Windows) di balik layar, bukan <code>select</code>. Namun, <code>select</code> adalah dasar pemahamannya.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#95-tugas-mandiri-analisis-skalabilitas","title":"9.5 Tugas Mandiri (Analisis Skalabilitas)","text":"<ol> <li>Jalankan Server.</li> <li>Koneksikan 5 Client. Chatting seperti biasa. Rasanya sama persis dengan versi Threading, bukan?</li> <li>Critical Thinking: Apa yang terjadi jika kode <code>select</code> di atas, saat memproses pesan dari Client A, kita melakukan proses berat (misal: loop 1 juta kali) sebelum kembali ke <code>select()</code>?<ul> <li>Jawab: Seluruh server akan macet (Lag). Client B, C, D tidak akan terlayani. Ini membuktikan bahwa <code>select</code> server juga bersifat Single Threaded Blockable. Server tidak boleh melakukan operasi CPU berat di dalam loop ini.</li> </ul> </li> <li>Tugas: Tambahkan fitur \"Private Message\". Jika client mengetik <code>@ip_tujuan pesan</code>, server hanya meneruskan pesan ke socket dengan IP tersebut.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-9","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 9","text":"<p>File: <code>latihan_9_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport threading\n\n# Kita gunakan thread hanya untuk menerima pesan agar input user tidak terganggu\n# Client ini sederhana saja, fokus utama bab ini ada di Server.\n\ndef receive_messages(sock):\n    while True:\n        try:\n            data = sock.recv(1024)\n            if not data: break\n            print(f\"\\n{data.decode()}\\nAnda: \", end=\"\")\n        except:\n            break\n\ndef run_simple_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        client.connect(('localhost', 9000))\n    except:\n        print(\"Gagal connect. Server mati?\")\n        return\n\n    threading.Thread(target=receive_messages, args=(client,), daemon=True).start()\n\n    print(\"Terhubung ke Chat Room! Ketik pesan Anda:\")\n    while True:\n        try:\n            msg = input(\"Anda: \")\n            client.send(msg.encode())\n        except KeyboardInterrupt:\n            break\n\n    client.close()\n\nif __name__ == \"__main__\":\n    run_simple_client()\n</code></pre></p> <p>File: <code>latihan_9_select_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport select\n\ndef run_select_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.bind(('0.0.0.0', 9000))\n    server_socket.listen(10)\n    server_socket.setblocking(False) # Penting! Non-blocking mode\n\n    # Daftar socket yang akan dipantau\n    inputs = [server_socket]\n    clients = {} # Mapping socket -&gt; addr\n\n    print(\"=== Select-based Chat Server on Port 9000 ===\")\n\n    while True:\n        # Panggil select untuk memantau aktivitas I/O\n        # readable = daftar socket yang siap di-READ (ada data masuk)\n        # writable = daftar socket yang siap di-WRITE (buffer kosong)\n        # exceptional = daftar socket yang error\n        readable, writable, exceptional = select.select(inputs, [], inputs)\n\n        for s in readable:\n            if s is server_socket:\n                # Ada koneksi baru\n                conn, addr = s.accept()\n                conn.setblocking(False)\n                inputs.append(conn)\n                clients[conn] = addr\n                print(f\"[NEW] Connection from {addr}\")\n            else:\n                # Ada pesan dari client yang sudah connect\n                try:\n                    data = s.recv(1024)\n                    if data:\n                        # Broadcast ke yang lain\n                        msg = f\"[{clients[s][1]}] {data.decode()}\".encode()\n                        for target in inputs:\n                            if target is not server_socket and target is not s:\n                                try:\n                                    target.send(msg)\n                                except:\n                                    target.close()\n                                    inputs.remove(target)\n                    else:\n                        # Data kosong artinya client close\n                        print(f\"[CLOSE] {clients[s]} disconnected\")\n                        if s in inputs: inputs.remove(s)\n                        s.close()\n                        del clients[s]\n                except Exception as e:\n                    print(f\"Error: {e}\")\n                    if s in inputs: inputs.remove(s)\n                    s.close()\n                    del clients[s]\n\nif __name__ == \"__main__\":\n    run_select_server()\n</code></pre></p> <p>File: <code>latihan_9_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 9999))\nserver.listen(5)\nprint(\"Server listening on port 9999\")\n\nwhile True:\n    client, addr = server.accept()\n    print(f\"Connection from {addr}\")\n    client.send(b\"Halo dari Server!\")\n    client.close()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-10-protokol-http-web-server","title":"Bab 10: Protokol HTTP &amp; Web Server","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menguraikan struktur paket HTTP (Header, Body, Status Code, Methods) secara mendetail. 2.  Mendemonstrasikan cara kerja Request-Response Cycle di balik setiap interaksi web. 3.  Membangun Web Server sederhana dari nol (from scratch) menggunakan TCP Socket yang mampu melayani file statis. 4.  Mendiagnosa kode status HTTP (200, 404, 500) dan implikasinya terhadap pengalaman pengguna.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#101-pendahuluan-bahasa-internet","title":"10.1 Pendahuluan: Bahasa Internet","text":"<p>Jika TCP/IP adalah jalan raya, maka HTTP (Hypertext Transfer Protocol) adalah bahasa yang digunakan truk-truk pengangkut barang di jalan raya tersebut. Ini adalah protokol yang memungkinkan Anda membaca teks ini di browser sekarang.</p> <p>Banyak Web Developer modern menggunakan framework seperti Django, Flask, atau Node.js dan lupa apa yang terjadi di belakang layar. Sebagai Network Programmer, kita akan membongkar kotak hitam tersebut dan melihat roda gigi yang berputar di dalamnya.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#102-analogi-memesan-makanan-di-restoran","title":"10.2 Analogi: Memesan Makanan di Restoran","text":"<p>HTTP bekerja dengan model Request-Response. Mari kita bayangkan Restoran:</p> <ol> <li>Client (Pelanggan): Anda duduk dan melihat buku menu (Browser).</li> <li>Server (Dapur): Tempat makanan dibuat/disimpan.</li> <li>HTTP Request (Pesanan): Anda memanggil pelayan dan berkata: \"Tolong bawakan Nasi Goreng (URL) satu porsi (GET).\"</li> <li>Proses: Pelayan ke dapur. Dapur mengecek bahan.</li> <li>HTTP Response (Sajian):<ul> <li>Status 200 OK: Pelayan datang membawa Nasi Goreng. Selamat menikmati!</li> <li>Status 404 Not Found: Pelayan datang dengan tangan kosong: \"Maaf mas, Nasi Goreng habis.\"</li> <li>Status 500 Internal Error: Dapur kebakaran. Tidak ada yang bisa dilayani.</li> </ul> </li> </ol> <p>Poin Penting: Stateless. HTTP itu pelupa. Setelah pelayan mengantar makanan, dia lupa siapa Anda. Jika Anda mau pesan minum, Anda harus memanggil dan memperkenalkan diri ulang (kecuali pakai Cookies - materi lanjutan).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#103-anatomi-paket-http","title":"10.3 Anatomi Paket HTTP","text":"<p>Web Server sebenarnya hanyalah Socket Server (Bab 2) yang memanipulasi teks dengan format tertentu.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-http-request-apa-yang-browser-kirim","title":"A. HTTP Request (Apa yang Browser Kirim)","text":"<p>Saat Anda mengetik <code>google.com</code>, browser mengirim teks ini ke server Google:</p> <pre><code>GET /index.html HTTP/1.1\nHost: www.google.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\nAccept: text/html,application/xhtml+xml\n[Baris Kosong]\n[Body Kosong untuk GET]\n</code></pre> <ul> <li>Baris 1 (Request Line): <code>METODE PATH VERSI</code>.<ul> <li><code>GET</code>: Minta data.</li> <li><code>POST</code>: Kirim data (misal login form).</li> </ul> </li> <li>Headers: Metadata tentang siapa saya (User-Agent) dan apa yang saya bisa baca (Accept).</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-http-response-jawaban-server","title":"B. HTTP Response (jawaban Server)","text":"<p>Server membalas dengan format yang mirip:</p> <pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2026 12:28:53 GMT\nServer: Apache/2.4.1 (Unix)\nContent-Length: 154\nContent-Type: text/html\n\n&lt;html&gt;\n  &lt;head&gt;&lt;title&gt;Halo!&lt;/title&gt;&lt;/head&gt;\n  &lt;body&gt;&lt;h1&gt;Ini Website Saya&lt;/h1&gt;&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>Baris 1 (Status Line): <code>VERSI KODE PESAN</code>.</li> <li>Headers: Penting! <code>Content-Type</code> memberitahu browser apakah ini teks HTML, gambar JPG, atau video MP4.</li> <li>Body: Isi konten sesungguhnya.</li> </ul> <p>[Saran: Tambahkan Gambar/Diagram disini: Bedah anatomi Request vs Response side-by-side]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#104-praktikum-membangun-web-server-dari-nol","title":"10.4 Praktikum: Membangun Web Server dari Nol","text":"<p>Kita akan membuat Web Server tanpa install Apache/Nginx. Kita gunakan Python murni. Server ini nanti bisa Anda akses lewat Chrome/Edge.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#logika-server","title":"Logika Server","text":"<ol> <li>Buat Server Socket (TCP), listen di port 8080.</li> <li><code>accept</code> koneksi browser.</li> <li><code>recv</code> request dari browser (masih bytes). Decode ke string.</li> <li>Parsing: Ambil kata kedua dari baris pertama request. Itu adalah Nama File yang diminta (misal <code>/index.html</code>).</li> <li>File Handling:<ul> <li>Coba buka file tersebut dari harddisk.</li> <li>Jika ada: Baca isinya, kirim Header <code>200 OK</code>, lalu kirim isi file.</li> <li>Jika tidak ada: Kirim Header <code>404 Not Found</code>, lalu kirim halaman error HTML.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#implementasi-kode-latihan_10_web_serverpy","title":"Implementasi Kode (<code>latihan_10_web_server.py</code>)","text":"<pre><code>import socket\n\ndef handle_client(client_socket):\n    # 1. Terima Request Browser\n    request = client_socket.recv(1024).decode('utf-8')\n\n    # Validasi: Kadang browser kirim koneksi kosong\n    if not request:\n        client_socket.close()\n        return\n\n    # 2. Parsing Request Line untuk cari nama file\n    # Request: \"GET /index.html HTTP/1.1 ...\"\n    headers = request.split('\\n')\n    first_line = headers[0]\n\n    try:\n        # Ambil bagian path: \"/index.html\"\n        filename = first_line.split()[1]\n    except IndexError:\n        client_socket.close()\n        return\n\n    # Ubah \"/\" jadi \"/index.html\" (Default Page)\n    if filename == '/':\n        filename = '/index.html'\n\n    # Hapus slash depan agar bisa dibaca os.path. \" /index.html\" -&gt; \"index.html\"\n    filepath = filename.lstrip('/')\n\n    try:\n        # 3. Coba Buka File\n        # Mode 'rb' (Read Binary) penting agar bisa baca Gambar juga\n        with open(filepath, 'rb') as f:\n            content = f.read()\n\n        # 4. Susun Response SUKSES (200 OK)\n        response_header = \"HTTP/1.1 200 OK\\r\\n\"\n\n        # Deteksi Content-Type sederhana\n        if filepath.endswith(\".html\"):\n            mime_type = \"text/html\"\n        elif filepath.endswith(\".jpg\") or filepath.endswith(\".png\"):\n            mime_type = \"image/jpeg\"\n        else:\n            mime_type = \"text/plain\"\n\n        response_header += f\"Content-Type: {mime_type}\\r\\n\"\n        response_header += f\"Content-Length: {len(content)}\\r\\n\"\n        response_header += \"Connection: close\\r\\n\\r\\n\" # Header ditutup dengan dua enter (\\r\\n\\r\\n)\n\n        # Kirim Header + Body\n        client_socket.send(response_header.encode('utf-8') + content)\n        print(f\"[200] Mengirim {filepath}\")\n\n    except FileNotFoundError:\n        # 5. Handle Error 404\n        error_content = \"&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;p&gt;File tidak ditemukan di Server.&lt;/p&gt;\"\n\n        response_header = \"HTTP/1.1 404 Not Found\\r\\n\"\n        response_header += \"Content-Type: text/html\\r\\n\"\n        response_header += f\"Content-Length: {len(error_content)}\\r\\n\"\n        response_header += \"Connection: close\\r\\n\\r\\n\"\n\n        client_socket.send(response_header.encode('utf-8') + error_content.encode('utf-8'))\n        print(f\"[404] File {filepath} tidak ada\")\n\n    client_socket.close()\n\ndef run_web_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n    print(\"=== Python Web Server Berjalan di http://localhost:8080 ===\")\n\n    while True:\n        client, addr = server.accept()\n        handle_client(client)\n\nif __name__ == \"__main__\":\n    run_web_server()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#105-konteks-industri-mengapa-tidak-pakai-ini-di-production","title":"10.5 Konteks Industri: Mengapa Tidak Pakai Ini di Production?","text":"<p>Server di atas disebut Single-Threaded Blocking Web Server. *   Masalah: Jika ada user dengan koneksi lambat sedang mendownload gambar besar, server akan freeze. User lain tidak bisa akses. *   Solusi Production: Di dunia nyata, kita menggunakan Gunicorn atau Nginx yang mengimplementasikan Asyncio (Bab 8) atau Multiplexing (Bab 9) untuk menangani ribuan request per detik. Namun, logika parsing HTTP-nya tetap sama dengan yang kita tulis di atas.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#106-tugas-mandiri-web-developer-ops","title":"10.6 Tugas Mandiri (Web Developer Ops)","text":"<ol> <li>Halaman Statis: Buat file <code>index.html</code> dan <code>about.html</code> dengan konten HTML cantik (CSS inline). Pastikan server bisa menyajikannya.</li> <li>Serving Image: Taruh sebuah file gambar <code>foto.jpg</code> di folder yang sama. Akses <code>http://localhost:8080/foto.jpg</code>. Jika gambar muncul tapi rusak (corrupt), cek apakah Anda sudah membukanya dengan mode <code>rb</code> (read binary) dan Content-Type-nya benar?</li> <li>Logs: Modifikasi server agar mencatat setiap request ke file <code>server.log</code> dengan format: <code>[JAMES-TIME] IP-ADDRESS REQUEST-FILE STATUS-CODE</code>. Ini adalah cikal bakal Access Log yang biasa dibaca SysAdmin.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-10","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 10","text":"<p>File: <code>latihan_10_thread.py</code> <pre><code># Credit: Fikom UIT\nimport threading\nimport time\n\ndef worker(nama):\n    print(f\"Worker {nama} mulai...\")\n    time.sleep(2)\n    print(f\"Worker {nama} selesai.\")\n\nt1 = threading.Thread(target=worker, args=(\"A\",))\nt2 = threading.Thread(target=worker, args=(\"B\",))\n\nt1.start()\nt2.start()\n</code></pre></p> <p>File: <code>latihan_10_web_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport os\n\ndef run_web_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n    print(\"=== Simple Web Server Running on port 8080 ===\")\n    print(\"Akses: http://localhost:8080/index.html\")\n\n    while True:\n        client_sock, addr = server.accept()\n        try:\n            request = client_sock.recv(1024).decode()\n\n            # Parsing baris pertama: \"GET /index.html HTTP/1.1\"\n            headers = request.split('\\n')\n            first_line = headers[0].split()\n\n            if len(first_line) &gt; 1:\n                filename = first_line[1] # misal: \"/index.html\"\n                if filename == '/': filename = '/index.html'\n\n                # Coba baca file\n                # Hilangkan slash depan agar pathnya relatif ke folder ini\n                filepath = filename[1:] \n\n                try:\n                    with open(filepath, 'r') as f:\n                        content = f.read()\n\n                    # HTTP Header\n                    response = \"HTTP/1.1 200 OK\\r\\n\"\n                    response += \"Content-Type: text/html\\r\\n\\r\\n\"\n                    response += content\n\n                except FileNotFoundError:\n                    # 404 Not Found\n                    response = \"HTTP/1.1 404 Not Found\\r\\n\\r\\n\"\n                    response += \"&lt;h1&gt;404 File Tidak Ditemukan&lt;/h1&gt;\"\n\n                client_sock.sendall(response.encode())\n\n        except Exception as e:\n            print(f\"Error {e}\")\n        finally:\n            client_sock.close()\n\nif __name__ == \"__main__\":\n    # Buat file dummy index.html jika belum ada\n    if not os.path.exists('index.html'):\n        with open('index.html', 'w') as f:\n            f.write(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Halo dari Python Web Server!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\")\n\n    run_web_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-11-rest-api-web-services","title":"Bab 11: REST API &amp; Web Services","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan konsep dasar Web Service dan arsitektur REST (Representational State Transfer). 2.  Memetakan metode HTTP (GET, POST, PUT, DELETE) ke dalam operasi database CRUD (Create, Read, Update, Delete). 3.  Mengimplementasikan aplikasi client yang mengonsumsi Public API menggunakan pustaka <code>requests</code>. 4.  Menganalisis struktur data JSON yang diterima dari penyedia layanan pihak ketiga.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#111-pendahuluan-saat-mesin-bicara-dengan-mesin","title":"11.1 Pendahuluan: Saat Mesin Bicara dengan Mesin","text":"<p>Di Bab 10, kita mengakses web menggunakan Browser. Itu adalah komunikasi Human-to-Machine. Tapi di era digital ini, mayoritas komunikasi internet adalah Machine-to-Machine.</p> <p>Contoh nyata: *   Saat Anda memesan GoJek, aplikasi GoJek \"bertanya\" ke Google Maps API: \"Berapa jarak dari rumah saya ke kampus?\" *   Saat Anda login Instagram pakai Facebook, Instagram \"bertanya\" ke Facebook API: \"Apakah user ini valid?\"</p> <p>Jembatan komunikasi inilah yang disebut API (Application Programming Interface).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#112-arsitektur-rest-standar-bahasa-universal","title":"11.2 Arsitektur REST: Standar Bahasa Universal","text":"<p>REST (Representational State Transfer) bukan protokol, melainkan gaya arsitektur. Bayangkan REST sebagai \"Menu Restoran yang Terstandarisasi\" di seluruh dunia.</p> <p>Analogi Bahasa Kerja: Jika Anda seorang pelayan (Server), Anda akan bingung jika setiap tamu punya cara pesan berbeda. *   Tamu A: \"Saya mau makan.\" *   Tamu B: \"Berikan saya asupan nutrisi.\" *   Tamu C: \"Muat makanan ke meja 5.\"</p> <p>REST menetapkan aturan baku: \"Gunakan KATA KERJA yang sama untuk benda yang berbeda.\"</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram alur Client (Mobile App) -&gt; HTTP Request (REST) -&gt; Server Backend -&gt; Database]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#113-pemetaan-http-methods-crud","title":"11.3 Pemetaan HTTP Methods (CRUD)","text":"<p>Dalam REST, kita menggunakan Metode HTTP (yang kita pelajari di Bab 10) untuk mewakili aksi terhadap data.</p> HTTP Method Analogi SQL Fungsi Bisnis Contoh Endpoint GET <code>SELECT</code> Read: Mengambil data <code>/mahasiswa/101</code> (Ambil data mhs nim 101) POST <code>INSERT</code> Create: Menambah data baru <code>/mahasiswa</code> (Tambah mhs baru) PUT/PATCH <code>UPDATE</code> Update: Mengubah data <code>/mahasiswa/101</code> (Ganti nama mhs 101) DELETE <code>DELETE</code> Delete: Menghapus data <code>/mahasiswa/101</code> (Hapus mhs 101)"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#114-pustaka-requests-http-for-humanstm","title":"11.4 Pustaka <code>requests</code>: HTTP for Humans\u2122","text":"<p>Python memiliki modul bawaan <code>urllib</code>, tapi sintaksnya sangat primitif dan rumit (mirip Socket). Oleh karena itu, komunitas Python menciptakan <code>requests</code>. Library ini begitu populer karena kemudahannya, sampai-sampai slogannya adalah \"HTTP for Humans\".</p> <p>Catatan Instalasi: Library ini bukan bawaan standar Python. Anda harus menginstallnya via terminal: <code>pip install requests</code></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#115-praktikum-membuat-aplikasi-cuaca","title":"11.5 Praktikum: Membuat Aplikasi Cuaca","text":"<p>Kita akan membuat aplikasi console yang mirip widget cuaca di HP Anda. Kita akan \"meminjam\" data dari Open-Meteo, sebuah penyedia API cuaca gratis yang tidak memerlukan pendaftaran kunci (API Key).</p> <ol> <li>Endpoint: <code>https://api.open-meteo.com/v1/forecast</code></li> <li>Parameter: <code>latitude</code>, <code>longitude</code>, <code>current_weather=true</code>.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#kode-implementasi-latihan_11_weather_apppy","title":"Kode Implementasi (<code>latihan_11_weather_app.py</code>)","text":"<pre><code>import requests\nimport sys\n\ndef get_weather(city_name, lat, lon):\n    print(f\"\\n--- Mengambil Data Cuaca untuk {city_name} ---\")\n\n    # 1. Definisikan URL dan Parameter\n    base_url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        'latitude': lat,\n        'longitude': lon,\n        'current_weather': 'true',\n        'timezone': 'auto' # Agar jam sesuai lokasi\n    }\n\n    try:\n        # 2. Kirim Request GET\n        # requests.get otomatis menyusun query string (?lat=...&amp;lon=...)\n        response = requests.get(base_url, params=params)\n\n        # 3. Cek Status Code\n        if response.status_code == 200:\n            # 4. Parsing JSON\n            data = response.json()\n\n            # Ambil bagian yang penting saja\n            current = data['current_weather']\n            suhu = current['temperature']\n            kecepatan_angin = current['windspeed']\n\n            print(f\"\ud83c\udf21\ufe0f  Suhu Saat Ini: {suhu}\u00b0C\")\n            print(f\"\ud83d\udca8 Kecepatan Angin: {kecepatan_angin} km/h\")\n            print(f\"\ud83c\udf0d Koordinat: {lat}, {lon}\")\n\n        else:\n            print(f\"[ERROR] Gagal mengambil data. Status: {response.status_code}\")\n\n    except requests.exceptions.ConnectionError:\n        print(\"[ERROR] Tidak ada koneksi internet!\")\n    except Exception as e:\n        print(f\"[ERROR] Terjadi kesalahan: {e}\")\n\nif __name__ == \"__main__\":\n    # Koordinat Jakarta\n    get_weather(\"Jakarta\", -6.2088, 106.8456)\n\n    # Koordinat Makassar\n    get_weather(\"Makassar\", -5.1477, 119.4327)\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#116-analisis-kode","title":"11.6 Analisis Kode","text":"<ul> <li><code>params={...}</code>: Fitur <code>requests</code> yang sangat membantu. Kita tidak perlu menjahit string URL secara manual (misal: <code>url + \"?lat=\" + lat</code>). Dictionary Python otomatis diubah jadi query string URL yang valid.</li> <li><code>response.json()</code>: Otomatis melakukan Deserialisasi JSON ke Dictionary (Materi Bab 7). Jika responsenya bukan JSON, ini akan error.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#117-tugas-mandiri-eksplorasi-api-lain","title":"11.7 Tugas Mandiri (Eksplorasi API Lain)","text":"<p>Tugas Anda adalah memodifikasi kode di atas untuk mengambil data dari API publik yang lain.</p> <ol> <li>API Kurs Mata Uang: Cari Free Currency API. Buat program konversi Rupiah ke USD secara real-time.</li> <li>API Jokes/Quotes: Cari API yang menyediakan \"Random Quote\". Tampilkan kata-kata mutiara setiap kali script dijalankan.</li> <li>Error Handling: Coba matikan internet Anda, lalu jalankan script cuaca tadi. Apakah pesan errornya manusiawi? Jika muncul pesan traceback panjang yang menakutkan, perbaiki blok <code>try-except</code> Anda.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-11","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 11","text":"<p>File: <code>latihan_11_http_get.py</code> <pre><code># Credit: Fikom UIT\nimport requests\n\nresponse = requests.get('https://jsonplaceholder.typicode.com/posts/1')\nprint(f\"Status Code: {response.status_code}\")\nprint(\"Body:\", response.json())\n</code></pre></p> <p>File: <code>latihan_11_weather_app.py</code> <pre><code># Credit: Fikom UIT\nimport requests\nimport json\n\ndef get_weather(lat, lon):\n    url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": lat,\n        \"longitude\": lon,\n        \"current_weather\": \"true\"\n    }\n\n    print(f\"Mengambil data cuaca untuk koordinat {lat}, {lon}...\")\n\n    try:\n        response = requests.get(url, params=params)\n\n        # Cek status code (200 = Success)\n        if response.status_code == 200:\n            data = response.json()\n            cuaca = data['current_weather']\n\n            print(\"\\n--- LAPORAN CUACA TERKINI ---\")\n            print(f\"Suhu        : {cuaca['temperature']} {data['current_weather_units']['temperature']}\")\n            print(f\"Kecepatan Angin: {cuaca['windspeed']} km/h\")\n            print(f\"Waktu Data  : {cuaca['time']}\")\n        else:\n            print(f\"Gagal mengambil data. Status: {response.status_code}\")\n\n    except requests.exceptions.ConnectionError:\n        print(\"Error: Tidak ada koneksi internet.\")\n    except Exception as e:\n        print(f\"Terjadi kesalahan: {e}\")\n\nif __name__ == \"__main__\":\n    # Koordinat Jakarta\n    jkt_lat = -6.2088\n    jkt_lon = 106.8456\n\n    get_weather(jkt_lat, jkt_lon)\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-12-real-time-communication-websocket","title":"Bab 12: Real-time Communication (WebSocket)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membedakan mekanisme HTTP Polling dengan WebSocket dalam konteks efisiensi bandwidth dan latensi. 2.  Menjelaskan proses Protocol Upgrade (Handshake) dari HTTP ke WebSocket. 3.  Membangun server WebSocket yang mampu melakukan Push Notification data secara real-time. 4.  Mengintegrasikan Backend Python dengan Frontend HTML/JS untuk visualisasi data langsung.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#121-pendahuluan-mengapa-http-tidak-cukup","title":"12.1 Pendahuluan: Mengapa HTTP Tidak Cukup?","text":"<p>HTTP (Bab 10) didesain untuk Dokumen Statis. Client minta, Server kasih, lalu putus. Tapi bagaimana dengan aplikasi modern seperti: *   Chat WhatsApp (Pesan masuk tanpa direload). *   Grafik Crypto/Saham (Bergerak tiap detik). *   Game Online (Multiplayer real-time).</p> <p>Jika menggunakan HTTP biasa, Client harus melakukan Polling:</p> <p>\"Server, ada pesan baru?\" (Tidak) \"Server, ada pesan baru?\" (Tidak) \"Server, ada pesan baru?\" (Ya)</p> <p>Ini sangat boros bandwidth dan server akan overload hanya untuk menjawab \"Tidak\". Kita butuh mekanisme di mana Server bisa menelpon balik Client: \"Hei, ada data baru nih!\"</p> <p>Analogi Tombol Refresh vs Notifikasi: *   HTTP (Polling): Anda menekan tombol F5 (Refresh) di browser setiap 1 detik untuk melihat skor bola terbaru. Capek dan tidak efisien. *   WebSocket (Push): Ponsel Anda bergetar sendiri saat ada Gol. Anda diam saja menunggu.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#122-protokol-websocket-full-duplex","title":"12.2 Protokol WebSocket (Full Duplex)","text":"<p>WebSocket adalah protokol komunikasi dua arah (Full Duplex) di atas satu koneksi TCP yang persisten.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#the-handshake-salaman-awal","title":"The Handshake (Salaman Awal)","text":"<p>WebSocket tidak berdiri sendiri, ia \"mendompleng\" HTTP di awal. 1.  Client: Mengirim HTTP Request dengan header <code>Upgrade: websocket</code>. 2.  Server: Jika setuju, membalas <code>101 Switching Protocols</code>. 3.  Jalur Terbuka: Koneksi HTTP kini berubah menjadi pipa WebSocket. Data bisa mengalir dua arah tanpa header HTTP yang gemuk.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Sequence Diagram Handshake HTTP Upgrade -&gt; WebSocket Connection Open]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#123-pustaka-websockets","title":"12.3 Pustaka <code>websockets</code>","text":"<p>Python memiliki pustaka <code>websockets</code> yang sangat powerfull dan berjalan di atas <code>asyncio</code> (Bab 8). Ini artinya server kita bisa menangani ribuan koneksi real-time sekaligus.</p> <p>Instalasi: <code>pip install websockets</code></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#124-praktikum-live-saham-ticker","title":"12.4 Praktikum: Live Saham Ticker","text":"<p>Kita akan membuat sistem pemantau harga saham palsu. *   Server (Python): Mengenerate harga acak setiap detik dan mem-broadcast ke semua browser yang sedang membuka dashboard. *   Client (Chrome/Edge): Halaman HTML sederhana dengan JavaScript untuk menerima data.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-kode-server-latihan_12_ws_serverpy","title":"A. Kode Server (<code>latihan_12_ws_server.py</code>)","text":"<pre><code>import asyncio\nimport websockets\nimport json\nimport random\n\n# Menyimpan semua client yang terhubung\nCONNECTED_CLIENTS = set()\n\nasync def stock_handler(websocket):\n    \"\"\"\n    Handler ini dijalankan setiap kali ada client baru connect\n    \"\"\"\n    # 1. Register Client\n    print(\"[NEW] Client bergabung.\")\n    CONNECTED_CLIENTS.add(websocket)\n\n    try:\n        # Kirim pesan selamat datang\n        await websocket.send(json.dumps({\"msg\": \"Welcome to Stock Ticker!\"}))\n\n        # Keep connection alive (looping listening)\n        # Sebenarnya server kita tipe BROADCASTER (satu arah), \n        # tapi kita perlu loop agar koneksi tidak putus.\n        async for message in websocket:\n            print(f\"Client sent: {message}\")\n\n    except websockets.exceptions.ConnectionClosed:\n        print(\"[CLOSED] Client terputus.\")\n    finally:\n        # 2. Unregister Client saat putus\n        CONNECTED_CLIENTS.remove(websocket)\n\nasync def broadcast_price():\n    \"\"\"\n    Fungsi latar belakang untuk generate harga palsu\n    \"\"\"\n    while True:\n        # Simulasi harga saham\n        price_data = {\n            \"symbol\": \"BBCA\",\n            \"price\": random.randint(8000, 8500),\n            \"timestamp\": \"Live\"\n        }\n\n        # Serialisasi ke JSON\n        message = json.dumps(price_data)\n\n        # Kirim ke SEMUA client yang ada di set\n        if CONNECTED_CLIENTS:\n            # websockets.broadcast butuh list/set client\n            websockets.broadcast(CONNECTED_CLIENTS, message)\n            print(f\"[BROADCAST] {message} -&gt; ke {len(CONNECTED_CLIENTS)} clients\")\n\n        await asyncio.sleep(1) # Update tiap 1 detik\n\nasync def main():\n    # Jalankan server di port 6789\n    async with websockets.serve(stock_handler, \"localhost\", 6789):\n        print(\"=== WebSocket Server running on ws://localhost:6789 ===\")\n\n        # Jalankan broadcaster di background\n        await broadcast_price() # Ini akan looping selamanya\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"Server Stopped.\")\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-kode-client-dashboardhtml","title":"B. Kode Client (<code>dashboard.html</code>)","text":"<p>Simpan kode ini sebagai file HTML dan buka di browser (Double click).</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Live Stock Dashboard&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: sans-serif; text-align: center; padding: 50px; }\n        #price-box { font-size: 4em; font-weight: bold; color: green; }\n        .log { color: gray; font-size: 0.8em; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Pantauan Saham BBCA (Real-time)&lt;/h1&gt;\n    &lt;div id=\"price-box\"&gt;Waiting...&lt;/div&gt;\n    &lt;div id=\"status\" class=\"log\"&gt;Disconnected&lt;/div&gt;\n\n    &lt;script&gt;\n        // 1. Buka Koneksi ke Server Python\n        const socket = new WebSocket('ws://localhost:6789');\n\n        socket.onopen = function(e) {\n            document.getElementById(\"status\").textContent = \"Connected to Server \u2705\";\n        };\n\n        socket.onmessage = function(event) {\n            // 2. Terima Data JSON\n            const data = JSON.parse(event.data);\n\n            // Cek apakah ini data harga\n            if(data.price) {\n                const display = `Rp ${data.price}`;\n                document.getElementById(\"price-box\").textContent = display;\n\n                // Efek visual sederhana (Warna berubah acak)\n                document.getElementById(\"price-box\").style.color = \n                    data.price &gt; 8250 ? \"green\" : \"red\";\n            }\n        };\n\n        socket.onclose = function(event) {\n            document.getElementById(\"status\").textContent = \"Connection Lost \u274c\";\n        };\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#125-tugas-mandiri-chat-room-modern","title":"12.5 Tugas Mandiri (Chat Room Modern)","text":"<ol> <li>Jalankan Codingan: Jalankan server python. Buka file HTML di Dua Tab Berbeda. Lihat apakah keduanya berubah angkanya secara bersamaan? (Harusnya Ya).</li> <li>Challenge: Ubah kode di atas menjadi Chat Room.<ul> <li>Server: Saat menerima pesan dari Client A, broadcast pesan itu ke Client B, C, dst.</li> <li>Client HTML: Tambahkan <code>&lt;input&gt;</code> text dan button <code>Send</code> yang memanggil <code>socket.send()</code>.</li> <li>Ini adalah tugas besar yang menggabungkan semua logika Broadcasting dan WebSocket.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#126-catatan-keamanan","title":"12.6 Catatan Keamanan","text":"<p>Koneksi WebSocket (<code>ws://</code>) itu tidak terenkripsi, sama seperti HTTP. Data bisa diintip hacker. Di production, WAJIB menggunakan WSS (<code>wss://</code>) yang dilindungi SSL/TLS (Sertifikat HTTPS).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-12","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 12","text":"<p>File: <code>latihan_12_async.py</code> <pre><code># Credit: Fikom UIT\nimport asyncio\n\nasync def sapa_async():\n    print(\"Halo...\")\n    await asyncio.sleep(1) # Simulasi I/O wait\n    print(\"...Dunia Async!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(sapa_async())\n</code></pre></p> <p>File: <code>latihan_12_ws_server.py</code> <pre><code># Credit: Fikom UIT\nimport asyncio\nimport websockets\nimport json\nimport random\n\n# Menyimpan semua client yang terhubung\nconnected_clients = set()\n\nasync def handler(websocket):\n    # Register client baru\n    connected_clients.add(websocket)\n    try:\n        print(f\"Client terhubung. Total: {len(connected_clients)}\")\n\n        while True:\n            # Simulasi data real-time\n            data = {\n                \"saham_A\": random.randint(100, 200),\n                \"saham_B\": random.randint(50, 80),\n                \"timestamp\": asyncio.get_event_loop().time()\n            }\n\n            # Kirim ke client ini\n            await websocket.send(json.dumps(data))\n\n            # Delay 1 detik\n            await asyncio.sleep(1)\n\n    except websockets.exceptions.ConnectionClosed:\n        pass\n    finally:\n        connected_clients.remove(websocket)\n        print(f\"Client putus. Total: {len(connected_clients)}\")\n\nasync def main():\n    # Start Websocket Server\n    # Note: perlu pip install websockets\n    try:\n        async with websockets.serve(handler, \"localhost\", 8765):\n            print(\"WS Server running on ws://localhost:8765\")\n            await asyncio.futures.Future() # Run forever\n    except ModuleNotFoundError:\n        print(\"Error: Library 'websockets' belum diinstall.\")\n        print(\"Silakan jalankan: pip install websockets\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-13-keamanan-jaringan-network-security","title":"Bab 13: Keamanan Jaringan (Network Security)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menganalisis kerentanan komunikasi data plaintext terhadap serangan Sniffing dan Man-in-the-Middle. 2.  Membedakan mekanisme Symmetric Encryption dan Asymmetric Encryption. 3.  Mendemonstrasikan penggunaan modul <code>ssl</code> Python untuk mengenkripsi lalu lintas aplikasi Client-Server. 4.  Menerapkan pembuatan Self-Signed Certificate untuk lingkungan pengembangan lokal.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#131-pendahuluan-jangan-kirim-kartu-pos","title":"13.1 Pendahuluan: Jangan Kirim Kartu Pos!","text":"<p>Bayangkan Anda ingin mengirim surat berisi password ATM kepada ibu Anda di kampung. *   Plaintext (Bab 1-12): Anda menuliskannya di Kartu Pos. Pak Pos bisa baca, tetangga bisa baca, siapapun yang memegang kartu itu bisa baca. Ini sangat berbahaya. *   Encrypted (Bab 13): Anda memasukkan surat itu ke dalam Amplop Baja yang terkunci rapat. Hanya ibu Anda yang memegang kuncinya. Pak Pos hanya bisa melihat alamat tujuan, tapi tidak bisa melihat isinya.</p> <p>Dalam jaringan komputer, \"Pak Pos\" adalah Router, ISP, dan hacker yang satu jaringan WiFi dengan Anda. Tanpa enkripsi, mereka bisa membaca semua data Anda menggunakan alat seperti Wireshark.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#132-konsep-kriptografi-modern","title":"13.2 Konsep Kriptografi Modern","text":"<p>Bagaimana cara mengirim \"kotak besi\" lewat internet? Komputer menggunakan matematika tingkat tinggi.</p> <ol> <li> <p>Symmetric Key (Kunci Simetris):</p> <ul> <li>Kunci untuk mengunci = Kunci untuk membuka.</li> <li>Masalah: Bagaimana cara mengirim kunci itu ke penerima tanpa dicuri di jalan?</li> </ul> </li> <li> <p>Asymmetric Key (Public/Private Key):</p> <ul> <li>Setiap orang punya sepasang kunci.</li> <li>Public Key (Gembok): Disebar ke semua orang. Siapapun boleh pakai ini untuk mengunci kotak.</li> <li>Private Key (Kunci): Disimpan rahasia. Hanya ini yang bisa membuka kotak yang dikunci oleh Public Key pasangannya.</li> <li>Mekanisme: Saya kirim Gembok Terbuka (Public) ke Anda. Anda masukkan pesan, kunci pakai gembok itu, lalu kirim balik ke saya. Aman! Saya buka pakai Kunci Rahasia saya.</li> </ul> </li> </ol> <p>[Saran: Tambahkan Gambar/Diagram disini: Alice &amp; Bob - Public/Private Key Encryption Flow]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#133-ssltls-standar-keamanan-internet","title":"13.3 SSL/TLS: Standar Keamanan Internet","text":"<p>Secure Sockets Layer (SSL), yang sekarang berevolusi menjadi Transport Layer Security (TLS), adalah protokol yang membungkus TCP biasa dengan lapisan enkripsi. Ini yang mengubah <code>http://</code> menjadi <code>https://</code>.</p> <p>Modul Python <code>ssl</code> memungkinkan kita melakukan \"Upgrade\" pada socket biasa agar menjadi Secure Socket.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#134-praktikum-secure-chat","title":"13.4 Praktikum: Secure Chat","text":"<p>Kita akan membuat server yang WAJIB pakai SSL. Client yang tidak punya sertifikat tidak akan bisa connect (atau minimal tidak bisa baca datanya).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#langkah-1-membuat-sertifikat-self-signed","title":"Langkah 1: Membuat Sertifikat (Self-Signed)","text":"<p>Di dunia nyata, sertifikat dibeli dari Certificate Authority (CA) seperti Verisign atau Let's Encrypt. Untuk latihan, kita jadi CA sendiri (Self-Signed).</p> <p>Buat file baru <code>generate_cert.py</code> dan jalankan SATU KALI SAJA:</p> <p><pre><code># generate_cert.py\nfrom cryptography import x509\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\nimport datetime\n\n# 1. Buat Private Key\nkey = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048,\n    backend=default_backend()\n)\n\n# 2. Buat Sertifikat (Self-Signed)\nsubject = issuer = x509.Name([\n    x509.NameAttribute(x509.NameOID.COUNTRY_NAME, u\"ID\"),\n    x509.NameAttribute(x509.NameOID.ORGANIZATION_NAME, u\"Fikom UIT\"),\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\"),\n])\n\ncert = x509.CertificateBuilder().subject_name(\n    subject\n).issuer_name(\n    issuer\n).public_key(\n    key.public_key()\n).serial_number(\n    x509.random_serial_number()\n).not_valid_before(\n    datetime.datetime.utcnow()\n).not_valid_after(\n    datetime.datetime.utcnow() + datetime.timedelta(days=365)\n).add_extension(\n    x509.SubjectAlternativeName([x509.DNSName(u\"localhost\")]),\n    critical=False,\n).sign(key, hashes.SHA256(), default_backend())\n\n# 3. Simpan ke File\nwith open(\"server_key.pem\", \"wb\") as f:\n    f.write(key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.TraditionalOpenSSL,\n        encryption_algorithm=serialization.NoEncryption(),\n    ))\n\nwith open(\"server_cert.pem\", \"wb\") as f:\n    f.write(cert.public_bytes(serialization.Encoding.PEM))\n\nprint(\"Sertifikat berhasil dibuat: server_cert.pem &amp; server_key.pem\")\n</code></pre> Catatan: Anda perlu <code>pip install cryptography</code> dulu.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#langkah-2-kode-server-aman-secure_serverpy","title":"Langkah 2: Kode Server Aman (<code>secure_server.py</code>)","text":"<pre><code>import socket\nimport ssl\n\ndef run_secure_server():\n    # 1. Konteks SSL\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    # Muat sertifikat &amp; private key yang kita buat tadi\n    context.load_cert_chain(certfile=\"server_cert.pem\", keyfile=\"server_key.pem\")\n\n    # 2. Socket Biasa\n    bindsocket = socket.socket()\n    bindsocket.bind(('localhost', 10023))\n    bindsocket.listen(5)\n    print(\"Secure Server listening on port 10023...\")\n\n    while True:\n        try:\n            newsocket, fromaddr = bindsocket.accept()\n            print(f\"[NEW] Koneksi TCP dari {fromaddr}\")\n\n            # 3. WRAP (Bungkus) Socket dengan SSL\n            # Di sinilah proses Handshake terjadi\n            conn = context.wrap_socket(newsocket, server_side=True)\n            print(f\"[SECURE] SSL Handshake sukses dengan {fromaddr}\")\n\n            # Komunikasi biasa (tapi terenkripsi otomatis)\n            data = conn.recv(1024)\n            print(f\"Pesan (Decrypted): {data.decode()}\")\n\n            conn.send(b\"Pesan Anda aman bersama kami.\")\n\n        except ssl.SSLError as e:\n            print(f\"[ERROR] Masalah SSL: {e}\")\n        except Exception as e:\n            print(f\"Error lain: {e}\")\n        finally:\n            # conn.close()\n            pass\n\nif __name__ == \"__main__\":\n    run_secure_server()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#langkah-3-kode-client-aman-secure_clientpy","title":"Langkah 3: Kode Client Aman (<code>secure_client.py</code>)","text":"<p>Perhatikan opsi <code>check_hostname=False</code> dan <code>CERT_NONE</code>. Ini karena sertifikat kita palsu (Self-Signed), jadi kita paksa client untuk \"percaya saja\".</p> <pre><code>import socket\nimport ssl\n\ndef run_secure_client():\n    # 1. Konteks SSL (Client)\n    # Gunakan create_default_context tapi matikan verifikasi karena sertifikat kita self-signed\n    context = ssl.create_default_context()\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    # 2. Socket Biasa\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 3. WRAP Socket SEBELUM connect\n    # Client membungkus socket dulu, baru connect\n    secure_sock = context.wrap_socket(sock, server_hostname='localhost')\n\n    try:\n        print(\"Menghubungkan ke Secure Server...\")\n        secure_sock.connect(('localhost', 10023))\n        print(f\"Terhubung dengan Cipher: {secure_sock.cipher()}\")\n\n        secure_sock.send(b\"Halo, ini pesan rahasia CIA.\")\n        response = secure_sock.recv(1024)\n        print(f\"Balasan Server: {response.decode()}\")\n\n    finally:\n        secure_sock.close()\n\nif __name__ == \"__main__\":\n    run_secure_client()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#135-tugas-mandiri-man-in-the-middle","title":"13.5 Tugas Mandiri (Man-in-the-Middle)","text":"<ol> <li>Jalankan Server &amp; Client: Pastikan komunikasi berjalan lancar.</li> <li>Percobaan Peretas: Buat script client biasa (tanpa SSL) dari Bab 2. Coba <code>connect()</code> ke port 10023 dan kirim pesan. Apa yang terjadi?<ul> <li>Hasil: Anda mungkin bisa connect secara TCP, tapi server akan memutus koneksi saat baris <code>context.wrap_socket</code> karena client tidak mengirim sinyal Handshake SSL. Server akan melempar <code>SSLError</code>.</li> </ul> </li> <li>Wireshark (Opsional): Jika Anda mengerti Wireshark, coba intip port 10023. Anda tidak akan melihat tulisan \"Halo\", melainkan sampah binary acak. Itulah enkripsi.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-13","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 13","text":"<p>File: <code>latihan_13_encrypt.py</code> <pre><code># Credit: Fikom UIT\nfrom cryptography.fernet import Fernet\n\n# Generate key\nkey = Fernet.generate_key()\ncipher = Fernet(key)\n\npesan = b\"Rahasia Negara\"\nencrypted = cipher.encrypt(pesan)\nprint(f\"Encrypted: {encrypted}\")\n\ndecrypted = cipher.decrypt(encrypted)\nprint(f\"Decrypted: {decrypted.decode()}\")\n</code></pre></p> <p>File: <code>latihan_13_gen_cert.py</code> <pre><code># Credit: Fikom UIT\nfrom cryptography import x509\nfrom cryptography.x509.oid import NameOID\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\nimport datetime\n\n# Script bantuan untuk generate cert.pem dan key.pem secara otomatis\n# Membtutuhkan: pip install cryptography\n\ndef generate_self_signed_cert():\n    print(\"Generating RSA Key...\")\n    key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n    )\n\n    print(\"Generating Certificate...\")\n    subject = issuer = x509.Name([\n        x509.NameAttribute(NameOID.COUNTRY_NAME, u\"ID\"),\n        x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u\"Jakarta\"),\n        x509.NameAttribute(NameOID.LOCALITY_NAME, u\"Jakarta\"),\n        x509.NameAttribute(NameOID.ORGANIZATION_NAME, u\"Fikom UIT\"),\n        x509.NameAttribute(NameOID.COMMON_NAME, u\"localhost\"),\n    ])\n\n    cert = x509.CertificateBuilder().subject_name(\n        subject\n    ).issuer_name(\n        issuer\n    ).public_key(\n        key.public_key()\n    ).serial_number(\n        x509.random_serial_number()\n    ).not_valid_before(\n        datetime.datetime.utcnow()\n    ).not_valid_after(\n        # Valid 1 tahun\n        datetime.datetime.utcnow() + datetime.timedelta(days=365)\n    ).add_extension(\n        x509.SubjectAlternativeName([x509.DNSName(u\"localhost\")]),\n        critical=False,\n    ).sign(key, hashes.SHA256())\n\n    # Write Key\n    with open(\"key.pem\", \"wb\") as f:\n        f.write(key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ))\n\n    # Write Cert\n    with open(\"cert.pem\", \"wb\") as f:\n        f.write(cert.public_bytes(serialization.Encoding.PEM))\n\n    print(\"Berhasil membuat 'key.pem' dan 'cert.pem'\")\n\nif __name__ == \"__main__\":\n    try:\n        generate_self_signed_cert()\n    except ImportError:\n        print(\"Error: Library 'cryptography' belum diinstall.\")\n        print(\"Run: pip install cryptography\")\n</code></pre></p> <p>File: <code>latihan_13_secure_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport ssl\n\ndef secure_client():\n    # Setup SSL Context untuk client\n    # PROTOCOL_TLS_CLIENT memaksa verifikasi sertifikat server\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\n    # Karena kita pakai Self-Signed Certificate, kita harus mematikan verifikasi hostname &amp; loading CA\n    # ATAU kita load cert kita sendiri sebagai \"Trusted CA\"\n    context.load_verify_locations('cert.pem')\n    # context.check_hostname = False # Opsional jika hostname tidak match\n\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # Wrap socket\n    secure_sock = context.wrap_socket(sock, server_hostname='localhost')\n\n    try:\n        print(\"Connecting securely...\")\n        secure_sock.connect(('localhost', 10023))\n\n        # Cek versi protokol yang dipakai\n        print(f\"Connected with {secure_sock.version()}\")\n\n        secure_sock.send(\"Rahasia Negara Bos!\".encode())\n\n        resp = secure_sock.recv(1024).decode()\n        print(f\"Response: {resp}\")\n\n    except ssl.SSLCertVerificationError:\n        print(\"Error: Sertifikat Server tidak dipercaya!\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        secure_sock.close()\n\nif __name__ == \"__main__\":\n    secure_client()\n</code></pre></p> <p>File: <code>latihan_13_secure_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport ssl\n\ndef secure_server():\n    # Setup SSL Context\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    try:\n        context.load_cert_chain(certfile=\"cert.pem\", keyfile=\"key.pem\")\n    except FileNotFoundError:\n        print(\"Sertifikat belum ada! Jalankan latihan_13_gen_cert.py dulu.\")\n        return\n\n    bindsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    bindsocket.bind(('localhost', 10023))\n    bindsocket.listen(5)\n    print(\"=== Secure TLS Server Listening on 10023 ===\")\n\n    # Wrap socket biasa dengan SSL\n    # server_side=True artinya socket ini berperan sebagai server\n    with context.wrap_socket(bindsocket, server_side=True) as ssock:\n        while True:\n            try:\n                conn, addr = ssock.accept()\n                print(f\"Secure connection from {addr}\")\n\n                data = conn.recv(1024).decode()\n                print(f\"Received: {data}\")\n\n                conn.send(f\"Server Says: Validated &amp; Encrypted!\".encode())\n                conn.close()\n            except Exception as e:\n                print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    secure_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-14-arsitektur-sistem-terdistribusi-iot-mqtt","title":"Bab 14: Arsitektur Sistem Terdistribusi &amp; IoT (MQTT)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membedakan arsitektur Request-Response (HTTP) dengan Publish-Subscribe (MQTT) dalam konteks IoT. 2.  Menganalisis peran Broker sebagai perantara pesan dalam sistem terdistribusi. 3.  Mengimplementasikan komunikasi data sensor menggunakan protokol MQTT dan pustaka <code>paho-mqtt</code>. 4.  Mengevaluasi tingkat keandalan data menggunakan QoS (Quality of Service) Level 0, 1, dan 2.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#141-pendahuluan-masalah-kabel-yang-semrawut","title":"14.1 Pendahuluan: Masalah Kabel yang Semrawut","text":"<p>Dalam 13 bab sebelumnya, kita selalu menghubungkan Client A langsung ke Server B. Bagaimana jika kita punya 1.000 Sensor di sebuah Pabrik Cerdas, dan data sensor itu harus dikirim ke: 1.  Dashboard Monitor Satpam. 2.  Database Server Pusat. 3.  Aplikasi HP Manajer.</p> <p>Jika setiap sensor harus melakukan <code>connect()</code> ke tiga tujuan itu, jaringan akan macet (Spaghetti Connection). Solusinya adalah arsitektur Publish-Subscribe (Pub/Sub).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#142-konsep-pubsub-mqtt","title":"14.2 Konsep Pub/Sub &amp; MQTT","text":"<p>MQTT (Message Queuing Telemetry Transport) adalah protokol \"Ringan\" yang didesain untuk perangkat dengan baterai kecil dan sinyal internet lemah.</p> <p>Analogi Langganan Majalah: *   Publisher (Penulis): Sensor Suhu. Dia tidak peduli siapa yang baca tulisannya. Dia cuma kirim tulisan ke Penerbit. *   Broker (Penerbit/Tukang Pos): Server Pusat (misal: Mosquitto). Dia menerima tulisan, lalu menyebarkannya ke siapapun yang berlangganan. *   Subscriber (Pembaca): Aplikasi HP/Database. Mereka \"Langganan\" topik tertentu. Jika ada edisi baru, Broker akan mengantar ke rumah mereka.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Arsitektur Pub/Sub dimana Sensor (kiri) kirim ke Broker (tengah), dan Broker sebar ke Laptop/HP (kanan)]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#143-quality-of-service-qos-seberapa-penting-data-anda","title":"14.3 Quality of Service (QoS): Seberapa Penting Data Anda?","text":"<p>MQTT punya 3 level jaminan pengiriman. Ini fitur unik yang tidak dimiliki HTTP.</p> <ol> <li>QoS 0 (At most once): \"Fire and Forget.\"<ul> <li>Kirim sekali, kalau hilang ya sudah.</li> <li>Guna: Data suhu yang dikirim tiap detik. Hilang satu tidak masalah.</li> </ul> </li> <li>QoS 1 (At least once): \"Confirmed.\"<ul> <li>Kirim terus sampai Broker bilang \"Diterima\". (Bisa duplikat).</li> <li>Guna: Sensor pintu terbuka (Alert maling).</li> </ul> </li> <li>QoS 2 (Exactly once): \"Perfect.\"<ul> <li>Dijamin sampai tepat satu kali.</li> <li>Guna: Transaksi pembayaran IoT.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#144-praktikum-simulasi-smart-home","title":"14.4 Praktikum: Simulasi Smart Home","text":"<p>Kita akan mensimulasikan sistem Rumah Cerdas. Kita butuh MQTT Broker Publik (gratisan) agar tidak perlu install server sendiri. Kita akan gunakan <code>broker.hivemq.com</code> atau <code>test.mosquitto.org</code>.</p> <p>Instalasi Pustaka: <code>pip install paho-mqtt</code></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#a-kode-subscriber-pusat-kontrolmonitor","title":"A. Kode Subscriber (Pusat Kontrol/Monitor)","text":"<p>Program ini akan \"mendengarkan\" topik <code>rumah/+/suhu</code>. Tanda <code>+</code> adalah wildcard, artinya dia menerima data dari ruang apa saja (tamu, tidur, dll).</p> <pre><code># latihan_14_mqtt_sub.py\nimport paho.mqtt.client as mqtt\n\n# 1. Konfigurasi\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC = \"kampus/iot/+\" # + adalah Wildcard satu level\n\ndef on_connect(client, userdata, flags, rc):\n    if rc == 0:\n        print(\"[SUKSES] Terhubung ke Broker!\")\n        # Langsung subscribe setelah connect\n        client.subscribe(TOPIC)\n    else:\n        print(f\"[GAGAL] Error Code: {rc}\")\n\ndef on_message(client, userdata, msg):\n    # msg.topic = \"kampus/iot/lab_komputer\"\n    # msg.payload = b\"25.5\"\n    lokasi = msg.topic.split(\"/\")[-1]\n    nilai = msg.payload.decode()\n\n    print(f\"\ud83d\udce1 Data Masuk dari [{lokasi}]: {nilai}\u00b0C\")\n\n# 2. Setup Client\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nprint(f\"Menghubungkan ke {BROKER}...\")\nclient.connect(BROKER, PORT, 60)\n\n# 3. Blocking Loop (Standby selamanya)\nclient.loop_forever()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#b-kode-publisher-sensor-dummy","title":"B. Kode Publisher (Sensor Dummy)","text":"<p>Program ini berpura-pura menjadi Sensor Suhu yang mengirim data setiap 2 detik.</p> <pre><code># latihan_14_mqtt_pub.py\nimport paho.mqtt.client as mqtt\nimport time\nimport random\n\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC_BASE = \"kampus/iot\"\n\nclient = mqtt.Client()\nprint(f\"Publisher terhubung ke {BROKER}...\")\nclient.connect(BROKER, PORT, 60)\n\nclient.loop_start() # Jalankan background thread untuk networking\n\ntry:\n    while True:\n        # Simulasi 2 sensor berbeda\n        suhu_lab = random.uniform(20.0, 25.0)\n        suhu_kantin = random.uniform(28.0, 32.0)\n\n        # Publish ke topik spesifik\n        # QoS=1 berarti \"Pastikan sampai\"\n        client.publish(f\"{TOPIC_BASE}/lab_komputer\", f\"{suhu_lab:.2f}\", qos=1)\n        print(f\"Mengirim {suhu_lab:.2f} ke Lab Komputer\")\n\n        client.publish(f\"{TOPIC_BASE}/kantin\", f\"{suhu_kantin:.2f}\", qos=1)\n        print(f\"Mengirim {suhu_kantin:.2f} ke Kantin\")\n\n        time.sleep(2)\n\nexcept KeyboardInterrupt:\n    print(\"Stop Publisher\")\n    client.loop_stop()\n    client.disconnect()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#145-tugas-mandiri-smart-garden-system","title":"14.5 Tugas Mandiri (Smart Garden System)","text":"<ol> <li>Jalankan: Hidupkan Subscriber dulu, baru Publisher. Perhatikan di terminal Subscriber, data dari \"lab_komputer\" dan \"kantin\" masuk bergantian.</li> <li>Eksperimen Topik: Ubah <code>TOPIC</code> di Subscriber menjadi <code>kampus/#</code>. Tanda <code>#</code> adalah wildcard multi-level. Coba publish ke topik <code>kampus/satpam/pos_depan</code>. Apakah masuk?</li> <li>Pengendali Lampu:<ul> <li>Buat script <code>saklar.py</code> yang mengirim pesan \"ON\" atau \"OFF\" ke topik <code>rumah/lampu</code>.</li> <li>Buat script <code>lampu.py</code> yang subscribe ke topik tersebut. Jika terima \"ON\", print \"\ud83d\udca1 NYALA\". Jika \"OFF\", print \"\u26ab MATI\".</li> <li>Ini adalah dasar pengendalian perangkat jarak jauh via internet!</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#146-catatan-security","title":"14.6 Catatan Security","text":"<p>Broker publik seperti HiveMQ/Mosquitto bersifat terbuka. Siapapun di dunia yang subscribe ke <code>kampus/iot/#</code> bisa melihat data Anda. JANGAN KIRIM DATA RAHASIA (PASSWORD/CREDENTIAL) KE BROKER PUBLIK. Untuk produksi, Anda harus menginstall broker sendiri (misal di VPS) dan mengaktifkan Username/Password authentication.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-14","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 14","text":"<p>File: <code>latihan_14_api.py</code> <pre><code># Credit: Fikom UIT\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return {\"message\": \"Halo, ini API Fikom UIT\"}\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre></p> <p>File: <code>latihan_14_mqtt_pub.py</code> <pre><code># Credit: Fikom UIT\nimport paho.mqtt.client as mqtt\nimport time\nimport random\n\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC = \"fikom/iot/suhu\"\n\ndef run_publisher():\n    client = mqtt.Client()\n\n    print(f\"Menghubungkan ke {BROKER}...\")\n    client.connect(BROKER, PORT, 60)\n\n    try:\n        while True:\n            # Simulasi Data\n            suhu = random.randint(20, 35)\n            payload = f\"{suhu} C\"\n\n            client.publish(TOPIC, payload)\n            print(f\"Published to {TOPIC}: {payload}\")\n\n            time.sleep(2)\n\n    except KeyboardInterrupt:\n        print(\"Stopped.\")\n    finally:\n        client.disconnect()\n\nif __name__ == \"__main__\":\n    run_publisher()\n</code></pre></p> <p>File: <code>latihan_14_mqtt_sub.py</code> <pre><code># Credit: Fikom UIT\nimport paho.mqtt.client as mqtt\n\n# Broker Publik Gratisan\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC = \"fikom/iot/suhu\"\n\ndef on_connect(client, userdata, flags, rc):\n    print(f\"Terhubung ke Broker! (Code: {rc})\")\n    # Langsung subscribe saat koneksi jadi\n    client.subscribe(TOPIC)\n    print(f\"Subscribed to {TOPIC}\")\n\ndef on_message(client, userdata, msg):\n    print(f\"[DATA MASUK] {msg.topic}: {msg.payload.decode()}\")\n\ndef run_subscriber():\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_message = on_message\n\n    print(f\"Menghubungkan ke {BROKER}...\")\n    try:\n        client.connect(BROKER, PORT, 60)\n        # Loop forever (blocking) untuk menangani network events\n        client.loop_forever()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    run_subscriber()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#bab-15-penutup-proyek-akhir-capstone-project","title":"Bab 15: Penutup &amp; Proyek Akhir (Capstone Project)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Merancang arsitektur sistem jaringan berskala kompleks yang mengintegrasikan minimal 3 protokol berbeda (mis: HTTP, WebSocket, TCP). 2.  Membangun aplikasi Full-Stack Network yang aman, andal, dan scalable sebagai portofolio akhir. 3.  Mengevaluasi performa dan keamanan sistem jaringan yang telah dibangun. 4.  Menyusun rencana pengembangan diri (roadmap) untuk karier di bidang Network Engineering atau Backend Development.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#151-refleksi-perjalanan-dari-bytes-ke-iot","title":"15.1 Refleksi Perjalanan: Dari Bytes ke IoT","text":"<p>Selamat! Anda telah menempuh perjalanan panjang dari Bab 1 hingga 14. Mari kita lihat kembali \"Peta Harta Karun\" yang telah Anda lewati:</p> <ol> <li>Fundamental (Bab 1-5): Anda belajar \"bicara\" bahasa mesin. Dari membedah IP Address, membuat Socket TCP/UDP mentah, hingga menangani error transmisi (Sticky Packet). Anda paham bedanya \"Telepon\" (TCP) dan \"Kartu Pos\" (UDP).</li> <li>Concurrency (Bab 6, 8, 9): Anda belajar multitasking. Dari merekrut banyak pelayan (Threading), menggunakan satu Super Satpam (Select), hingga teknik canggih Asyncio. Anda tahu cara menangani 1.000 user tanpa meledakkan RAM.</li> <li>Data &amp; Protocol (Bab 7, 10, 11): Anda tidak lagi mengirim string kosong. Anda mengirim JSON, membuat Web Server sendiri, dan mengonsumsi REST API cuaca. Anda paham bahwa HTTP hanyalah teks yang diformat rapi.</li> <li>Modern Apps (Bab 12, 13, 14): Anda memasuki era modern. Membuat Dashboard Real-time (WebSocket), mengamankan chat dengan Amplop Baja (SSL), dan menghubungkan Rumah Cerdas (MQTT).</li> </ol> <p>Anda bukan lagi sekadar Coder. Anda adalah Network Application Architect.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#152-spesifikasi-final-project-pjbl","title":"15.2 Spesifikasi Final Project (PjBL)","text":"<p>Sebagai syarat kelulusan mata kuliah ini, Anda wajib mengerjakan Project Based Learning (PjBL) secara berkelompok (3-4 orang). Tujuan proyek ini adalah membuat Satu Aplikasi Terintegrasi yang menggabungkan minimal 3 konsep utama.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#tema-distributed-smart-system","title":"Tema: \"Distributed Smart System\"","text":"<p>Buatlah sebuah sistem yang terdiri dari 3 komponen terpisah yang saling berkomunikasi.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#komponen-1-the-agent-python-bab-2-4-14","title":"Komponen 1: The Agent (Python - Bab 2, 4, 14)","text":"<ul> <li>Sebuah script kecil yang berjalan di laptop/Raspberry Pi.</li> <li>Tugas: Membaca data (bisa CPU Usage, Suhu Palsu, atau Kamera).</li> <li>Protokol: Mengirim data via MQTT atau UDP ke Server Pusat.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#komponen-2-the-core-server-python-bab-6-7-8-13","title":"Komponen 2: The Core Server (Python - Bab 6, 7, 8, 13)","text":"<ul> <li>Otak utama sistem.</li> <li>Tugas:<ul> <li>Menerima data dari Agent (Subscribe MQTT / Bind UDP).</li> <li>Menyimpan data ke File/Database (JSON/CSV).</li> <li>Menyediakan REST API sederhana untuk login user.</li> <li>(Opsional) Wajib menggunakan SSL/TLS untuk keamanan.</li> </ul> </li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#komponen-3-the-monitor-htmljs-bab-10-12","title":"Komponen 3: The Monitor (HTML/JS - Bab 10, 12)","text":"<ul> <li>Antarmuka pengguna.</li> <li>Tugas: Menampilkan data secara Real-time (wajib pakai WebSocket, dilarang Refresh page).</li> <li>User harus bisa melakukan login sederhana sebelum melihat dashboard.</li> </ul> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram Arsitektur Sistem yang menghubungkan Agent -&gt; Server -&gt; Browser]</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#153-kriteria-penilaian-profesional","title":"15.3 Kriteria Penilaian Profesional","text":"<p>Proyek ini akan dinilai layaknya sebuah tender proyek IT profesional:</p> Kriteria Bobot Deskripsi Integrasi Protokol 30% Apakah WebSocket, REST, dan MQTT berjalan harmonis tanpa crash? Keandalan (Reliability) 25% Jalankan Agent, matikan Server, nyalakan lagi. Agent harus bisa reconnect otomatis (Error Handling). Keamanan 15% Data sensitif tidak boleh plaintext. Minimal ada Auth login. Plus poin jika pakai SSL. Kode &amp; Arsitektur 20% Kerapian kode, modularitas (fungsi terpisah), dan komentar penjelasan. Dokumen &amp; Demo 10% Readme.md yang jelas dan demo live yang lancar."},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#154-peta-jalan-masa-depan-career-path","title":"15.4 Peta Jalan Masa Depan (Career Path)","text":"<p>Mata kuliah ini adalah pondasi. Dunia jaringan sangat luas. Ke mana Anda harus melangkah selanjutnya?</p> <ol> <li> <p>Jalur DevOps / SRE (Site Reliability Engineer):</p> <ul> <li>Pelajari Docker &amp; Kubernetes: Bagaimana menjalankan script server Anda bukan di laptop, tapi di container.</li> <li>Pelajari CI/CD: Otomatisasi testing dan deployment.</li> </ul> </li> <li> <p>Jalur Backend Engineer:</p> <ul> <li>Pelajari Framework: FastAPI atau Django. Mereka membungkus socket, threading, dan security yang kita pelajari menjadi paket siap pakai.</li> <li>Pelajari Database: PostgreSQL atau Redis (untuk caching data socket).</li> </ul> </li> <li> <p>Jalur IoT Engineer:</p> <ul> <li>Pelajari Elektronika: Arduino, ESP32, Raspberry Pi.</li> <li>Pelajari Protokol Industri: CoAP, Modbus.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#155-kata-penutup","title":"15.5 Kata Penutup","text":"<p>Teknologi protokol akan terus berubah. Hari ini kita pakai HTTP/1.1, besok HTTP/2, lusa HTTP/3 (QUIC/UDP). Hari ini kita pakai Socket, besok mungkin gRPC atau WebAssembly.</p> <p>Namun, Fundamental tidak pernah berubah. *   IP Address tetaplah alamat. *   Port tetaplah pintu. *   Latency tetaplah musuh. *   Dan Security tetaplah prioritas.</p> <p>Pegang teguh pemahaman fundamental yang Anda dapatkan di buku ini, dan Anda akan siap menghadapi teknologi apapun di masa depan.</p> <p>Happy Networking, and Keep the Packet Flowing! \ud83d\ude80</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#lampiran-kode-praktikum-bab-15","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 15","text":"<p>File: <code>latihan_15_project_starter.py</code> <pre><code># Credit: Fikom UIT\nimport psutil\nimport time\nimport socket\nimport json\n\n# Contoh Kode untuk Opsi B (Monitoring Agent)\n# Mengirim data CPU/RAM ke Server Monitoring\n\nSERVER_IP = 'localhost'\nSERVER_PORT = 5555\n\ndef start_agent():\n    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    print(f\"Monitoring Agent Started. Sending data to {SERVER_IP}:{SERVER_PORT}\")\n\n    try:\n        while True:\n            # Ambil metrics system\n            cpu = psutil.cpu_percent(interval=1)\n            ram = psutil.virtual_memory().percent\n            disk = psutil.disk_usage('/').percent\n\n            data = {\n                \"hostname\": socket.gethostname(),\n                \"cpu\": cpu,\n                \"ram\": ram,\n                \"disk\": disk\n            }\n\n            # Kirim via UDP (karena data stream cepat)\n            msg = json.dumps(data)\n            client.sendto(msg.encode(), (SERVER_IP, SERVER_PORT))\n\n            print(f\"Sent: {msg}\")\n\n    except KeyboardInterrupt:\n        print(\"Agent Stopped.\")\n\nif __name__ == \"__main__\":\n    # pip install psutil\n    try:\n        start_agent()\n    except ImportError:\n        print(\"Module 'psutil' not found. Install: pip install psutil\")\n</code></pre></p> <p>File: <code>latihan_15_script.py</code> <pre><code># Credit: Fikom UIT\nimport sys\nprint(f\"Script Python dijalankan dari: {sys.executable}\")\nprint(\"Integrasi Berhasil!\")\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#daftar-pustaka","title":"DAFTAR PUSTAKA","text":"<ol> <li>Rhodes, B., &amp; Goerzen, J. (2014). Foundations of Python Network Programming (3rd ed.). Apress.</li> <li>Kurose, J. F., &amp; Ross, K. W. (2021). Computer Networking: A Top-Down Approach (8th ed.). Pearson.</li> <li>Wouters, J. (2019). Learning Python Network Programming. Packt Publishing.</li> <li>Doherty, J. (2020). Python Network Programming Techniques. Packt Publishing.</li> <li>Python Software Foundation. (2025). Python 3.12 Documentation. https://docs.python.org/3/</li> <li>Mozilla Developer Network (MDN). (2025). Web Technologies for Developers. https://developer.mozilla.org/</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Final/#glosarium","title":"GLOSARIUM","text":"<ul> <li>API (Application Programming Interface): Antarmuka yang memungkinkan dua aplikasi perangkat lunak untuk saling berkomunikasi.</li> <li>Asynchronous: Model eksekusi di mana sebuah tugas tidak memblokir tugas lain, memungkinkan multitasking dalam satu thread.</li> <li>Blocking I/O: Operasi Input/Output yang menghentikan eksekusi program hingga operasi tersebut selesai.</li> <li>Client-Server: Arsitektur jaringan di mana klien meminta layanan dan server menyediakan layanan.</li> <li>Concurrency: Kemampuan program untuk menangani beberapa tugas secara tumpang tindih dalam satu rentang waktu.</li> <li>Handshake: Proses negosiasi awal antara dua pihak (misal: Client dan Server) sebelum pertukaran data dimulai.</li> <li>HTTP (HyperText Transfer Protocol): Protokol standar untuk mentransfer dokumen hypermedia di World Wide Web.</li> <li>IoT (Internet of Things): Jaringan perangkat fisik yang tertanam dengan sensor dan software untuk bertukar data via internet.</li> <li>IP Address: Label numerik yang ditetapkan untuk setiap perangkat yang terhubung ke jaringan komputer.</li> <li>JSON (JavaScript Object Notation): Format pertukaran data ringan yang mudah dibaca manusia dan mesin.</li> <li>Latency: Penundaan waktu antara pengiriman permintaan dan penerimaan respons.</li> <li>Localhost: Nama host standar yang diberikan ke alamat loopback local (127.0.0.1).</li> <li>MQTT: Protokol pesan ringan untuk sensor dan perangkat mobile kecil (IoT).</li> <li>Port: Titik akhir virtual komunikasi dalam sistem operasi untuk membedakan proses/layanan spesifik.</li> <li>Protocol: Aturan standar yang memungkinkan perangkat elektronik untuk berkomunikasi satu sama lain.</li> <li>REST (Representational State Transfer): Gaya arsitektur perangkat lunak untuk menyediakan standar antara sistem komputer di web.</li> <li>Socket: Titik akhir (endpoint) komunikasi dua arah antara dua program di jaringan.</li> <li>SSL/TLS: Protokol kriptografi yang dirancang untuk memberikan keamanan komunikasi melalui jaringan komputer.</li> <li>Thread: Unit eksekusi terkecil dalam sebuah proses.</li> <li>UDP (User Datagram Protocol): Protokol komunikasi tanpa koneksi yang memprioritaskan kecepatan di atas keandalan.</li> <li>WebSocket: Protokol komunikasi komputer yang menyediakan saluran komunikasi full-duplex melalui koneksi TCP tunggal.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/","title":"BUKU AJAR: PEMROGRAMAN JARINGAN","text":"<p>Dosen Pengampu: Ucok, S.Kom., MT Generated Date: 2026-01-02</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#pengantar-dan-prasyarat-mata-kuliah","title":"Pengantar dan Prasyarat Mata Kuliah","text":"<p>Selamat datang di mata kuliah Pemrograman Jaringan (Network Programming). Dokumen ini berisi informasi awal yang penting sebelum Anda memulai petualangan coding di dunia jaringan komputer.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#1-deskripsi-mata-kuliah","title":"1. Deskripsi Mata Kuliah","text":"<p>Mata kuliah ini dirancang untuk menjembatani teori jaringan komputer dengan praktik pengembangan aplikasi. Jika di mata kuliah \"Jaringan Komputer\" Anda belajar bagaimana kabel dan router bekerja, di sini Anda akan belajar cara membuat aplikasi yang berjalan di atas infrastruktur tersebut.</p> <p>Anda akan mulai dari level terendah (Socket API), naik ke protokol transport (TCP/UDP), menangani concurrency (Threading/Async), hingga level aplikasi modern (HTTP, WebSocket, IoT, dan Security).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#2-mengapa-belajar-pemrograman-jaringan","title":"2. Mengapa Belajar Pemrograman Jaringan?","text":"<p>Di era Cloud Computing dan IoT saat ini, hampir tidak ada aplikasi yang berdiri sendiri (standalone). *   Aplikasi HP Anda terhubung ke Server. *   Game Web terhubung ke Multiplayer Server. *   Smart Home terhubung ke Cloud. Kemampuan membangun sistem yang saling berkomunikasi adalah skill fundamental bagi Software Engineer modern.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#3-prasyarat-prerequisites","title":"3. Prasyarat (Prerequisites)","text":"<p>Agar tidak \"tersesat\" di tengah jalan, pastikan Anda telah memiliki bekal berikut:</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#a-hard-skills-wajib","title":"a. Hard Skills (Wajib)","text":"<ol> <li>Dasar Jaringan Komputer:<ul> <li>Memahami konsep IP Address &amp; Port.</li> <li>Memahami perbedaan mendasar TCP vs UDP.</li> <li>Familiar dengan Model OSI/TCP-IP.</li> </ul> </li> <li>Algoritma &amp; Pemrograman Python:<ul> <li>Lancar menggunakan sintaks dasar (Variabel, Loop, If-Else).</li> <li>Paham konsep Function dan Exception Handling (<code>try-except</code>).</li> <li>(Disarankan) Paham Konsep OOP (<code>Class</code> &amp; <code>Object</code>).</li> </ul> </li> <li>Command Line Interface (CLI):<ul> <li>Tidak takut layar hitam (Terminal/CMD).</li> <li>Bisa menggunakan perintah dasar jaringan: <code>ping</code>, <code>ipconfig</code>/<code>ifconfig</code>, <code>telnet</code>.</li> </ul> </li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#b-tools-lingkungan-kerja","title":"b. Tools &amp; Lingkungan Kerja","text":"<ol> <li>Laptop/PC: Windows, Linux, atau macOS.</li> <li>Python 3.x: Wajib terinstall dan terdaftar di PATH Environment Variable.</li> <li>Code Editor: Visual Studio Code (Rekomendasi), PyCharm, atau Sublime Text.</li> <li>Packet Analyzer (Optional): Wireshark (untuk melihat \"isi perut\" data jaringan).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#4-peta-jalan-pembelajaran-roadmap","title":"4. Peta Jalan Pembelajaran (Roadmap)","text":"<p>Buku ajar ini disusun secara bertahap: *   Fundamental: Bab 1 - 4 (Konsep, Socket, TCP, UDP). *   Concurrency: Bab 6, 8, 9 (Multi-threading, Async, Multiplexing). *   Data &amp; Error: Bab 5, 7 (Framing, JSON). *   Web &amp; Modern: Bab 10 - 12 (HTTP, REST, WebSocket). *   Advanced: Bab 13 - 15 (Security, IoT, Final Project).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-1-konsep-dasar-pemrograman-jaringan","title":"Bab 1: Konsep Dasar Pemrograman Jaringan","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#11-pendahuluan","title":"1.1 Pendahuluan","text":"<p>Pemrograman Jaringan (Network Programming) adalah seni menulis perangkat lunak yang memungkinkan proses-proses komputer yang berbeda untuk berkomunikasi satu sama lain melalui jaringan. Materi ini akan menjadi fondasi bagi Anda untuk memahami bagaimana internet bekerja, mulai dari aplikasi chat sederhana hingga sistem skala besar yang terdistribusi.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#12-model-referensi-komunikasi","title":"1.2 Model Referensi Komunikasi","text":"<p>Dalam dunia jaringan, kita menggunakan model referensi untuk memahami bagaimana data dikirim dari satu tempat ke tempat lain.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#a-model-osi-7-layer","title":"a. Model OSI (7 Layer)","text":"<p>Model konseptual yang membagi komunikasi jaringan menjadi 7 lapisan: 1. Physical: Kabel, sinyal listrik/radio (Bit). 2. Data Link: MAC Address, framing (Frame). 3. Network: IP Address, routing (Packet). 4. Transport: TCP/UDP, port, reliability (Segment). 5. Session: Manajemen sesi koneksi. 6. Presentation: Enkripsi, kompresi, format data. 7. Application: HTTP, FTP, SMTP (Data pengguna).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#b-model-tcpip-4-layer","title":"b. Model TCP/IP (4 Layer)","text":"<p>Model yang lebih praktis dan digunakan di internet saat ini: 1. Network Access: Gabungan Physical &amp; Data Link. 2. Internet: Setara Network (IP). 3. Transport: TCP &amp; UDP. 4. Application: Gabungan Session, Presentation, &amp; Application.</p> <p>Fokus Mata Kuliah ini adalah di Layer Transport (Socket) dan Layer Application.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#13-entitas-jaringan-ip-port-dan-socket","title":"1.3 Entitas Jaringan: IP, Port, dan Socket","text":"<p>Untuk berkomunikasi, kita butuh \"Alamat\" dan \"Pintu\".</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#ip-address-alamat-rumah","title":"IP Address (Alamat Rumah)","text":"<p>Alamat unik yang mengidentifikasi host/komputer di jaringan. *  IPv4: <code>192.168.1.1</code> (Paling umum). *  Localhost: <code>127.0.0.1</code> (Alamat loopback ke komputer sendiri).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#port-number-nomor-kamarpintu","title":"Port Number (Nomor Kamar/Pintu)","text":"<p>Angka 16-bit (0-65535) yang membedakan proses/aplikasi dalam satu komputer. *  Well-known Ports (0-1023): HTTP (80), HTTPS (443), SSH (22). *  Registered Ports (1024-49151): MySQL (3306), PostgreSQL (5432). *  Dynamic/Private Ports (49152-65535): Biasanya untuk client ephemeral.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#socket-wadah-komunikasi","title":"Socket (Wadah Komunikasi)","text":"<p>Titik akhir (endpoint) komunikasi dua arah antara dua program yang berjalan di jaringan. Socket = IP Address + Port Number</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#14-persiapan-environment","title":"1.4 Persiapan Environment","text":"<p>Kita akan menggunakan Python 3 karena pustaka jaringannya standar dan mudah dipahami. IDE yang disarankan: Visual Studio Code.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#cek-instalasi","title":"Cek Instalasi","text":"<p>Pastikan Python terinstal dan bisa diakses dari terminal.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#15-latihan-cek-ip-dan-hostname","title":"1.5 Latihan: Cek IP dan Hostname","text":"<p>Mari kita coba script Python sederhana untuk melihat identitas komputer kita di jaringan. Buka file <code>latihan_1_net_check.py</code>.</p> <pre><code>import socket\n\ndef check_net_info():\n  # Mengambil Hostname (Nama Komputer)\n  hostname = socket.gethostname()\n\n  # Mengambil IP Address Lokal\n  ip_address = socket.gethostbyname(hostname)\n\n  print(f\"Informasi Perangkat:\")\n  print(f\"Hostname : {hostname}\")\n  print(f\"IP Address: {ip_address}\")\n\nif __name__ == \"__main__\":\n  check_net_info()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-1","title":"Tugas Mandiri 1","text":"<ol> <li>Jalankan <code>latihan_1_net_check.py</code>.</li> <li>Buka terminal (CMD/PowerShell), jalankan perintah <code>ipconfig</code> (Windows).</li> <li>Bandingkan output program Python dengan output <code>ipconfig</code>. Apakah sama?</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-1","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 1","text":"<p>File: <code>latihan_1_net_check.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef check_net_info():\n    print(\"--- Network Information Tool ---\")\n    try:\n        # Mengambil Hostname (Nama Komputer)\n        hostname = socket.gethostname()\n\n        # Mengambil IP Address Lokal komputer ini\n        # Note: Ini biasanya mengambil IP interface utama\n        ip_address = socket.gethostbyname(hostname)\n\n        print(f\"Hostname  : {hostname}\")\n        print(f\"IP Address: {ip_address}\")\n\n    except Exception as e:\n        print(f\"Terjadi kesalahan: {e}\")\n\nif __name__ == \"__main__\":\n    check_net_info()\n</code></pre></p> <p>File: <code>latihan_1_sapa.py</code> <pre><code># Credit: Fikom UIT\ndef main():\n    print(\"Halo, Mahasiswa Fikom UIT!\")\n    nama = input(\"Siapa nama Anda? \")\n    print(f\"Selamat belajar Python, {nama}!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-2-socket-api-dasar","title":"Bab 2: Socket API Dasar","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#21-apa-itu-socket-api","title":"2.1 Apa itu Socket API?","text":"<p>Socket API adalah antarmuka pemrograman aplikasi (API) standar yang disediakan oleh sistem operasi untuk memungkinkan program aplikasi mengontrol dan menggunakan socket jaringan. Di Python, kita menggunakan modul bawaan bernama <code>socket</code>.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#22-anatomi-socket-server-vs-client","title":"2.2 Anatomi Socket: Server vs Client","text":"<p>Dalam arsitektur Client-Server, terdapat perbedaan tanggung jawab yang tercermin dalam urutan pemanggilan fungsi socket.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#langkah-langkah-server-pasif","title":"Langkah-langkah Server (Pasif)","text":"<p>Server bertugas menunggu koneksi masuk. 1. <code>socket()</code>: Membuat objek socket. 2. <code>bind((HOST, PORT))</code>: Mengikat socket ke alamat IP dan Port tertentu. 3. <code>listen(backlog)</code>: Mulai mendengarkan (listening) koneksi masuk. 4. <code>accept()</code>: Menerima koneksi dari client. Fungsi ini blocking (menunggu sampai ada yang connect). 5. <code>recv()</code> / <code>send()</code>: Bertukar data. 6. <code>close()</code>: Menutup koneksi.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#langkah-langkah-client-aktif","title":"Langkah-langkah Client (Aktif)","text":"<p>Client bertugas memulai koneksi. 1. <code>socket()</code>: Membuat objek socket. 2. <code>connect((HOST, PORT))</code>: Melakukan koneksi ke alamat Server. 3. <code>send()</code> / <code>recv()</code>: Bertukar data. 4. <code>close()</code>: Menutup koneksi.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#23-blocking-vs-non-blocking","title":"2.3 Blocking vs Non-Blocking","text":"<p>Secara default, socket Python bersifat Blocking. *  Blocking: Program akan \"berhenti\" (pause) di baris kode tertentu (seperti <code>accept()</code> atau <code>recv()</code>) sampai operasi tersebut selesai. *  Non-Blocking: Program tidak berhenti. Jika data belum siap, socket akan melempar error, dan program bisa mengerjakan hal lain. (Akan dibahas lebih lanjut di topik Concurrency).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#24-encoding-decoding","title":"2.4 Encoding &amp; Decoding","text":"<p>Data yang dikirim lewat jaringan harus berbentuk Bytes (<code>b'...'</code>), bukan String. *  Encode: String -&gt; Bytes (<code>pesan.encode('utf-8')</code>) *  Decode: Bytes -&gt; String (<code>data.decode('utf-8')</code>)</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#25-latihan-hello-world-socket","title":"2.5 Latihan: Hello World Socket","text":"<p>Kita akan membuat dua script terpisah: <code>server.py</code> dan <code>client.py</code>. Anda harus menjalankan <code>server.py</code> terlebih dahulu di satu terminal, baru kemudian <code>client.py</code> di terminal lain.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#server-code-latihan_2_serverpy","title":"Server Code (<code>latihan_2_server.py</code>)","text":"<pre><code>import socket\n\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(('localhost', 12345))\nserver_socket.listen(1)\nprint(\"Server menunggu koneksi di port 12345...\")\n\nconn, addr = server_socket.accept() # Blocking\nprint(f\"Terhubung dengan: {addr}\")\n\nmsg = conn.recv(1024).decode('utf-8') # Terima pesan\nprint(f\"Pesan dari Client: {msg}\")\n\nconn.send(\"Halo Client, pesan diterima!\".encode('utf-8'))\nconn.close()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#client-code-latihan_2_clientpy","title":"Client Code (<code>latihan_2_client.py</code>)","text":"<pre><code>import socket\n\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect(('localhost', 12345))\n\nclient_socket.send(\"Halo Server! Ini percobaan pertama.\".encode('utf-8'))\n\nresponse = client_socket.recv(1024).decode('utf-8')\nprint(f\"Balasan Server: {response}\")\n\nclient_socket.close()\n</code></pre>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-2","title":"Tugas Mandiri 2","text":"<ol> <li>Jalankan kode di atas.</li> <li>Apa yang terjadi jika Anda menjalankan Client HANYA tanpa menjalankan Server? (Expect: <code>ConnectionRefusedError</code>)</li> <li>Ubah pesan yang dikirim dan alamat Port (misal ke 9999) pada kedua sisi.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-2","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 2","text":"<p>File: <code>latihan_2_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef run_client():\n    # 1. Membuat object socket\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 2. Connect ke server\n    host = 'localhost'\n    port = 5000\n\n    try:\n        print(f\"Mencoba menghubungkan ke {host}:{port}...\")\n        client_socket.connect((host, port))\n        print(\"Terhubung!\")\n\n        # 3. Send data\n        pesan = \"Halo Server, ini Client Fikom!\"\n        client_socket.send(pesan.encode('utf-8'))\n\n        # 4. Receive response\n        data = client_socket.recv(1024)\n        print(f\"Respon Server: {data.decode('utf-8')}\")\n\n    except ConnectionRefusedError:\n        print(\"Koneksi ditolak! Pastikan Server sudah berjalan.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        # 5. Close\n        client_socket.close()\n\nif __name__ == \"__main__\":\n    run_client()\n</code></pre></p> <p>File: <code>latihan_2_kalkulator.py</code> <pre><code># Credit: Fikom UIT\ndef kalkulator():\n    print(\"--- Kalkulator Sederhana ---\")\n    a = float(input(\"Angka 1: \"))\n    b = float(input(\"Angka 2: \"))\n\n    print(f\"Hasil Tambah: {a + b}\")\n    print(f\"Hasil Kurang: {a - b}\")\n    print(f\"Hasil Kali: {a * b}\")\n    if b != 0:\n        print(f\"Hasil Bagi: {a / b}\")\n    else:\n        print(\"Tidak bisa membagi dengan nol\")\n\nif __name__ == \"__main__\":\n    kalkulator()\n</code></pre></p> <p>File: <code>latihan_2_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef run_server():\n    # 1. Membuat object socket\n    # AF_INET = IPv4, SOCK_STREAM = TCP\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 2. Bind (Mengikat ke alamat IP dan Port)\n    host = 'localhost' # Bisa juga '0.0.0.0' untuk menerima dari luar network\n    port = 5000\n    server_socket.bind((host, port))\n\n    # 3. Listen (Mulai mendengarkan)\n    # Angka 1 berarti antrian koneksi maksimum (backlog)\n    server_socket.listen(1)\n    print(f\"Server berjalan di {host}:{port}, menunggu client...\")\n\n    # 4. Accept (Menerima koneksi - BLOCKING)\n    # conn = objek socket baru khusus untuk client ini\n    # addr = alamat client (ip, port)\n    conn, addr = server_socket.accept()\n    print(f\"Koneksi diterima dari: {addr}\")\n\n    # 5. Receive &amp; Send\n    try:\n        data = conn.recv(1024) # Buffer size 1024 bytes\n        message = data.decode('utf-8')\n        print(f\"Client mengirim: {message}\")\n\n        reply = f\"Server menerima: {message}\"\n        conn.send(reply.encode('utf-8'))\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        # 6. Close connection\n        conn.close()\n        server_socket.close()\n        print(\"Koneksi ditutup.\")\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-3-protokol-tcp-aplikasi-chat","title":"Bab 3: Protokol TCP (Aplikasi Chat)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#31-karakteristik-tcp","title":"3.1 Karakteristik TCP","text":"<p>Transmission Control Protocol (TCP) adalah protokol yang berorientasi koneksi (connection-oriented) dan reliabel. Karakteristik Utama: 1. Reliable: Menjamin data sampai ke tujuan. Jika paket hilang, akan dikirim ulang. 2. Ordered: Paket data diterima sesuai urutan pengiriman. 3. Stream-oriented: Data diperlakukan seperti aliran air (byte stream), tidak ada batas paket yang eksplisit (perlu framing). 4. Flow-Control: Mencegah pengirim membanjiri penerima yang lambat.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#32-tcp-handshake-3-way-handshake","title":"3.2 TCP Handshake (3-Way Handshake)","text":"<p>Sebelum data dikirim, TCP membangun koneksi melalui 3 langkah: 1. SYN: Client meminta koneksi (Synchronize). 2. SYN-ACK: Server menyetujui (Synchronize-Acknowledge). 3. ACK: Client mengonfirmasi (Acknowledge). Baru setelah ini koneksi \"ESTABLISHED\".</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#33-studi-kasus-aplikasi-chat-sederhana","title":"3.3 Studi Kasus: Aplikasi Chat Sederhana","text":"<p>Pada Bab 2, server langsung mati setelah membalas satu pesan. Di bab ini, kita akan membuat server dan client yang bisa bertukar pesan berkali-kali sampai salah satu mengetik \"bye\".</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#logika-loop-komunikasi","title":"Logika Loop Komunikasi","text":"<p>Supaya chat bisa berlanjut, kita harus membungkus proses <code>send</code> dan <code>recv</code> di dalam Loop `while True'.</p> <p>Kode Server (<code>latihan_3_chat_server.py</code>): <pre><code>import socket\n\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('localhost', 5000))\nserver.listen(1)\nprint(\"Chat Server Siap...\")\n\nconn, addr = server.accept()\nprint(f\"Client {addr} bergabung.\")\n\nwhile True:\n  try:\n    data = conn.recv(1024).decode('utf-8')\n    if not data or data.lower() == 'bye':\n      print(\"Client memutus koneksi.\")\n      break\n    print(f\"Client: {data}\")\n\n    reply = input(\"Server (Anda): \")\n    conn.send(reply.encode('utf-8'))\n    if reply.lower() == 'bye':\n      break\n  except Exception as e:\n    print(f\"Error: {e}\")\n    break\n\nconn.close()\n</code></pre></p> <p>Kelemahan kode di atas: *  Karena <code>input()</code> itu blocking, Server tidak bisa menerima pesan Client saat sedang mengetik balasan, dan sebaliknya. Komunikasi harus bergantian (Walkie-Talkie style). *  Solusinya: Menggunakan Multi-threading (Bab 6) atau Asynchronous (Bab 8).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-3-project-based","title":"Tugas Mandiri 3 (Project Based)","text":"<ol> <li>Jalankan Chat Server dan Chat Client.</li> <li>Lakukan percakapan pendek.</li> <li>Analisis apa yang terjadi jika Anda mencoba mengirim dua pesan berturut-turut tanpa menunggu balasan lawan bicara.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-3","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 3","text":"<p>File: <code>latihan_3_chat_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef chat_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    print(\"=== Chat Client (TCP) ===\")\n\n    try:\n        client.connect(('localhost', 5000))\n        print(\"Terhubung ke Server! Silakan kirim pesan.\")\n\n        while True:\n            # Kirim pesan duluan\n            pesan = input(\"Anda (Client): \")\n            client.send(pesan.encode('utf-8'))\n\n            if pesan.lower() == 'bye':\n                print(\"[!] Anda mengakhiri obrolan.\")\n                break\n\n            # Tunggu balasan server\n            print(\"Menunggu balasan server...\")\n            response = client.recv(1024).decode('utf-8')\n\n            if not response or response.lower() == 'bye':\n                print(\"\\n[!] Server mengakhiri obrolan.\")\n                break\n\n            print(f\"\\nServer: {response}\")\n\n    except ConnectionRefusedError:\n        print(\"[!] Gagal connect. Server belum nyala?\")\n    except ConnectionResetError:\n        print(\"\\n[!] Koneksi terputus.\")\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    chat_client()\n</code></pre></p> <p>File: <code>latihan_3_chat_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef chat_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('localhost', 5000))\n    server.listen(1)\n    print(\"=== Chat Server (TCP) ===\")\n    print(\"Menunggu lawan bicara...\")\n\n    conn, addr = server.accept()\n    print(f\"Terhubung dengan {addr}\")\n\n    while True:\n        try:\n            # Terima pesan dari client\n            data = conn.recv(1024).decode('utf-8')\n\n            # Cek jika koneksi putus atau client bilang bye\n            if not data or data.lower() == 'bye':\n                print(\"\\n[!] Client mengakhiri obrolan.\")\n                break\n\n            print(f\"\\nClient: {data}\")\n\n            # Balas pesan\n            response = input(\"Anda (Server): \")\n            conn.send(response.encode('utf-8'))\n\n            if response.lower() == 'bye':\n                print(\"[!] Anda mengakhiri obrolan.\")\n                break\n\n        except ConnectionResetError:\n            print(\"\\n[!] Koneksi diputus paksa oleh client.\")\n            break\n\n    conn.close()\n    server.close()\n\nif __name__ == \"__main__\":\n    chat_server()\n</code></pre></p> <p>File: <code>latihan_3_grade.py</code> <pre><code># Credit: Fikom UIT\ndef cek_grade(nilai):\n    if nilai &gt;= 85:\n        return \"A\"\n    elif nilai &gt;= 70:\n        return \"B\"\n    elif nilai &gt;= 60:\n        return \"C\"\n    else:\n        return \"D\"\n\nif __name__ == \"__main__\":\n    n = int(input(\"Masukkan Nilai Angka: \"))\n    print(f\"Grade Anda: {cek_grade(n)}\")\n</code></pre></p> <p>File: <code>latihan_3_loop.py</code> <pre><code># Credit: Fikom UIT\nprint(\"--- Deret Ganjil ---\")\nfor i in range(1, 10, 2):\n    print(i, end=\" \")\nprint()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-4-protokol-udp-streaming-broadcasting","title":"Bab 4: Protokol UDP (Streaming &amp; Broadcasting)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#41-karakteristik-udp","title":"4.1 Karakteristik UDP","text":"<p>User Datagram Protocol (UDP) dijuluki sebagai protokol \"Fire and Forget\". Karakteristik Utama: 1. Connectionless: Tidak ada handshake awal. Langsung kirim! 2. Unreliable: Tidak ada jaminan paket sampai. Jika hilang di jalan, ya sudah hilang (effort-best delivery). 3. No Ordering: Paket A dikirim sebelum B, bisa saja B sampai duluan. 4. Header Kecil: Overhead sangat kecil (8 bytes vs TCP 20+ bytes), sehingga SANGAT CEPAT.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#42-kapan-menggunakan-udp","title":"4.2 Kapan Menggunakan UDP?","text":"<ul> <li>Video Streaming/VoIP (Zoom, YouTube Live): Kehilangan 1-2 frame tidak masalah, yang penting video lancar (low latency).</li> <li>Game Online (FPS/MOBA): Posisi player harus update secepat mungkin.</li> <li>DNS Queries: Kecil dan harus cepat.</li> <li>IoT Sensor Data: Mengirim data suhu tiap detik. Jika data detik ke-5 hilang, tidak masalah karena akan ada data detik ke-6.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#43-perbedaan-coding-tcp-vs-udp","title":"4.3 Perbedaan Coding TCP vs UDP","text":"Fitur TCP (<code>SOCK_STREAM</code>) UDP (<code>SOCK_DGRAM</code>) Tipe Socket <code>socket.SOCK_STREAM</code> <code>socket.SOCK_DGRAM</code> Koneksi <code>connect()</code>, <code>listen()</code>, <code>accept()</code> Tidak ada (langsung kirim) Kirim Data <code>send()</code> / <code>sendall()</code> <code>sendto(data, address)</code> Terima Data <code>recv()</code> <code>recvfrom()</code> -&gt; returns <code>(data, address)</code>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#44-latihan-simulasi-sensor-suhu","title":"4.4 Latihan: Simulasi Sensor Suhu","text":"<p>Kita akan membuat sistem di mana Client bertindak sebagai sensor yang mengirim \"suhu\" dummy terus menerus ke Server.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#server-receiver","title":"Server (Receiver)","text":"<p>Server UDP cukup bind port dan melakukan looping <code>recvfrom</code>. <pre><code># latihan_4_udp_receiver.py\nimport socket\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.bind(('localhost', 9999))\n\nprint(\"UDP Server siap menerima data sensor...\")\n\nwhile True:\n  data, addr = sock.recvfrom(1024)\n  print(f\"Dapat data dari {addr}: {data.decode()}\")\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#client-sender","title":"Client (Sender)","text":"<p>Client UDP bahkan tidak perlu <code>connect</code>. Cukup loop <code>sendto</code>. <pre><code># latihan_4_udp_sender.py\nimport socket\nimport time\nimport random\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\ntarget_addr = ('localhost', 9999)\n\nwhile True:\n  suhu = random.randint(20, 35)\n  pesan = f\"Suhu: {suhu} C\"\n  sock.sendto(pesan.encode(), target_addr)\n  print(f\"Mengirim: {pesan}\")\n  time.sleep(1) # Delay 1 detik\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-4","title":"Tugas Mandiri 4","text":"<ol> <li>Jalankan Receiver.</li> <li>Jalankan Sender.</li> <li>Matikan Receiver (Ctrl+C), biarkan Sender tetap jalan. Apa yang terjadi pada Sender? (Jawab: Sender tidak akan error, ia tetap mengirim paket ke \"antah berantah\". Ini bukti sifat connectionless UDP).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-4","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 4","text":"<p>File: <code>latihan_4_data_mhs.py</code> <pre><code># Credit: Fikom UIT\nmahasiswa = []\n\ndef tambah_mhs(nama, nim):\n    mhs = {\"nama\": nama, \"nim\": nim}\n    mahasiswa.append(mhs)\n\ndef tampilkan_semua():\n    print(f\"--- Data Mahasiswa ({len(mahasiswa)} orang) ---\")\n    for m in mahasiswa:\n        print(f\"NIM: {m['nim']} - Nama: {m['nama']}\")\n\nif __name__ == \"__main__\":\n    tambah_mhs(\"Andi\", \"A11.2025.001\")\n    tambah_mhs(\"Budi\", \"A11.2025.002\")\n    tampilkan_semua()\n</code></pre></p> <p>File: <code>latihan_4_udp_receiver.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef udp_receiver():\n    # Perhatikan: SOCK_DGRAM untuk UDP\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    # Tetap perlu bind agar bisa menerima data di port tertentu\n    ip = 'localhost'\n    port = 9999\n    try:\n        sock.bind((ip, port))\n        print(f\"UDP Server Listening on {ip}:{port}\")\n\n        while True:\n            # recvfrom mengembalikan (data, address_pengirim)\n            # Berbeda dengan recv() TCP yg cuma return data\n            data, addr = sock.recvfrom(1024)\n            print(f\"[{addr}] Data Masuk: {data.decode('utf-8')}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nServer dihentikan.\")\n    finally:\n        sock.close()\n\nif __name__ == \"__main__\":\n    udp_receiver()\n</code></pre></p> <p>File: <code>latihan_4_udp_sender.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport time\nimport random\n\ndef udp_sender():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    # UDP tidak perlu connect()\n    target_ip = 'localhost'\n    target_port = 9999\n    target_addr = (target_ip, target_port)\n\n    print(f\"Mulai mengirim data dummy ke {target_addr}...\")\n    print(\"Tekan Ctrl+C untuk berhenti.\")\n\n    try:\n        packet_count = 0\n        while True:\n            packet_count += 1\n            # Simulasi data sensor\n            suhu = random.randint(20, 40)\n            kelembapan = random.randint(40, 80)\n\n            payload = f\"#{packet_count} | Suhu: {suhu}C, Hum: {kelembapan}%\"\n\n            # sendto butuh argumen alamat tujuan setiap kali kirim\n            sock.sendto(payload.encode('utf-8'), target_addr)\n\n            print(f\"Sent: {payload}\")\n            time.sleep(1) # Kirim setiap 1 detik\n\n    except KeyboardInterrupt:\n        print(\"\\nPengiriman data dihentikan.\")\n    finally:\n        sock.close()\n\nif __name__ == \"__main__\":\n    udp_sender()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-5-error-handling-framing-data","title":"Bab 5: Error Handling &amp; Framing Data","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#51-tantangan-komunikasi-jaringan","title":"5.1 Tantangan Komunikasi Jaringan","text":"<p>Di dunia nyata, jaringan tidak selalu sempurna. Kabel bisa putus, sinyal WiFi hilang, atau aplikasi crash. Program jaringan yang baik harus bisa menangani: 1. Connection Reset: Lawan bicara menutup koneksi secara paksa. 2. Timeout: Tidak ada data yang masuk dalam jangka waktu tertentu. 3. Data Fragmentation/Coalescing (Sticky Packet): Masalah utama pada TCP stream.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#52-masalah-sticky-packet","title":"5.2 Masalah \"Sticky Packet\"","text":"<p>TCP bersifat stream-oriented. TCP tidak mengirim \"pesan\", ia mengirim \"byte\". Jika kita mengirim \"Halo\" dan \"Dunia\" sangat cepat: *  Harapan: <code>recv</code> pertama dapat \"Halo\", <code>recv</code> kedua dapat \"Dunia\". *  Kenyataan: Bisa jadi <code>recv</code> pertama dapat \"HaloDunia\" (lengket/sticky), atau \"Hal\" dan \"oDunia\" (terpotong).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#kenapa-terjadi","title":"Kenapa terjadi?","text":"<p>Nagle's Algorithm pada TCP menahan data kecil untuk digabungkan menjadi satu paket besar demi efisiensi bandwidth.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#53-solusi-framing","title":"5.3 Solusi: Framing","text":"<p>Framing adalah teknik memberi batas pada pesan agar penerima tahu di mana pesan berawal dan berakhir.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#metode-1-delimiter-pemisah","title":"Metode 1: Delimiter (Pemisah)","text":"<p>Menambahkan karakter khusus di akhir setiap pesan, misal <code>\\n</code> (newline). *  Format: <code>Pesan1\\nPesan2\\n</code> *  Penerima membaca terus sampai ketemu <code>\\n</code>.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#metode-2-fixed-length","title":"Metode 2: Fixed Length","text":"<p>Setiap pesan panjangnya PASTI X bytes. *  Jika pesan kurang dari X, tambahkan padding (spasi).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#metode-3-header-length-prefixed","title":"Metode 3: Header Length (Prefixed)","text":"<p>Kirim panjang pesan dulu (misal 4 byte integer), baru isi pesannya. *  Header: <code>0005</code> (artinya 5 byte data berikut adalah isinya). *  Body: <code>HELLO</code>.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#54-latihan-mengatasi-sticky-packet","title":"5.4 Latihan: Mengatasi Sticky Packet","text":"<p>Kita akan membuat server yang menggunakan metode Delimiter (\\n).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#kode-server","title":"Kode Server","text":"<p>Lihat <code>latihan_5_sticky_server.py</code>. Server ini menggunakan <code>makefile</code> untuk mempermudah pembacaan baris-per-baris layaknya membaca file teks biasa.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#55-buffering-timeout","title":"5.5 Buffering &amp; Timeout","text":"<p>Saat menggunakan <code>socket</code>, data masuk ke buffer OS dulu sebelum diambil aplikasi. Mengatur timeout: <code>sock.settimeout(5.0)</code> (Throw error jika 5 detik hening).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-5","title":"Tugas Mandiri 5","text":"<ol> <li>Jalankan server dan client latihan 5.</li> <li>Coba modifikasi client untuk mengirim 10 pesan \"TEST\" dengan sangat cepat tanpa <code>time.sleep</code>.</li> <li>Amati apakah server menerima satu per satu atau sekaligus jika tanpa framing yang benar.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-5","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 5","text":"<p>File: <code>latihan_5_fungsi.py</code> <pre><code># Credit: Fikom UIT\ndef luas_persegi_panjang(panjang, lebar):\n    return panjang * lebar\n\ndef sapa(nama=\"Teman\"):\n    print(f\"Halo, {nama}!\")\n\nif __name__ == \"__main__\":\n    l = luas_persegi_panjang(10, 5)\n    print(f\"Luas: {l}\")\n    sapa()\n</code></pre></p> <p>File: <code>latihan_5_sticky_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport time\n\ndef sticky_packet_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('localhost', 5000))\n\n    # CASE 1: Kirim pesan \"nempel\" (Sticky Packet)\n    # Kita kirim banyak pesan sekaligus tanpa delay\n    print(\"Mengirim 5 pesan sekaligus...\")\n\n    # Perhatikan: Setiap pesan DIAKHIRI '\\n' sebagai delimiter\n    paket_besar = \"\"\n    for i in range(5):\n        paket_besar += f\"PesanKe-{i+1}\\n\"\n\n    # Kirim sekaligus dalam satu kali send()\n    # Di sisi jaringan, ini akan jadi satu blok data\n    client.send(paket_besar.encode('utf-8'))\n\n    # Baca balasan satu per satu\n    socket_file = client.makefile('r', encoding='utf-8')\n    try:\n        for _ in range(5):\n            response = socket_file.readline().strip()\n            print(f\"Jawab Server: {response}\")\n    except Exception as e:\n        print(f\"Error baca: {e}\")\n\n    client.close()\n\nif __name__ == \"__main__\":\n    sticky_packet_client()\n</code></pre></p> <p>File: <code>latihan_5_sticky_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\ndef sticky_packet_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('localhost', 5000))\n    server.listen(1)\n    print(\"=== Sticky Packet Server (Delimiter Mode) ===\")\n\n    conn, addr = server.accept()\n    print(f\"Connected: {addr}\")\n\n    # Teknik: Menggunakan makefile() agar bisa pakai readline()\n    # Ini cara termudah menangani framing berbasis delimiter '\\n'\n    socket_file = conn.makefile('r', encoding='utf-8')\n\n    conn.settimeout(10.0) # Jika 10 detik diam, anggap putus\n\n    try:\n        while True:\n            # readline() akan terus membaca sampai ketemu '\\n'\n            # Ini otomatis menangani fragmentasi atau penggabungan paket\n            line = socket_file.readline()\n\n            if not line:\n                break # Koneksi putus\n\n            # Hilangkan whitespace/newline di ujung\n            cleaned_msg = line.strip()\n            print(f\"Terima Pesan Utuh: {cleaned_msg}\")\n\n            # Kirim balasan juga harus pakai delimiter\n            conn.send(f\"ACK: {cleaned_msg}\\n\".encode('utf-8'))\n\n    except socket.timeout:\n        print(\"Timeout! Client terlalu lama diam.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        socket_file.close() # Penting menutup reader wrapper\n        conn.close()\n        server.close()\n\nif __name__ == \"__main__\":\n    sticky_packet_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-6-concurrency-part-i-threading","title":"Bab 6: Concurrency Part I - Threading","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#61-limitasi-server-single-thread","title":"6.1 Limitasi Server Single-Thread","text":"<p>Pada bab-bab sebelumnya, server kita hanya bisa melayani SATU client dalam satu waktu. Jika Client A tersambung, Client B harus menunggu sampai Client A putus. Ini disebut Iterative Server. Tentu ini tidak berguna untuk aplikasi nyata seperti Chat Room.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#62-konsep-concurrency","title":"6.2 Konsep Concurrency","text":"<p>Concurrency adalah kemampuan program untuk menangani banyak tugas \"seolah-olah\" bersamaan. Ada dua pendekatan utama: 1. Multi-threading: Menggunakan \"pekerja\" tambahan (Thread) dalam satu proses memori yang sama. 2. Multi-processing: Menggunakan core CPU/Proses OS berbeda (lebih berat, memori terpisah).</p> <p>Untuk aplikasi I/O Bound (jaringan), Threading adalah pilihan standar.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#63-threading-di-python","title":"6.3 Threading di Python","text":"<p>Modul <code>threading</code> memungkinkan kita menjalan fungsi secara paralel. Konsep utamanya: Setiap kali <code>accept()</code> menerima client baru, kita buat Thread baru khusus untuk melayani client tersebut. Thread utama (Main Thread) kembali fokus looping <code>accept()</code> untuk menunggu tamu berikutnya.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#64-shared-resource-thread-safety","title":"6.4 Shared Resource &amp; Thread Safety","text":"<p>Karena Thread berbagi memori yang sama, bahaya terbesar adalah Race Condition. Contoh: Dua thread mencoba menulis ke file log yang sama bersamaan -&gt; File rusak. Solusi: Gunakan Lock / Mutex.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#65-latihan-chat-room-multi-client","title":"6.5 Latihan: Chat Room Multi-Client","text":"<p>Kita akan membangun Server yang bisa menampung banyak orang dan membroadcast pesan.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#alur-program-server","title":"Alur Program Server","text":"<ol> <li>Buat List global <code>CLIENTS = []</code>.</li> <li>Saat client connect -&gt; Masukkan ke List -&gt; Start Thread pembantu.</li> <li>Fungsi Thread pembantu: <code>while True</code> terima pesan -&gt; Broadcast ke semua socket di <code>CLIENTS</code>.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-6-project","title":"Tugas Mandiri 6 (Project)","text":"<ol> <li>Jalankan <code>latihan_6_thread_server.py</code>.</li> <li>Jalankan minimal 3 Client (bisa pakai kode client Bab 3).</li> <li>Kirim pesan dari Client 1, pastikan Client 2 dan 3 menerimanya.</li> <li>Coba matikan satu client, server harusnya tidak crash dan menghapus client tersebut dari daftar.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-6","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 6","text":"<p>File: <code>latihan_6_file_io.py</code> <pre><code># Credit: Fikom UIT\ndef tulis_log(pesan):\n    try:\n        with open(\"log.txt\", \"a\") as f:\n            f.write(pesan + \"\\n\")\n        print(\"Log berhasil ditulis.\")\n    except Exception as e:\n        print(f\"Gagal menulis file: {e}\")\n\nif __name__ == \"__main__\":\n    tulis_log(\"Sistem dimulai...\")\n    tulis_log(\"User login.\")\n</code></pre></p> <p>File: <code>latihan_6_thread_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport threading\n\n# Global variables\nCLIENTS = [] # Menyimpan daftar koneksi aktif\nLOCK = threading.Lock() # Untuk mencegah race condition saat akses list\n\ndef broadcast(message, sender_conn=None):\n    \"\"\"\n    Mengirim pesan ke SEMUA client yang terhubung,\n    kecuali si pengirim (opsional).\n    \"\"\"\n    with LOCK: # Kunci akses agar tidak bentrok\n        for conn in CLIENTS:\n            if conn != sender_conn:\n                try:\n                    conn.send(message)\n                except:\n                    # Jika gagal kirim, mungkin koneksi sudah putus/rusak\n                    conn.close()\n                    # Kita remove nanti atau biarkan handle_client yang urus\n                    pass\n\ndef handle_client(conn, addr):\n    \"\"\"\n    Fungsi yang akan dijalankan oleh setiap Thread.\n    Menangani komunikasi unik dengan satu client.\n    \"\"\"\n    print(f\"[NEW] {addr} connected.\")\n\n    # Masukkan ke daftar global\n    with LOCK:\n        CLIENTS.append(conn)\n\n    broadcast(f\"\\n[INFO] {addr} bergabung ke chat room!\\n\".encode('utf-8'), conn)\n\n    try:\n        conn.send(\"Selamat datang di Fikom Chat Room!\\n\".encode('utf-8'))\n        while True:\n            data = conn.recv(1024)\n            if not data:\n                break # Client putus\n\n            msg = data.decode('utf-8')\n            # Format pesan broadast\n            final_msg = f\"[{addr[1]}] says: {msg}\"\n            broadcast(final_msg.encode('utf-8'), conn)\n\n    except Exception as e:\n        print(f\"[ERR] {addr}: {e}\")\n    finally:\n        # Bersih-bersih saat client disconnect\n        with LOCK:\n            if conn in CLIENTS:\n                CLIENTS.remove(conn)\n\n        broadcast(f\"\\ninfo: {addr} telah keluar.\\n\".encode('utf-8'))\n        conn.close()\n        print(f\"[DISCONNECT] {addr} disconnected.\")\n\ndef run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # SO_REUSEADDR agar port langsung bisa dipakai lagi setelah stop\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    server.bind(('0.0.0.0', 6000)) # Port 6000\n    server.listen(5)\n    print(\"=== Multi-Threaded Chat Server Running on Port 6000 ===\")\n\n    while True:\n        # Main Thread hanya fokus menerima tamu\n        conn, addr = server.accept()\n\n        # Buat thread baru untuk melayani tamu tersebut\n        # target=fungsi yg dijalankan, args=argumen fungsi tsb\n        thread = threading.Thread(target=handle_client, args=(conn, addr))\n        thread.start()\n\n        print(f\"[ACTIVE CONNECTIONS] {threading.active_count() - 1}\")\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-7-serialisasi-data-json-pickle","title":"Bab 7: Serialisasi Data (JSON &amp; Pickle)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#71-masalah-pengiriman-data-kompleks","title":"7.1 Masalah Pengiriman Data Kompleks","text":"<p>Socket hanya bisa mengirim Bytes. Bagaimana jika kita ingin mengirim: *  Dictionary Python: <code>{'nama': 'Budi', 'nilai': 90}</code> *  List: <code>[1, 2, 3]</code> *  Objek Class: <code>Mahasiswa()</code></p> <p>Kita tidak bisa langsung melakukan <code>socket.send(dictionary)</code>. Kita harus mengubahnya menjadi format string atau bytes dulu. Proses ini disebut Serialisasi (Serialization) atau Marshalling. Proses kebalikannya disebut Deserialisasi.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#72-json-javascript-object-notation","title":"7.2 JSON (JavaScript Object Notation)","text":"<p>Standar de facto untuk pertukaran data modern. *  Kelebihan: Teks terbaca manusia (human-readable), didukung semua bahasa (py, js, java, php). *  Kekurangan: Hanya mendukung tipe data dasar (str, int, list, dict), tidak bisa menyimpan objek function/class python custom. *  Modul Python: <code>json</code>   *  <code>json.dumps(obj)</code> -&gt; Mengubah obj jadi String JSON.   *  <code>json.loads(str)</code> -&gt; Mengubah String JSON jadi obj Python.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#73-pickle","title":"7.3 Pickle","text":"<p>Format serialisasi khusus Python (binary). *  Kelebihan: Bisa menyimpan hampir semua objek Python (termasuk class custom). *  Kekurangan: TIDAK AMAN (bisa eksekusi kode jahat saat load), hanya bisa dibaca oleh Python. *  Saran: Gunakan JSON untuk komunikasi antar-aplikasi, Pickle hanya untuk simpan internal terpercaya.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#74-latihan-mengirim-data-mahasiswa-via-json","title":"7.4 Latihan: Mengirim Data Mahasiswa via JSON","text":"<p>Kita akan membuat server yang menerima query NIM dalam format JSON, dan membalas dengan Data Mahasiswa dalam format JSON juga.</p> <p>Alur Protokol: 1. Client kirim: <code>{\"command\": \"GET_MHS\", \"nim\": \"123\"}</code> 2. Server jawab: <code>{\"status\": \"OK\", \"data\": {\"nama\": \"Budi\", \"prodi\": \"TI\"}}</code></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-7","title":"Tugas Mandiri 7","text":"<ol> <li>Jalankan <code>latihan_7_json_server.py</code>.</li> <li>Jalankan <code>latihan_7_json_client.py</code>.</li> <li>Coba masukkan NIM yang ada (101, 102) dan yang tidak ada.</li> <li>Apa yang terjadi jika Anda megirim JSON yang formatnya salah (typo)? Server harus menangani error decoding.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-7","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 7","text":"<p>File: <code>latihan_7_class.py</code> <pre><code># Credit: Fikom UIT\nclass Mahasiswa:\n    def __init__(self, nama, nim):\n        self.nama = nama\n        self.nim = nim\n\n    def perkenalan(self):\n        print(f\"Halo, saya {self.nama}, NIM {self.nim}\")\n\nif __name__ == \"__main__\":\n    m1 = Mahasiswa(\"Siti\", \"12345\")\n    m1.perkenalan()\n</code></pre></p> <p>File: <code>latihan_7_json_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport json\n\ndef json_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    try:\n        client.connect(('localhost', 7000))\n\n        print(\"Menu Request:\")\n        print(\"1. Cari Mahasiswa (101, 102, 103)\")\n        nim_input = input(\"Masukkan NIM: \")\n\n        # Buat Dictionary Request\n        request_packet = {\n            \"command\": \"GET_MHS\",\n            \"nim\": nim_input\n        }\n\n        # Serialisasi ke String JSON\n        json_str = json.dumps(request_packet)\n\n        # Kirim\n        client.send(json_str.encode('utf-8'))\n\n        # Terima Balasan\n        raw_response = client.recv(4096).decode('utf-8')\n\n        # Deserialisasi Balasan\n        response_dict = json.loads(raw_response)\n\n        print(\"\\n--- Respon Server ---\")\n        if response_dict['status'] == 'OK':\n            mhs = response_dict['data']\n            print(f\"Nama : {mhs['nama']}\")\n            print(f\"Prodi: {mhs['prodi']}\")\n            print(f\"IPK  : {mhs['ipk']}\")\n        else:\n            print(f\"Error: {response_dict.get('msg')}\")\n\n    except Exception as e:\n        print(f\"Error connection: {e}\")\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    json_client()\n</code></pre></p> <p>File: <code>latihan_7_json_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport json\n\n# Database dummy\nDATABASE = {\n    \"101\": {\"nama\": \"Andi Saputra\", \"prodi\": \"Informatika\", \"ipk\": 3.75},\n    \"102\": {\"nama\": \"Budi Santoso\", \"prodi\": \"Sistem Informasi\", \"ipk\": 3.40},\n    \"103\": {\"nama\": \"Citra Lestari\", \"prodi\": \"Informatika\", \"ipk\": 3.90}\n}\n\ndef json_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('localhost', 7000))\n    server.listen(5)\n    print(\"=== JSON Database Server Running on Port 7000 ===\")\n\n    while True:\n        conn, addr = server.accept()\n        print(f\"Connection from {addr}\")\n\n        try:\n            # Terima data (asumsi max 4096 bytes)\n            raw_data = conn.recv(4096).decode('utf-8')\n            if not raw_data:\n                continue\n\n            print(f\"Request Raw: {raw_data}\")\n\n            # 1. Deserialisasi (String JSON -&gt; Dict Python)\n            try:\n                request = json.loads(raw_data)\n            except json.JSONDecodeError:\n                response = {\"status\": \"ERROR\", \"msg\": \"Invalid JSON Format\"}\n                conn.send(json.dumps(response).encode('utf-8'))\n                conn.close()\n                continue\n\n            # 2. Proses Logika\n            command = request.get(\"command\")\n            nim = request.get(\"nim\")\n\n            response = {}\n            if command == \"GET_MHS\":\n                data = DATABASE.get(nim)\n                if data:\n                    response = {\"status\": \"OK\", \"data\": data}\n                else:\n                    response = {\"status\": \"NOT_FOUND\", \"msg\": f\"NIM {nim} tidak ditemukan\"}\n            else:\n                 response = {\"status\": \"ERROR\", \"msg\": \"Unknown Command\"}\n\n            # 3. Serialisasi Balasan (Dict -&gt; JSON String -&gt; Bytes)\n            json_reply = json.dumps(response)\n            conn.send(json_reply.encode('utf-8'))\n\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            conn.close()\n\nif __name__ == \"__main__\":\n    json_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-8-asynchronous-io-concurrency-part-ii","title":"Bab 8: Asynchronous I/O (Concurrency Part II)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#81-kelemahan-multi-threading","title":"8.1 Kelemahan Multi-threading","text":"<p>Pada Bab 6 kita menggunakan Threading. Meskipun mudah, threading punya kelemahan: 1. Overhead Memori: Setiap thread butuh memori stack sendiri (misal 8MB per thread). Jika ada 10.000 user, RAM akan habis. 2. Context Switching: CPU terbebani karena harus terus menerus berganti fokus antar ribuah thread.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#82-konsep-asynchronous-single-threaded","title":"8.2 Konsep Asynchronous (Single-Threaded)","text":"<p>Bayangkan seorang pelayan restoran (Single Thread). *  Blocking (Synchronous): Pelayan menerima pesanan Meja A, lalu berdiri menunggu koki selesai masak, baru antar ke Meja A. Sementara menunggu, Meja B tidak bisa pesan. (Sangat lambat). *  Asynchronous: Pelayan terima pesanan Meja A, kasih ke dapur. Sambil menunggu masakan jadi, dia terima pesanan Meja B, Meja C, dst. Jika masakan Meja A jadi, dia dipanggil (callback/await) untuk mengantar. Hasil? Satu pelayan bisa melayani ratusan meja.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#83-python-asyncio","title":"8.3 Python <code>asyncio</code>","text":"<p>Sejak Python 3.5, diperkenalkan sintaks <code>async</code> dan <code>await</code>. *  Coroutines: Fungsi spesial yang bisa di-pause dan di-resume. Didefinisikan dengan <code>async def</code>. *  Event Loop: Jantung dari asyncio yang mengatur eksekusi coroutines.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#84-latihan-async-echo-server","title":"8.4 Latihan: Async Echo Server","text":"<p>Kita akan membuat server yang bisa menangani ribuan koneksi menggunakan satu thread saja.</p> <p>Kode utama menggunakan library <code>asyncio</code>. Perbedaan dengan socket biasa: *  <code>socket.accept()</code> -&gt; diganti <code>await loop.sock_accept(sock)</code> *  <code>conn.recv()</code> -&gt; diganti <code>await loop.sock_recv(conn, 1024)</code></p> <p>Catatan: Untuk level lanjutan, biasanya orang menggunakan library <code>aiohttp</code> atau <code>FastAPI</code> yang dibangun di atas asyncio.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-8","title":"Tugas Mandiri 8","text":"<ol> <li>Jalankan <code>latihan_8_async_server.py</code>.</li> <li>Coba konek menggunakan <code>telnet</code> atau client TCP biasa dari bab sebelumnya (bisa pakai Client Bab 2).</li> <li>Server ini sangat ringan resource.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-8","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 8","text":"<p>File: <code>latihan_8_async_server.py</code> <pre><code># Credit: Fikom UIT\nimport asyncio\nimport socket\n\n# Asyncio membutuhkan definisi fungsi dengan 'async def'\nasync def handle_client(reader, writer):\n    # Dapatkan alamat client\n    addr = writer.get_extra_info('peername')\n    print(f\"[NEW] {addr} connected.\")\n\n    writer.write(f\"Halo {addr}, selamat datang di Async Server!\\n\".encode())\n    await writer.drain() # Pastikan data terkirim\n\n    try:\n        while True:\n            # await: \"Tunggu data masuk, tapi sambil nunggu, kerjakan yang lain\"\n            data = await reader.read(100)\n            if not data:\n                break\n\n            message = data.decode().strip()\n            print(f\"[{addr}] Received: {message}\")\n\n            # Echo balik\n            response = f\"Echo: {message}\\n\"\n            writer.write(response.encode())\n            await writer.drain()\n\n    except Exception as e:\n        print(f\"Error {addr}: {e}\")\n    finally:\n        print(f\"[CLOSE] {addr} closed.\")\n        writer.close()\n        await writer.wait_closed()\n\nasync def main():\n    # Membuat server dengan API High-Level asyncio\n    server = await asyncio.start_server(\n        handle_client, '127.0.0.1', 8888)\n\n    addr = server.sockets[0].getsockname()\n    print(f'=== Asyncio Server Serving on {addr} ===')\n\n    # Server forever loop\n    async with server:\n        await server.serve_forever()\n\nif __name__ == \"__main__\":\n    try:\n        # Menjalankan Event Loop\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\nServer Stopped.\")\n</code></pre></p> <p>File: <code>latihan_8_cek_ip.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\nhostname = socket.gethostname()\nip = socket.gethostbyname(hostname)\n\nprint(f\"Hostname: {hostname}\")\nprint(f\"IP Address: {ip}\")\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-9-io-multiplexing-select-poll","title":"Bab 9: I/O Multiplexing (<code>select</code> &amp; <code>poll</code>)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#91-keterbatasan-threading-blocking-io","title":"9.1 Keterbatasan Threading &amp; Blocking I/O","text":"<p>Di Bab 6 &amp; 8, kita sudah belajar cara menangani banyak koneksi. *  Blocking I/O (Basic): Server berhenti menunggu satu client -&gt; Tidak efisien. *  Threading: Satu thread per client -&gt; Boros RAM. *  Asyncio: Modern dan efisien, tapi cara kerjanya \"ajaib\" (high level abstraction).</p> <p>Bagaimana jika kita ingin server efisien (single thread) tapi menggunakan cara \"Manual\" tanpa library asyncio? Jawabannya adalah I/O Multiplexing.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#92-konsep-select","title":"9.2 Konsep <code>select</code>","text":"<p>Fungsi <code>select()</code> (dari sistem operasi Unix/Windows) bertugas memantau banyak socket sekaligus. Ia akan bertanya pada Kernel OS: \"Hei Kernel, dari 100 socket yang saya punya, mana yang punya data masuk?\" Kernel menjawab: \"Socket No 5 dan Socket No 8 ada data.\" Lalu program kita hanya memproses Socket 5 dan 8. Tidak ada CPU yang terbuang untuk menunggu socket yang kosong.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#93-latihan-chat-server-hemat-resource","title":"9.3 Latihan: Chat Server Hemat Resource","text":"<p>Kita akan membuat Chat Server lagi, tapi kali ini TANPA THREADING. Kita gunakan module <code>select</code>.</p> <p>Algoritma: 1. Buat daftar <code>SOCKET_LIST</code> berisi server socket. 2. Loop selamanya:   *  Panggil <code>select(SOCKET_LIST, ..., ...)</code>   *  <code>select</code> akan memblokir sampai ada SALAH SATU socket yang aktif.   *  Jika server socket aktif -&gt; Berarti ada client baru (<code>accept</code>).   *  Jika client socket aktif -&gt; Berarti ada pesan masuk (<code>recv</code>).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-9","title":"Tugas Mandiri 9","text":"<ol> <li>Jalankan <code>latihan_9_select_server.py</code>.</li> <li>Jalankan beberapa client.</li> <li>Perhatikan bahwa server ini sangat ringan (hanya 1 Thread/Process) tapi bisa menangani banyak chat.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-9","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 9","text":"<p>File: <code>latihan_9_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport threading\n\n# Kita gunakan thread hanya untuk menerima pesan agar input user tidak terganggu\n# Client ini sederhana saja, fokus utama bab ini ada di Server.\n\ndef receive_messages(sock):\n    while True:\n        try:\n            data = sock.recv(1024)\n            if not data: break\n            print(f\"\\n{data.decode()}\\nAnda: \", end=\"\")\n        except:\n            break\n\ndef run_simple_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        client.connect(('localhost', 9000))\n    except:\n        print(\"Gagal connect. Server mati?\")\n        return\n\n    threading.Thread(target=receive_messages, args=(client,), daemon=True).start()\n\n    print(\"Terhubung ke Chat Room! Ketik pesan Anda:\")\n    while True:\n        try:\n            msg = input(\"Anda: \")\n            client.send(msg.encode())\n        except KeyboardInterrupt:\n            break\n\n    client.close()\n\nif __name__ == \"__main__\":\n    run_simple_client()\n</code></pre></p> <p>File: <code>latihan_9_select_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport select\n\ndef run_select_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.bind(('0.0.0.0', 9000))\n    server_socket.listen(10)\n    server_socket.setblocking(False) # Penting! Non-blocking mode\n\n    # Daftar socket yang akan dipantau\n    inputs = [server_socket]\n    clients = {} # Mapping socket -&gt; addr\n\n    print(\"=== Select-based Chat Server on Port 9000 ===\")\n\n    while True:\n        # Panggil select untuk memantau aktivitas I/O\n        # readable = daftar socket yang siap di-READ (ada data masuk)\n        # writable = daftar socket yang siap di-WRITE (buffer kosong)\n        # exceptional = daftar socket yang error\n        readable, writable, exceptional = select.select(inputs, [], inputs)\n\n        for s in readable:\n            if s is server_socket:\n                # Ada koneksi baru\n                conn, addr = s.accept()\n                conn.setblocking(False)\n                inputs.append(conn)\n                clients[conn] = addr\n                print(f\"[NEW] Connection from {addr}\")\n            else:\n                # Ada pesan dari client yang sudah connect\n                try:\n                    data = s.recv(1024)\n                    if data:\n                        # Broadcast ke yang lain\n                        msg = f\"[{clients[s][1]}] {data.decode()}\".encode()\n                        for target in inputs:\n                            if target is not server_socket and target is not s:\n                                try:\n                                    target.send(msg)\n                                except:\n                                    target.close()\n                                    inputs.remove(target)\n                    else:\n                        # Data kosong artinya client close\n                        print(f\"[CLOSE] {clients[s]} disconnected\")\n                        if s in inputs: inputs.remove(s)\n                        s.close()\n                        del clients[s]\n                except Exception as e:\n                    print(f\"Error: {e}\")\n                    if s in inputs: inputs.remove(s)\n                    s.close()\n                    del clients[s]\n\nif __name__ == \"__main__\":\n    run_select_server()\n</code></pre></p> <p>File: <code>latihan_9_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\n\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 9999))\nserver.listen(5)\nprint(\"Server listening on port 9999\")\n\nwhile True:\n    client, addr = server.accept()\n    print(f\"Connection from {addr}\")\n    client.send(b\"Halo dari Server!\")\n    client.close()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-10-protokol-http-web-server","title":"Bab 10: Protokol HTTP &amp; Web Server","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#101-apa-itu-http","title":"10.1 Apa itu HTTP?","text":"<p>HyperText Transfer Protocol (HTTP) adalah protokol aplikasi berbasis teks yang menjadi fondasi World Wide Web (WWW). *  Berjalan di atas TCP (biasanya port 80). *  Model Request-Response: Client (Browser) minta halaman, Server kirim halaman.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#102-struktur-http","title":"10.2 Struktur HTTP","text":"<p>Server web sebenarnya hanyalah socket server biasa yang berbicara bahasa \"HTTP\".</p> <p>Contoh Request (dari Browser): <pre><code>GET /index.html HTTP/1.1\nHost: www.google.com\nUser-Agent: Mozilla/5.0 ...\n</code></pre></p> <p>Contoh Response (dari Server): <pre><code>HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: 50\n\n&lt;html&gt;&lt;body&gt;&lt;h1&gt;Halo Fikom!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#103-latihan-membuat-web-server-sendiri","title":"10.3 Latihan: Membuat Web Server Sendiri","text":"<p>Kita tidak akan menggunakan Apache atau Nginx dulu. Kita akan menulis Web Server dari nol menggunakan Socket Python. Tujuannya agar mahasiswa paham \"magic\" di balik web server.</p> <p>Fitur Web Server kita: 1. Bisa melayani file HTML statis. 2. Bisa menampilkan Gambar. 3. Mengembalikan Error 404 jika file tidak ditemukan.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-10","title":"Tugas Mandiri 10","text":"<ol> <li>Buat file <code>index.html</code> sederhana di folder yang sama.</li> <li>Jalankan <code>latihan_10_web_server.py</code>.</li> <li>Buka Browser, akses <code>http://localhost:8080/index.html</code>.</li> <li>Coba akses file ngawur <code>http://localhost:8080/ngawur.html</code> -&gt; Cek apakah muncul 404.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-10","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 10","text":"<p>File: <code>latihan_10_thread.py</code> <pre><code># Credit: Fikom UIT\nimport threading\nimport time\n\ndef worker(nama):\n    print(f\"Worker {nama} mulai...\")\n    time.sleep(2)\n    print(f\"Worker {nama} selesai.\")\n\nt1 = threading.Thread(target=worker, args=(\"A\",))\nt2 = threading.Thread(target=worker, args=(\"B\",))\n\nt1.start()\nt2.start()\n</code></pre></p> <p>File: <code>latihan_10_web_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport os\n\ndef run_web_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n    print(\"=== Simple Web Server Running on port 8080 ===\")\n    print(\"Akses: http://localhost:8080/index.html\")\n\n    while True:\n        client_sock, addr = server.accept()\n        try:\n            request = client_sock.recv(1024).decode()\n\n            # Parsing baris pertama: \"GET /index.html HTTP/1.1\"\n            headers = request.split('\\n')\n            first_line = headers[0].split()\n\n            if len(first_line) &gt; 1:\n                filename = first_line[1] # misal: \"/index.html\"\n                if filename == '/': filename = '/index.html'\n\n                # Coba baca file\n                # Hilangkan slash depan agar pathnya relatif ke folder ini\n                filepath = filename[1:] \n\n                try:\n                    with open(filepath, 'r') as f:\n                        content = f.read()\n\n                    # HTTP Header\n                    response = \"HTTP/1.1 200 OK\\r\\n\"\n                    response += \"Content-Type: text/html\\r\\n\\r\\n\"\n                    response += content\n\n                except FileNotFoundError:\n                    # 404 Not Found\n                    response = \"HTTP/1.1 404 Not Found\\r\\n\\r\\n\"\n                    response += \"&lt;h1&gt;404 File Tidak Ditemukan&lt;/h1&gt;\"\n\n                client_sock.sendall(response.encode())\n\n        except Exception as e:\n            print(f\"Error {e}\")\n        finally:\n            client_sock.close()\n\nif __name__ == \"__main__\":\n    # Buat file dummy index.html jika belum ada\n    if not os.path.exists('index.html'):\n        with open('index.html', 'w') as f:\n            f.write(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Halo dari Python Web Server!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\")\n\n    run_web_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-11-rest-api-web-services","title":"Bab 11: REST API &amp; Web Services","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#111-evolusi-web","title":"11.1 Evolusi Web","text":"<p>Web 1.0 hanya menampilkan dokumen HTML. Web 2.0 (sekarang) adalah aplikasi yang saling bertukar data. API (Application Programming Interface) adalah jembatan komunikasi antar aplikasi.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#112-arsitektur-rest-representational-state-transfer","title":"11.2 Arsitektur REST (Representational State Transfer)","text":"<p>Gaya arsitektur standar untuk web service. Prinsip utama: Menggunakan HTTP Method sesuai fungsinya.</p> HTTP Method SQL Analog Fungsi GET SELECT Mengambil data POST INSERT Menambah data baru PUT/PATCH UPDATE Mengedit data DELETE DELETE Menghapus data"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#113-library-requests","title":"11.3 Library <code>requests</code>","text":"<p>Python punya library standar <code>urllib</code>, tapi sangat ribet. Komunitas Python membuat standar baru: Requests. (Perlu instalasi: <code>pip install requests</code>)</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#114-latihan-mengonsumsi-public-api","title":"11.4 Latihan: Mengonsumsi Public API","text":"<p>Kita akan membuat program cuaca sederhana yang mengambil data dari Open-Meteo (Gratis, tanpa API Key). URL: <code>https://api.open-meteo.com/v1/forecast?latitude=-6.20&amp;longitude=106.81&amp;current_weather=true</code> (Contoh Jakarta).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-11","title":"Tugas Mandiri 11","text":"<ol> <li>Install requests: <code>pip install requests</code>.</li> <li>Jalankan <code>latihan_11_weather_app.py</code>.</li> <li>Ubah koordinat Latitude/Longitude ke kota lain (cari di Google Maps).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-11","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 11","text":"<p>File: <code>latihan_11_http_get.py</code> <pre><code># Credit: Fikom UIT\nimport requests\n\nresponse = requests.get('https://jsonplaceholder.typicode.com/posts/1')\nprint(f\"Status Code: {response.status_code}\")\nprint(\"Body:\", response.json())\n</code></pre></p> <p>File: <code>latihan_11_weather_app.py</code> <pre><code># Credit: Fikom UIT\nimport requests\nimport json\n\ndef get_weather(lat, lon):\n    url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": lat,\n        \"longitude\": lon,\n        \"current_weather\": \"true\"\n    }\n\n    print(f\"Mengambil data cuaca untuk koordinat {lat}, {lon}...\")\n\n    try:\n        response = requests.get(url, params=params)\n\n        # Cek status code (200 = Success)\n        if response.status_code == 200:\n            data = response.json()\n            cuaca = data['current_weather']\n\n            print(\"\\n--- LAPORAN CUACA TERKINI ---\")\n            print(f\"Suhu        : {cuaca['temperature']} {data['current_weather_units']['temperature']}\")\n            print(f\"Kecepatan Angin: {cuaca['windspeed']} km/h\")\n            print(f\"Waktu Data  : {cuaca['time']}\")\n        else:\n            print(f\"Gagal mengambil data. Status: {response.status_code}\")\n\n    except requests.exceptions.ConnectionError:\n        print(\"Error: Tidak ada koneksi internet.\")\n    except Exception as e:\n        print(f\"Terjadi kesalahan: {e}\")\n\nif __name__ == \"__main__\":\n    # Koordinat Jakarta\n    jkt_lat = -6.2088\n    jkt_lon = 106.8456\n\n    get_weather(jkt_lat, jkt_lon)\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-12-real-time-communication-websocket","title":"Bab 12: Real-time Communication (WebSocket)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#121-keterbatasan-http-untuk-real-time","title":"12.1 Keterbatasan HTTP untuk Real-time","text":"<p>HTTP bersifat Request-Response. Server tidak bisa \"menelpon\" Client duluan. Jika kita ingin membuat dashboard real-time (misal: grafik saham): *  Cara Lama (Polling): Client bertanya \"Ada data baru?\" tiap 1 detik. (Boros bandwidth &amp; latency tinggi). *  Cara Baru (WebSocket): Saluran telepon yang terbuka terus 2 arah. Server bisa kirim data kapan saja.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#122-handshake-protocol","title":"12.2 Handshake Protocol","text":"<p>WebSocket dimulai dengan HTTP biasa. Client mengirim header <code>Upgrade: websocket</code>. Jika Server setuju, koneksi HTTP \"berubah wujud\" menjadi koneksi WebSocket yang persisten (TCP raw).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#123-library-websockets","title":"12.3 Library <code>websockets</code>","text":"<p>Kita perlu library eksternal karena protokol frame WebSocket cukup rumit (berbeda dengan raw socket biasa). <code>pip install websockets</code></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#124-latihan-dashboard-real-time-server-side","title":"12.4 Latihan: Dashboard Real-time (Server Side)","text":"<p>Kita akan membuat server yang mengirim data \"saham dummy\" setiap detik ke semua client yang terhubung.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-12","title":"Tugas Mandiri 12","text":"<ol> <li>Install library: <code>pip install websockets asyncio</code>.</li> <li>Jalankan <code>latihan_12_ws_server.py</code>.</li> <li>Untuk clientnya, kita perlu Browser/HTML+JS (akan dibuat di file terpisah <code>dashboard.html</code>).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-12","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 12","text":"<p>File: <code>latihan_12_async.py</code> <pre><code># Credit: Fikom UIT\nimport asyncio\n\nasync def sapa_async():\n    print(\"Halo...\")\n    await asyncio.sleep(1) # Simulasi I/O wait\n    print(\"...Dunia Async!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(sapa_async())\n</code></pre></p> <p>File: <code>latihan_12_ws_server.py</code> <pre><code># Credit: Fikom UIT\nimport asyncio\nimport websockets\nimport json\nimport random\n\n# Menyimpan semua client yang terhubung\nconnected_clients = set()\n\nasync def handler(websocket):\n    # Register client baru\n    connected_clients.add(websocket)\n    try:\n        print(f\"Client terhubung. Total: {len(connected_clients)}\")\n\n        while True:\n            # Simulasi data real-time\n            data = {\n                \"saham_A\": random.randint(100, 200),\n                \"saham_B\": random.randint(50, 80),\n                \"timestamp\": asyncio.get_event_loop().time()\n            }\n\n            # Kirim ke client ini\n            await websocket.send(json.dumps(data))\n\n            # Delay 1 detik\n            await asyncio.sleep(1)\n\n    except websockets.exceptions.ConnectionClosed:\n        pass\n    finally:\n        connected_clients.remove(websocket)\n        print(f\"Client putus. Total: {len(connected_clients)}\")\n\nasync def main():\n    # Start Websocket Server\n    # Note: perlu pip install websockets\n    try:\n        async with websockets.serve(handler, \"localhost\", 8765):\n            print(\"WS Server running on ws://localhost:8765\")\n            await asyncio.futures.Future() # Run forever\n    except ModuleNotFoundError:\n        print(\"Error: Library 'websockets' belum diinstall.\")\n        print(\"Silakan jalankan: pip install websockets\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-13-keamanan-jaringan-network-security","title":"Bab 13: Keamanan Jaringan (Network Security)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#131-mengapa-perlu-enkripsi","title":"13.1 Mengapa Perlu Enkripsi?","text":"<p>Hingga Bab 12, semua data yang kita kirim lewat socket berbentuk Plaintext. Artinya, jika ada orang iseng di jaringan WiFi yang sama menggunakan aplikasi Packet Sniffer (seperti Wireshark), mereka bisa membaca SEMUA chat, password, dan data sensifitf kita.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#132-konsep-kriptografi","title":"13.2 Konsep Kriptografi","text":"<ol> <li>Symmetric Key: Satu kunci untuk mengunci dan membuka. (Cepat, tapi repot membagikan kuncinya).</li> <li>Asymmetric Key (Public/Private): Kunci publik untuk mengunci, kunci privat untuk membuka. (Lebih lambat, tapi aman).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#133-ssltls-secure-sockets-layer","title":"13.3 SSL/TLS (Secure Sockets Layer)","text":"<p>Protokol standar industri untuk mengamankan koneksi internet (HTTPS). Pada Python, kita bisa membungkus standard socket dengan <code>ssl.wrap_socket</code>. Syarat utama SSL adalah Sertifikat Digital. Untuk latihan, kita akan membuat sertifikat sendiri (Self-Signed Certificate).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#134-latihan-secure-chat","title":"13.4 Latihan: Secure Chat","text":"<p>Kita akan memodifikasi Simple Server agar menggunakan SSL.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#langkah-persiapan-generate-certificate","title":"Langkah Persiapan (Generate Certificate)","text":"<p>Karena kita di Windows dan mungkin tidak ada OpenSSL terinstall, kita akan menggunakan script Python helper untuk generate sertifikat dummy (<code>cert.pem</code> dan <code>key.pem</code>).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-13","title":"Tugas Mandiri 13","text":"<ol> <li>Jalankan <code>latihan_13_gen_cert.py</code> dulu untuk membuat sertifikat.</li> <li>Jalankan <code>latihan_13_secure_server.py</code>.</li> <li>Jalankan <code>latihan_13_secure_client.py</code>.</li> <li>Coba intip trafficnya (kalau bisa pakai Wireshark). Data akan terlihat acak (terenkripsi).</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-13","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 13","text":"<p>File: <code>latihan_13_encrypt.py</code> <pre><code># Credit: Fikom UIT\nfrom cryptography.fernet import Fernet\n\n# Generate key\nkey = Fernet.generate_key()\ncipher = Fernet(key)\n\npesan = b\"Rahasia Negara\"\nencrypted = cipher.encrypt(pesan)\nprint(f\"Encrypted: {encrypted}\")\n\ndecrypted = cipher.decrypt(encrypted)\nprint(f\"Decrypted: {decrypted.decode()}\")\n</code></pre></p> <p>File: <code>latihan_13_gen_cert.py</code> <pre><code># Credit: Fikom UIT\nfrom cryptography import x509\nfrom cryptography.x509.oid import NameOID\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\nimport datetime\n\n# Script bantuan untuk generate cert.pem dan key.pem secara otomatis\n# Membtutuhkan: pip install cryptography\n\ndef generate_self_signed_cert():\n    print(\"Generating RSA Key...\")\n    key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n    )\n\n    print(\"Generating Certificate...\")\n    subject = issuer = x509.Name([\n        x509.NameAttribute(NameOID.COUNTRY_NAME, u\"ID\"),\n        x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u\"Jakarta\"),\n        x509.NameAttribute(NameOID.LOCALITY_NAME, u\"Jakarta\"),\n        x509.NameAttribute(NameOID.ORGANIZATION_NAME, u\"Fikom UIT\"),\n        x509.NameAttribute(NameOID.COMMON_NAME, u\"localhost\"),\n    ])\n\n    cert = x509.CertificateBuilder().subject_name(\n        subject\n    ).issuer_name(\n        issuer\n    ).public_key(\n        key.public_key()\n    ).serial_number(\n        x509.random_serial_number()\n    ).not_valid_before(\n        datetime.datetime.utcnow()\n    ).not_valid_after(\n        # Valid 1 tahun\n        datetime.datetime.utcnow() + datetime.timedelta(days=365)\n    ).add_extension(\n        x509.SubjectAlternativeName([x509.DNSName(u\"localhost\")]),\n        critical=False,\n    ).sign(key, hashes.SHA256())\n\n    # Write Key\n    with open(\"key.pem\", \"wb\") as f:\n        f.write(key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ))\n\n    # Write Cert\n    with open(\"cert.pem\", \"wb\") as f:\n        f.write(cert.public_bytes(serialization.Encoding.PEM))\n\n    print(\"Berhasil membuat 'key.pem' dan 'cert.pem'\")\n\nif __name__ == \"__main__\":\n    try:\n        generate_self_signed_cert()\n    except ImportError:\n        print(\"Error: Library 'cryptography' belum diinstall.\")\n        print(\"Run: pip install cryptography\")\n</code></pre></p> <p>File: <code>latihan_13_secure_client.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport ssl\n\ndef secure_client():\n    # Setup SSL Context untuk client\n    # PROTOCOL_TLS_CLIENT memaksa verifikasi sertifikat server\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\n    # Karena kita pakai Self-Signed Certificate, kita harus mematikan verifikasi hostname &amp; loading CA\n    # ATAU kita load cert kita sendiri sebagai \"Trusted CA\"\n    context.load_verify_locations('cert.pem')\n    # context.check_hostname = False # Opsional jika hostname tidak match\n\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # Wrap socket\n    secure_sock = context.wrap_socket(sock, server_hostname='localhost')\n\n    try:\n        print(\"Connecting securely...\")\n        secure_sock.connect(('localhost', 10023))\n\n        # Cek versi protokol yang dipakai\n        print(f\"Connected with {secure_sock.version()}\")\n\n        secure_sock.send(\"Rahasia Negara Bos!\".encode())\n\n        resp = secure_sock.recv(1024).decode()\n        print(f\"Response: {resp}\")\n\n    except ssl.SSLCertVerificationError:\n        print(\"Error: Sertifikat Server tidak dipercaya!\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        secure_sock.close()\n\nif __name__ == \"__main__\":\n    secure_client()\n</code></pre></p> <p>File: <code>latihan_13_secure_server.py</code> <pre><code># Credit: Fikom UIT\nimport socket\nimport ssl\n\ndef secure_server():\n    # Setup SSL Context\n    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    try:\n        context.load_cert_chain(certfile=\"cert.pem\", keyfile=\"key.pem\")\n    except FileNotFoundError:\n        print(\"Sertifikat belum ada! Jalankan latihan_13_gen_cert.py dulu.\")\n        return\n\n    bindsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    bindsocket.bind(('localhost', 10023))\n    bindsocket.listen(5)\n    print(\"=== Secure TLS Server Listening on 10023 ===\")\n\n    # Wrap socket biasa dengan SSL\n    # server_side=True artinya socket ini berperan sebagai server\n    with context.wrap_socket(bindsocket, server_side=True) as ssock:\n        while True:\n            try:\n                conn, addr = ssock.accept()\n                print(f\"Secure connection from {addr}\")\n\n                data = conn.recv(1024).decode()\n                print(f\"Received: {data}\")\n\n                conn.send(f\"Server Says: Validated &amp; Encrypted!\".encode())\n                conn.close()\n            except Exception as e:\n                print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    secure_server()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-14-arsitektur-sistem-terdistribusi-iot","title":"Bab 14: Arsitektur Sistem Terdistribusi &amp; IoT","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#141-dari-client-server-ke-distributed-system","title":"14.1 Dari Client-Server ke Distributed System","text":"<p>Sampai saat ini kita menggunakan model Request-Response (1-on-1). Dalam sistem IoT (Internet of Things) dengan ribuan sensor, model ini tidak efisien karena Server harus menjaga ribuan koneksi terbuka secara bersamaan.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#142-pola-publish-subscribe-pubsub","title":"14.2 Pola Publish-Subscribe (Pub/Sub)","text":"<p>Solusinya adalah memisahkan pengirim (Publisher) dan penerima (Subscriber) menggunakan perantara yang disebut Broker. *  Publisher: Mengirim pesan ke topik tertentu (misal: \"rumah/ruang_tamu/suhu\"). *  Subscriber: Berlangganan topik tersebut. *  Broker: Meneruskan pesan dari Publisher ke SEMUA Subscriber yang relevan.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#143-protokol-mqtt","title":"14.3 Protokol MQTT","text":"<p>MQTT (Message Queuing Telemetry Transport) adalah protokol standar IoT yang sangat ringan berbasis TCP/IP. Kelebihan: 1. Hemat Bandwidth (Header cuma 2 byte!). 2. Hemat Baterai (cocok untuk Arduino/ESP32). 3. QoS (Quality of Service): Level 0 (fire-forget), 1 (at least once), 2 (exactly once).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#144-latihan-simulasi-smart-home-mqtt","title":"14.4 Latihan: Simulasi Smart Home (MQTT)","text":"<p>Kita butuh MQTT Broker publik untuk latihan ini, misal <code>test.mosquitto.org</code> atau <code>broker.hivemq.com</code>. Library Python: <code>paho-mqtt</code> (<code>pip install paho-mqtt</code>).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#skenario","title":"Skenario","text":"<ol> <li>Script Sensor (Publisher): Mengirim data suhu tiap detik ke topik <code>fikom/iot/suhu</code>.</li> <li>Script Dashboard (Subscriber): Menunggu data di topik <code>fikom/iot/suhu</code> dan menampilkannya.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#tugas-mandiri-14","title":"Tugas Mandiri 14","text":"<ol> <li>Install library: <code>pip install paho-mqtt</code>.</li> <li>Jalankan <code>latihan_14_mqtt_sub.py</code> (Monitor).</li> <li>Jalankan <code>latihan_14_mqtt_pub.py</code> (Sensor).</li> <li>Lihat bagaimana data mengalir melalui Broker publik di internet.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-14","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 14","text":"<p>File: <code>latihan_14_api.py</code> <pre><code># Credit: Fikom UIT\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return {\"message\": \"Halo, ini API Fikom UIT\"}\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre></p> <p>File: <code>latihan_14_mqtt_pub.py</code> <pre><code># Credit: Fikom UIT\nimport paho.mqtt.client as mqtt\nimport time\nimport random\n\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC = \"fikom/iot/suhu\"\n\ndef run_publisher():\n    client = mqtt.Client()\n\n    print(f\"Menghubungkan ke {BROKER}...\")\n    client.connect(BROKER, PORT, 60)\n\n    try:\n        while True:\n            # Simulasi Data\n            suhu = random.randint(20, 35)\n            payload = f\"{suhu} C\"\n\n            client.publish(TOPIC, payload)\n            print(f\"Published to {TOPIC}: {payload}\")\n\n            time.sleep(2)\n\n    except KeyboardInterrupt:\n        print(\"Stopped.\")\n    finally:\n        client.disconnect()\n\nif __name__ == \"__main__\":\n    run_publisher()\n</code></pre></p> <p>File: <code>latihan_14_mqtt_sub.py</code> <pre><code># Credit: Fikom UIT\nimport paho.mqtt.client as mqtt\n\n# Broker Publik Gratisan\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC = \"fikom/iot/suhu\"\n\ndef on_connect(client, userdata, flags, rc):\n    print(f\"Terhubung ke Broker! (Code: {rc})\")\n    # Langsung subscribe saat koneksi jadi\n    client.subscribe(TOPIC)\n    print(f\"Subscribed to {TOPIC}\")\n\ndef on_message(client, userdata, msg):\n    print(f\"[DATA MASUK] {msg.topic}: {msg.payload.decode()}\")\n\ndef run_subscriber():\n    client = mqtt.Client()\n    client.on_connect = on_connect\n    client.on_message = on_message\n\n    print(f\"Menghubungkan ke {BROKER}...\")\n    try:\n        client.connect(BROKER, PORT, 60)\n        # Loop forever (blocking) untuk menangani network events\n        client.loop_forever()\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    run_subscriber()\n</code></pre></p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#bab-15-panduan-final-project-pjbl","title":"Bab 15: Panduan Final Project (PjBL)","text":""},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#151-deskripsi-tugas-akhir","title":"15.1 Deskripsi Tugas Akhir","text":"<p>Untuk menyelesaikan mata kuliah Pemrograman Jaringan, mahasiswa diwajibkan membuat proyek akhir secara berkelompok (3-4 orang). Tujuan proyek ini adalah mengintegrasikan semua materi yang telah dipelajari (TCP/UDP, Threading, Database/JSON, Security).</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#152-pilihan-topik-project","title":"15.2 Pilihan Topik Project","text":"<p>Pilih salah satu dari topik berikut atau ajukan ide Anda sendiri kepada Dosen.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#opsi-a-aplikasi-chat-room-whatsapp-kw","title":"Opsi A: Aplikasi Chat Room \"WhatsApp KW\"","text":"<ul> <li>Fitur Wajib:</li> <li>Login dengan Username &amp; Password (Database sederhana).</li> <li>One-on-One Chat &amp; Group Chat.</li> <li>Kirim File (Gambar/Dokumen).</li> <li>Enkripsi End-to-End sederhana (XOR atau AES).</li> <li>Teknologi: TCP Socket, Threading, JSON, Tkinter/PyQt (GUI).</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#opsi-b-sistem-monitoring-server-jarak-jauh","title":"Opsi B: Sistem Monitoring Server Jarak Jauh","text":"<ul> <li>Fitur Wajib:</li> <li>Agent (Client): Dipasang di PC target, membaca CPU Usage, RAM, dan Disk Space lalu kirim ke Server.</li> <li>Dashboard (Server): Menampilkan grafik status PC target secara real-time.</li> <li>Alert: Kirim notifikasi (Email/Telegram Bot) jika CPU &gt; 90%.</li> <li>Teknologi: UDP (untuk data stream), HTTP/WebSocket (untuk dashboard), Psutil.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#opsi-c-multiplayer-game-lan-sederhana","title":"Opsi C: Multiplayer Game LAN Sederhana","text":"<ul> <li>Fitur Wajib:</li> <li>Game sederhana (Pong, Snake, atau Tic-Tac-Toe).</li> <li>Lobby System (Create Room / Join Room).</li> <li>Sinkronisasi gerakan player real-time.</li> <li>Teknologi: UDP (untuk gerakan), TCP (untuk lobby), Pygame.</li> </ul>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#153-kriteria-penilaian","title":"15.3 Kriteria Penilaian","text":"<ol> <li>Fungsionalitas (40%): Apakah semua fitur berjalan tanpa error?</li> <li>Kode Program (30%): Kerapian kode, komentar, struktur Modular/OOP, error handling.</li> <li>UI/UX (10%): Kemudahan penggunaan (CLI rapi atau GUI menarik).</li> <li>Presentasi (20%): Demo live dan kemampuan menjawab pertanyaan.</li> </ol>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#154-timeline-pengerjaan","title":"15.4 Timeline Pengerjaan","text":"<ul> <li>Minggu 14: Pembentukan Tim &amp; Pengajuan Judul (Proposal 1 Halaman).</li> <li>Minggu 15: Development Phase.</li> <li>Minggu 16: Final Presentation (UAS).</li> </ul> <p>Selamat berkarya! Gunakan ilmu ini untuk membangun solusi nyata.</p>"},{"location":"Buku_Ajar_Pemrograman_Jaringan_Lengkap/#lampiran-kode-praktikum-bab-15","title":"\ud83d\udcce Lampiran Kode Praktikum Bab 15","text":"<p>File: <code>latihan_15_project_starter.py</code> <pre><code># Credit: Fikom UIT\nimport psutil\nimport time\nimport socket\nimport json\n\n# Contoh Kode untuk Opsi B (Monitoring Agent)\n# Mengirim data CPU/RAM ke Server Monitoring\n\nSERVER_IP = 'localhost'\nSERVER_PORT = 5555\n\ndef start_agent():\n    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    print(f\"Monitoring Agent Started. Sending data to {SERVER_IP}:{SERVER_PORT}\")\n\n    try:\n        while True:\n            # Ambil metrics system\n            cpu = psutil.cpu_percent(interval=1)\n            ram = psutil.virtual_memory().percent\n            disk = psutil.disk_usage('/').percent\n\n            data = {\n                \"hostname\": socket.gethostname(),\n                \"cpu\": cpu,\n                \"ram\": ram,\n                \"disk\": disk\n            }\n\n            # Kirim via UDP (karena data stream cepat)\n            msg = json.dumps(data)\n            client.sendto(msg.encode(), (SERVER_IP, SERVER_PORT))\n\n            print(f\"Sent: {msg}\")\n\n    except KeyboardInterrupt:\n        print(\"Agent Stopped.\")\n\nif __name__ == \"__main__\":\n    # pip install psutil\n    try:\n        start_agent()\n    except ImportError:\n        print(\"Module 'psutil' not found. Install: pip install psutil\")\n</code></pre></p> <p>File: <code>latihan_15_script.py</code> <pre><code># Credit: Fikom UIT\nimport sys\nprint(f\"Script Python dijalankan dari: {sys.executable}\")\nprint(\"Integrasi Berhasil!\")\n</code></pre></p>"},{"location":"Bab_1/Naskah_Bab_1/","title":"Bab 1 (Konsep Dasar)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#bab-1-konsep-dasar-pemrograman-jaringan","title":"Bab 1: Konsep Dasar Pemrograman Jaringan","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan arsitektur protokol jaringan (Model OSI dan TCP/IP) dan relevansinya dalam pengembangan aplikasi. 2.  Mengidentifikasi komponen vital komunikasi jaringan: IP Address, Port, dan Socket. 3.  Mendemonstrasikan penggunaan library dasar Python untuk diagnosa informasi jaringan lokal.</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#11-pendahuluan","title":"1.1 Pendahuluan","text":"<p>Pemrograman Jaringan (Network Programming) adalah seni menulis perangkat lunak yang memungkinkan proses-proses komputer yang berbeda untuk berkomunikasi satu sama lain melalui jaringan. Materi ini akan menjadi fondasi bagi Anda untuk memahami bagaimana internet bekerja, mulai dari aplikasi chat sederhana hingga sistem skala besar yang terdistribusi (Distributed Systems).</p> <p>Analogi di Dunia Nyata: Bayangkan Anda mengirim paket belanja online. *   Aplikasi (Shopee/Tokopedia): Adalah program yang Anda buat. *   Jasa Ekspedisi (JNE/J&amp;T): Adalah Jaringan Komputer yang mengurus pengantaran tanpa Anda perlu tahu detail rute truknya. Tugas kita sebagai Network Programmer adalah memastikan paket (data) diserahkan ke kurir dengan alamat yang benar dan dikemas dengan aman.</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#12-model-referensi-komunikasi","title":"1.2 Model Referensi Komunikasi","text":"<p>Dalam dunia industri IT (terutama bagi Network Engineer dan SysAdmin), pemahaman layer sangat vital untuk troubleshooting. Jika website down, apakah masalah di kabel (Physical), IP conflict (Network), atau kode program error (Application)?</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram Perbandingan Side-by-Side antara Model OSI 7 Layer dan TCP/IP 4 Layer]</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#a-model-osi-7-layer","title":"a. Model OSI (7 Layer)","text":"<p>Model konseptual yang membagi komunikasi jaringan menjadi 7 lapisan: 1.  Physical: Media transmisi (Kabel LAN, Fiber Optic, Sinyal WiFi). 2.  Data Link: Identitas perangkat keras (MAC Address), Switching. 3.  Network: Pengalamatan logis (IP Address), Routing antar jaringan. 4.  Transport: Pengiriman data reliabel vs cepat (TCP/UDP), Port numbers. 5.  Session: Manajemen sesi komunikasi. 6.  Presentation: Format data (Enkripsi SSL/TLS, Kompresi). 7.  Application: Protokol yang langsung berinteraksi dengan user (HTTP, DNS, FTP).</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#b-model-tcpip-4-layer","title":"b. Model TCP/IP (4 Layer)","text":"<p>Model yang lebih praktis dan menjadi standar Internet saat ini: 1.  Network Access: Gabungan Physical &amp; Data Link. 2.  Internet: Setara Network (IP). 3.  Transport: TCP &amp; UDP. 4.  Application: Gabungan Session, Presentation, &amp; Application.</p> <p>Fokus Mata Kuliah ini ada di Layer Transport (Socket Programming) dan Layer Application.</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#13-entitas-jaringan-ip-port-dan-socket","title":"1.3 Entitas Jaringan: IP, Port, dan Socket","text":"<p>Untuk membuat aplikasi jaringan, kita memerlukan \"Alamat Tujuan\" dan \"Pintu Masuk\".</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Socket sebagai kombinasi IP Address dan Port Number pada dua komputer yang terhubung]</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#1-ip-address-alamat-gedung","title":"1. IP Address (Alamat Gedung)","text":"<p>Alamat unik yang mengidentifikasi host/komputer di jaringan. *   IPv4: <code>192.168.1.1</code> (Format umum saat ini). *   Localhost: <code>127.0.0.1</code> (Alamat loopback, ibarat bicara pada diri sendiri). Penting untuk testing aplikasi tanpa internet.</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#2-port-number-nomor-ruanganekstensi","title":"2. Port Number (Nomor Ruangan/Ekstensi)","text":"<p>Angka 16-bit (0-65535) yang membedakan layanan/aplikasi dalam satu komputer. Satu komputer bisa menjalankan Web Server (Port 80) dan Database (Port 3306) sekaligus. *   Well-known Ports (0-1023): Direservasi sistem (HTTP=80, HTTPS=443, SSH=22). Jangan gunakan ini untuk aplikasi latihan Anda kecuali Anda punya akses Administrator. *   Registered/Dynamic Ports (1024+): Aman digunakan untuk aplikasi buatan kita (misal: 5000, 8080, 12345).</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#3-socket-wadah-komunikasi","title":"3. Socket (Wadah Komunikasi)","text":"<p>Titik akhir (endpoint) komunikasi dua arah. Rumus: <code>Socket = IP Address + Port Number</code></p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#14-persiapan-environment","title":"1.4 Persiapan Environment","text":"<p>Kita akan menggunakan Python 3 karena pustaka jaringannya (<code>socket</code>) adalah standar industri dan cross-platform (bisa jalan di Windows/Linux/Mac). IDE yang disarankan: Visual Studio Code atau PyCharm.</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#cek-instalasi","title":"Cek Instalasi","text":"<p>Pastikan Python terinstal dan terbaca di terminal: <pre><code>python --version\n# Hubungkan perangkat ke WiFi/LAN agar mendapat IP Address yang valid.\n</code></pre></p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#15-latihan-cek-identitas-jaringan-network-diagnostic","title":"1.5 Latihan: Cek Identitas Jaringan (Network Diagnostic)","text":"<p>Mari kita buat alat diagnosa sederhana. Script ini berguna saat Anda mendeploy aplikasi ke Server Cloud (AWS/GCP) untuk memastikan aplikasi berjalan di Hostname yang benar.</p> <p>Buka file <code>latihan_1_net_check.py</code>.</p> <pre><code>import socket\n\ndef check_net_info():\n    print(\"=== Network Information Tool ===\")\n    try:\n        # 1. Mengambil Hostname (Nama Komputer)\n        # Bermanfaat untuk log file agar tahu server mana yang memproses request\n        hostname = socket.gethostname()\n\n        # 2. Mengambil IP Address Lokal\n        # Fungsi ini melakukan resolusi DNS lokal\n        ip_address = socket.gethostbyname(hostname)\n\n        print(f\"Hostname  : {hostname}\")\n        print(f\"IP Address: {ip_address}\")\n\n    except socket.error as e:\n        # Best Practice: Selalu tangani potensi error jaringan\n        print(f\"Gagal mengambil informasi jaringan: {e}\")\n\nif __name__ == \"__main__\":\n    check_net_info()\n</code></pre>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#analisis-kode","title":"Analisis Kode","text":"<ul> <li><code>import socket</code>: Mengimpor modul inti Python untuk komunikasi jaringan.</li> <li><code>socket.gethostname()</code>: Meminta OS memberitahu nama komputer saat ini.</li> <li><code>socket.gethostbyname()</code>: Menerjemahkan nama komputer menjadi alamat IP.</li> </ul>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#troubleshooting-common-issues","title":"Troubleshooting (Common Issues)","text":"<ul> <li>Output IP <code>127.0.0.1</code>: Ini berarti komputer tidak terhubung ke jaringan eksternal/WiFi, atau file <code>/etc/hosts</code> (di Linux/Mac) memetakan hostname ke localhost.</li> <li>VPN Aktif: Kadang IP yang muncul adalah IP Virtual dari VPN, bukan IP fisik LAN.</li> </ul>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_1/Naskah_Bab_1/#16-tugas-mandiri-problem-solving","title":"1.6 Tugas Mandiri (Problem Solving)","text":"<p>Kerjakan tugas berikut untuk menguji pemahaman Anda:</p> <ol> <li> <p>Verifikasi Manual: Jalankan script di atas, lalu bandingkan hasilnya dengan perintah asli OS:</p> <ul> <li>Windows: Buka CMD, ketik <code>ipconfig</code>.</li> <li>Linux/Mac: Buka Terminal, ketik <code>ip addr</code> atau <code>ifconfig</code>.</li> <li>Analisis: Apakah IP-nya sama? Jika berbeda, mengapa? (Petunjuk: Sebuah komputer bisa memiliki banyak Network Interface Card/NIC).</li> </ul> </li> <li> <p>DNS Lookup Sederhana: Modifikasi kode di atas agar tidak mengecek hostname sendiri, melainkan mengecek IP dari website terkenal (misal: <code>google.com</code> atau <code>mikrotik.co.id</code>).</p> <ul> <li>Hint: Ganti parameter <code>hostname</code> pada fungsi <code>gethostbyname()</code> dengan string domain.</li> </ul> </li> </ol> <p>Navigasi: 00_Pengantar | [[00_Dashboard]] | Naskah_Bab_2</p>","tags":["KonsepJaringan","OSIModel","TCPIP","SocketBasics","PemrogramanJaringan","Python","Bab1"]},{"location":"Bab_10/Naskah_Bab_10/","title":"Bab 10 (HTTP Server)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#bab-10-protokol-http-web-server","title":"Bab 10: Protokol HTTP &amp; Web Server","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menguraikan struktur paket HTTP (Header, Body, Status Code, Methods) secara mendetail. 2.  Mendemonstrasikan cara kerja Request-Response Cycle di balik setiap interaksi web. 3.  Membangun Web Server sederhana dari nol (from scratch) menggunakan TCP Socket yang mampu melayani file statis. 4.  Mendiagnosa kode status HTTP (200, 404, 500) dan implikasinya terhadap pengalaman pengguna.</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#101-pendahuluan-bahasa-internet","title":"10.1 Pendahuluan: Bahasa Internet","text":"<p>Jika TCP/IP adalah jalan raya, maka HTTP (Hypertext Transfer Protocol) adalah bahasa yang digunakan truk-truk pengangkut barang di jalan raya tersebut. Ini adalah protokol yang memungkinkan Anda membaca teks ini di browser sekarang.</p> <p>Banyak Web Developer modern menggunakan framework seperti Django, Flask, atau Node.js dan lupa apa yang terjadi di belakang layar. Sebagai Network Programmer, kita akan membongkar kotak hitam tersebut dan melihat roda gigi yang berputar di dalamnya.</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#102-analogi-memesan-makanan-di-restoran","title":"10.2 Analogi: Memesan Makanan di Restoran","text":"<p>HTTP bekerja dengan model Request-Response. Mari kita bayangkan Restoran:</p> <ol> <li>Client (Pelanggan): Anda duduk dan melihat buku menu (Browser).</li> <li>Server (Dapur): Tempat makanan dibuat/disimpan.</li> <li>HTTP Request (Pesanan): Anda memanggil pelayan dan berkata: \"Tolong bawakan Nasi Goreng (URL) satu porsi (GET).\"</li> <li>Proses: Pelayan ke dapur. Dapur mengecek bahan.</li> <li>HTTP Response (Sajian):<ul> <li>Status 200 OK: Pelayan datang membawa Nasi Goreng. Selamat menikmati!</li> <li>Status 404 Not Found: Pelayan datang dengan tangan kosong: \"Maaf mas, Nasi Goreng habis.\"</li> <li>Status 500 Internal Error: Dapur kebakaran. Tidak ada yang bisa dilayani.</li> </ul> </li> </ol> <p>Poin Penting: Stateless. HTTP itu pelupa. Setelah pelayan mengantar makanan, dia lupa siapa Anda. Jika Anda mau pesan minum, Anda harus memanggil dan memperkenalkan diri ulang (kecuali pakai Cookies - materi lanjutan).</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#103-anatomi-paket-http","title":"10.3 Anatomi Paket HTTP","text":"<p>Web Server sebenarnya hanyalah Socket Server (Bab 2) yang memanipulasi teks dengan format tertentu.</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#a-http-request-apa-yang-browser-kirim","title":"A. HTTP Request (Apa yang Browser Kirim)","text":"<p>Saat Anda mengetik <code>google.com</code>, browser mengirim teks ini ke server Google:</p> <pre><code>GET /index.html HTTP/1.1\nHost: www.google.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)\nAccept: text/html,application/xhtml+xml\n[Baris Kosong]\n[Body Kosong untuk GET]\n</code></pre> <ul> <li>Baris 1 (Request Line): <code>METODE PATH VERSI</code>.<ul> <li><code>GET</code>: Minta data.</li> <li><code>POST</code>: Kirim data (misal login form).</li> </ul> </li> <li>Headers: Metadata tentang siapa saya (User-Agent) dan apa yang saya bisa baca (Accept).</li> </ul>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#b-http-response-jawaban-server","title":"B. HTTP Response (jawaban Server)","text":"<p>Server membalas dengan format yang mirip:</p> <pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2026 12:28:53 GMT\nServer: Apache/2.4.1 (Unix)\nContent-Length: 154\nContent-Type: text/html\n\n&lt;html&gt;\n  &lt;head&gt;&lt;title&gt;Halo!&lt;/title&gt;&lt;/head&gt;\n  &lt;body&gt;&lt;h1&gt;Ini Website Saya&lt;/h1&gt;&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>Baris 1 (Status Line): <code>VERSI KODE PESAN</code>.</li> <li>Headers: Penting! <code>Content-Type</code> memberitahu browser apakah ini teks HTML, gambar JPG, atau video MP4.</li> <li>Body: Isi konten sesungguhnya.</li> </ul> <p>[Saran: Tambahkan Gambar/Diagram disini: Bedah anatomi Request vs Response side-by-side]</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#104-praktikum-membangun-web-server-dari-nol","title":"10.4 Praktikum: Membangun Web Server dari Nol","text":"<p>Kita akan membuat Web Server tanpa install Apache/Nginx. Kita gunakan Python murni. Server ini nanti bisa Anda akses lewat Chrome/Edge.</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#logika-server","title":"Logika Server","text":"<ol> <li>Buat Server Socket (TCP), listen di port 8080.</li> <li><code>accept</code> koneksi browser.</li> <li><code>recv</code> request dari browser (masih bytes). Decode ke string.</li> <li>Parsing: Ambil kata kedua dari baris pertama request. Itu adalah Nama File yang diminta (misal <code>/index.html</code>).</li> <li>File Handling:<ul> <li>Coba buka file tersebut dari harddisk.</li> <li>Jika ada: Baca isinya, kirim Header <code>200 OK</code>, lalu kirim isi file.</li> <li>Jika tidak ada: Kirim Header <code>404 Not Found</code>, lalu kirim halaman error HTML.</li> </ul> </li> </ol>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#implementasi-kode-latihan_10_web_serverpy","title":"Implementasi Kode (<code>latihan_10_web_server.py</code>)","text":"<pre><code>import socket\n\ndef handle_client(client_socket):\n    # 1. Terima Request Browser\n    request = client_socket.recv(1024).decode('utf-8')\n\n    # Validasi: Kadang browser kirim koneksi kosong\n    if not request:\n        client_socket.close()\n        return\n\n    # 2. Parsing Request Line untuk cari nama file\n    # Request: \"GET /index.html HTTP/1.1 ...\"\n    headers = request.split('\\n')\n    first_line = headers[0]\n\n    try:\n        # Ambil bagian path: \"/index.html\"\n        filename = first_line.split()[1]\n    except IndexError:\n        client_socket.close()\n        return\n\n    # Ubah \"/\" jadi \"/index.html\" (Default Page)\n    if filename == '/':\n        filename = '/index.html'\n\n    # Hapus slash depan agar bisa dibaca os.path. \" /index.html\" -&gt; \"index.html\"\n    filepath = filename.lstrip('/')\n\n    try:\n        # 3. Coba Buka File\n        # Mode 'rb' (Read Binary) penting agar bisa baca Gambar juga\n        with open(filepath, 'rb') as f:\n            content = f.read()\n\n        # 4. Susun Response SUKSES (200 OK)\n        response_header = \"HTTP/1.1 200 OK\\r\\n\"\n\n        # Deteksi Content-Type sederhana\n        if filepath.endswith(\".html\"):\n            mime_type = \"text/html\"\n        elif filepath.endswith(\".jpg\") or filepath.endswith(\".png\"):\n            mime_type = \"image/jpeg\"\n        else:\n            mime_type = \"text/plain\"\n\n        response_header += f\"Content-Type: {mime_type}\\r\\n\"\n        response_header += f\"Content-Length: {len(content)}\\r\\n\"\n        response_header += \"Connection: close\\r\\n\\r\\n\" # Header ditutup dengan dua enter (\\r\\n\\r\\n)\n\n        # Kirim Header + Body\n        client_socket.send(response_header.encode('utf-8') + content)\n        print(f\"[200] Mengirim {filepath}\")\n\n    except FileNotFoundError:\n        # 5. Handle Error 404\n        error_content = \"&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;p&gt;File tidak ditemukan di Server.&lt;/p&gt;\"\n\n        response_header = \"HTTP/1.1 404 Not Found\\r\\n\"\n        response_header += \"Content-Type: text/html\\r\\n\"\n        response_header += f\"Content-Length: {len(error_content)}\\r\\n\"\n        response_header += \"Connection: close\\r\\n\\r\\n\"\n\n        client_socket.send(response_header.encode('utf-8') + error_content.encode('utf-8'))\n        print(f\"[404] File {filepath} tidak ada\")\n\n    client_socket.close()\n\ndef run_web_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(5)\n    print(\"=== Python Web Server Berjalan di http://localhost:8080 ===\")\n\n    while True:\n        client, addr = server.accept()\n        handle_client(client)\n\nif __name__ == \"__main__\":\n    run_web_server()\n</code></pre>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#105-konteks-industri-mengapa-tidak-pakai-ini-di-production","title":"10.5 Konteks Industri: Mengapa Tidak Pakai Ini di Production?","text":"<p>Server di atas disebut Single-Threaded Blocking Web Server. *   Masalah: Jika ada user dengan koneksi lambat sedang mendownload gambar besar, server akan freeze. User lain tidak bisa akses. *   Solusi Production: Di dunia nyata, kita menggunakan Gunicorn atau Nginx yang mengimplementasikan Asyncio (Bab 8) atau Multiplexing (Bab 9) untuk menangani ribuan request per detik. Namun, logika parsing HTTP-nya tetap sama dengan yang kita tulis di atas.</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_10/Naskah_Bab_10/#106-tugas-mandiri-web-developer-ops","title":"10.6 Tugas Mandiri (Web Developer Ops)","text":"<ol> <li>Halaman Statis: Buat file <code>index.html</code> dan <code>about.html</code> dengan konten HTML cantik (CSS inline). Pastikan server bisa menyajikannya.</li> <li>Serving Image: Taruh sebuah file gambar <code>foto.jpg</code> di folder yang sama. Akses <code>http://localhost:8080/foto.jpg</code>. Jika gambar muncul tapi rusak (corrupt), cek apakah Anda sudah membukanya dengan mode <code>rb</code> (read binary) dan Content-Type-nya benar?</li> <li>Logs: Modifikasi server agar mencatat setiap request ke file <code>server.log</code> dengan format: <code>[JAMES-TIME] IP-ADDRESS REQUEST-FILE STATUS-CODE</code>. Ini adalah cikal bakal Access Log yang biasa dibaca SysAdmin.</li> </ol> <p>Navigasi: Naskah_Bab_9 | [[00_Dashboard]] | Naskah_Bab_11</p>","tags":["HTTPProtocol","WebServer","RequestResponse","SocketServer","PemrogramanJaringan","Python","Bab10"]},{"location":"Bab_11/Naskah_Bab_11/","title":"Bab 11 (REST API)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#bab-11-rest-api-web-services","title":"Bab 11: REST API &amp; Web Services","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan konsep dasar Web Service dan arsitektur REST (Representational State Transfer). 2.  Memetakan metode HTTP (GET, POST, PUT, DELETE) ke dalam operasi database CRUD (Create, Read, Update, Delete). 3.  Mengimplementasikan aplikasi client yang mengonsumsi Public API menggunakan pustaka <code>requests</code>. 4.  Menganalisis struktur data JSON yang diterima dari penyedia layanan pihak ketiga.</p>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#111-pendahuluan-saat-mesin-bicara-dengan-mesin","title":"11.1 Pendahuluan: Saat Mesin Bicara dengan Mesin","text":"<p>Di Bab 10, kita mengakses web menggunakan Browser. Itu adalah komunikasi Human-to-Machine. Tapi di era digital ini, mayoritas komunikasi internet adalah Machine-to-Machine.</p> <p>Contoh nyata: *   Saat Anda memesan GoJek, aplikasi GoJek \"bertanya\" ke Google Maps API: \"Berapa jarak dari rumah saya ke kampus?\" *   Saat Anda login Instagram pakai Facebook, Instagram \"bertanya\" ke Facebook API: \"Apakah user ini valid?\"</p> <p>Jembatan komunikasi inilah yang disebut API (Application Programming Interface).</p>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#112-arsitektur-rest-standar-bahasa-universal","title":"11.2 Arsitektur REST: Standar Bahasa Universal","text":"<p>REST (Representational State Transfer) bukan protokol, melainkan gaya arsitektur. Bayangkan REST sebagai \"Menu Restoran yang Terstandarisasi\" di seluruh dunia.</p> <p>Analogi Bahasa Kerja: Jika Anda seorang pelayan (Server), Anda akan bingung jika setiap tamu punya cara pesan berbeda. *   Tamu A: \"Saya mau makan.\" *   Tamu B: \"Berikan saya asupan nutrisi.\" *   Tamu C: \"Muat makanan ke meja 5.\"</p> <p>REST menetapkan aturan baku: \"Gunakan KATA KERJA yang sama untuk benda yang berbeda.\"</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram alur Client (Mobile App) -&gt; HTTP Request (REST) -&gt; Server Backend -&gt; Database]</p>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#113-pemetaan-http-methods-crud","title":"11.3 Pemetaan HTTP Methods (CRUD)","text":"<p>Dalam REST, kita menggunakan Metode HTTP (yang kita pelajari di Bab 10) untuk mewakili aksi terhadap data.</p> HTTP Method Analogi SQL Fungsi Bisnis Contoh Endpoint GET <code>SELECT</code> Read: Mengambil data <code>/mahasiswa/101</code> (Ambil data mhs nim 101) POST <code>INSERT</code> Create: Menambah data baru <code>/mahasiswa</code> (Tambah mhs baru) PUT/PATCH <code>UPDATE</code> Update: Mengubah data <code>/mahasiswa/101</code> (Ganti nama mhs 101) DELETE <code>DELETE</code> Delete: Menghapus data <code>/mahasiswa/101</code> (Hapus mhs 101)","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#114-pustaka-requests-http-for-humanstm","title":"11.4 Pustaka <code>requests</code>: HTTP for Humans\u2122","text":"<p>Python memiliki modul bawaan <code>urllib</code>, tapi sintaksnya sangat primitif dan rumit (mirip Socket). Oleh karena itu, komunitas Python menciptakan <code>requests</code>. Library ini begitu populer karena kemudahannya, sampai-sampai slogannya adalah \"HTTP for Humans\".</p> <p>Catatan Instalasi: Library ini bukan bawaan standar Python. Anda harus menginstallnya via terminal: <code>pip install requests</code></p>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#115-praktikum-membuat-aplikasi-cuaca","title":"11.5 Praktikum: Membuat Aplikasi Cuaca","text":"<p>Kita akan membuat aplikasi console yang mirip widget cuaca di HP Anda. Kita akan \"meminjam\" data dari Open-Meteo, sebuah penyedia API cuaca gratis yang tidak memerlukan pendaftaran kunci (API Key).</p> <ol> <li>Endpoint: <code>https://api.open-meteo.com/v1/forecast</code></li> <li>Parameter: <code>latitude</code>, <code>longitude</code>, <code>current_weather=true</code>.</li> </ol>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#kode-implementasi-latihan_11_weather_apppy","title":"Kode Implementasi (<code>latihan_11_weather_app.py</code>)","text":"<pre><code>import requests\nimport sys\n\ndef get_weather(city_name, lat, lon):\n    print(f\"\\n--- Mengambil Data Cuaca untuk {city_name} ---\")\n\n    # 1. Definisikan URL dan Parameter\n    base_url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        'latitude': lat,\n        'longitude': lon,\n        'current_weather': 'true',\n        'timezone': 'auto' # Agar jam sesuai lokasi\n    }\n\n    try:\n        # 2. Kirim Request GET\n        # requests.get otomatis menyusun query string (?lat=...&amp;lon=...)\n        response = requests.get(base_url, params=params)\n\n        # 3. Cek Status Code\n        if response.status_code == 200:\n            # 4. Parsing JSON\n            data = response.json()\n\n            # Ambil bagian yang penting saja\n            current = data['current_weather']\n            suhu = current['temperature']\n            kecepatan_angin = current['windspeed']\n\n            print(f\"\ud83c\udf21\ufe0f  Suhu Saat Ini: {suhu}\u00b0C\")\n            print(f\"\ud83d\udca8 Kecepatan Angin: {kecepatan_angin} km/h\")\n            print(f\"\ud83c\udf0d Koordinat: {lat}, {lon}\")\n\n        else:\n            print(f\"[ERROR] Gagal mengambil data. Status: {response.status_code}\")\n\n    except requests.exceptions.ConnectionError:\n        print(\"[ERROR] Tidak ada koneksi internet!\")\n    except Exception as e:\n        print(f\"[ERROR] Terjadi kesalahan: {e}\")\n\nif __name__ == \"__main__\":\n    # Koordinat Jakarta\n    get_weather(\"Jakarta\", -6.2088, 106.8456)\n\n    # Koordinat Makassar\n    get_weather(\"Makassar\", -5.1477, 119.4327)\n</code></pre>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#116-analisis-kode","title":"11.6 Analisis Kode","text":"<ul> <li><code>params={...}</code>: Fitur <code>requests</code> yang sangat membantu. Kita tidak perlu menjahit string URL secara manual (misal: <code>url + \"?lat=\" + lat</code>). Dictionary Python otomatis diubah jadi query string URL yang valid.</li> <li><code>response.json()</code>: Otomatis melakukan Deserialisasi JSON ke Dictionary (Materi Bab 7). Jika responsenya bukan JSON, ini akan error.</li> </ul>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_11/Naskah_Bab_11/#117-tugas-mandiri-eksplorasi-api-lain","title":"11.7 Tugas Mandiri (Eksplorasi API Lain)","text":"<p>Tugas Anda adalah memodifikasi kode di atas untuk mengambil data dari API publik yang lain.</p> <ol> <li>API Kurs Mata Uang: Cari Free Currency API. Buat program konversi Rupiah ke USD secara real-time.</li> <li>API Jokes/Quotes: Cari API yang menyediakan \"Random Quote\". Tampilkan kata-kata mutiara setiap kali script dijalankan.</li> <li>Error Handling: Coba matikan internet Anda, lalu jalankan script cuaca tadi. Apakah pesan errornya manusiawi? Jika muncul pesan traceback panjang yang menakutkan, perbaiki blok <code>try-except</code> Anda.</li> </ol> <p>Navigasi: Naskah_Bab_10 | [[00_Dashboard]] | Naskah_Bab_12</p>","tags":["RESTAPI","WebServices","RequestsLibrary","JSON","PemrogramanJaringan","Python","Bab11"]},{"location":"Bab_12/Naskah_Bab_12/","title":"Bab 12 (WebSocket)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#bab-12-real-time-communication-websocket","title":"Bab 12: Real-time Communication (WebSocket)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membedakan mekanisme HTTP Polling dengan WebSocket dalam konteks efisiensi bandwidth dan latensi. 2.  Menjelaskan proses Protocol Upgrade (Handshake) dari HTTP ke WebSocket. 3.  Membangun server WebSocket yang mampu melakukan Push Notification data secara real-time. 4.  Mengintegrasikan Backend Python dengan Frontend HTML/JS untuk visualisasi data langsung.</p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#121-pendahuluan-mengapa-http-tidak-cukup","title":"12.1 Pendahuluan: Mengapa HTTP Tidak Cukup?","text":"<p>HTTP (Bab 10) didesain untuk Dokumen Statis. Client minta, Server kasih, lalu putus. Tapi bagaimana dengan aplikasi modern seperti: *   Chat WhatsApp (Pesan masuk tanpa direload). *   Grafik Crypto/Saham (Bergerak tiap detik). *   Game Online (Multiplayer real-time).</p> <p>Jika menggunakan HTTP biasa, Client harus melakukan Polling:</p> <p>\"Server, ada pesan baru?\" (Tidak) \"Server, ada pesan baru?\" (Tidak) \"Server, ada pesan baru?\" (Ya)</p> <p>Ini sangat boros bandwidth dan server akan overload hanya untuk menjawab \"Tidak\". Kita butuh mekanisme di mana Server bisa menelpon balik Client: \"Hei, ada data baru nih!\"</p> <p>Analogi Tombol Refresh vs Notifikasi: *   HTTP (Polling): Anda menekan tombol F5 (Refresh) di browser setiap 1 detik untuk melihat skor bola terbaru. Capek dan tidak efisien. *   WebSocket (Push): Ponsel Anda bergetar sendiri saat ada Gol. Anda diam saja menunggu.</p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#122-protokol-websocket-full-duplex","title":"12.2 Protokol WebSocket (Full Duplex)","text":"<p>WebSocket adalah protokol komunikasi dua arah (Full Duplex) di atas satu koneksi TCP yang persisten.</p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#the-handshake-salaman-awal","title":"The Handshake (Salaman Awal)","text":"<p>WebSocket tidak berdiri sendiri, ia \"mendompleng\" HTTP di awal. 1.  Client: Mengirim HTTP Request dengan header <code>Upgrade: websocket</code>. 2.  Server: Jika setuju, membalas <code>101 Switching Protocols</code>. 3.  Jalur Terbuka: Koneksi HTTP kini berubah menjadi pipa WebSocket. Data bisa mengalir dua arah tanpa header HTTP yang gemuk.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Sequence Diagram Handshake HTTP Upgrade -&gt; WebSocket Connection Open]</p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#123-pustaka-websockets","title":"12.3 Pustaka <code>websockets</code>","text":"<p>Python memiliki pustaka <code>websockets</code> yang sangat powerfull dan berjalan di atas <code>asyncio</code> (Bab 8). Ini artinya server kita bisa menangani ribuan koneksi real-time sekaligus.</p> <p>Instalasi: <code>pip install websockets</code></p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#124-praktikum-live-saham-ticker","title":"12.4 Praktikum: Live Saham Ticker","text":"<p>Kita akan membuat sistem pemantau harga saham palsu. *   Server (Python): Mengenerate harga acak setiap detik dan mem-broadcast ke semua browser yang sedang membuka dashboard. *   Client (Chrome/Edge): Halaman HTML sederhana dengan JavaScript untuk menerima data.</p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#a-kode-server-latihan_12_ws_serverpy","title":"A. Kode Server (<code>latihan_12_ws_server.py</code>)","text":"<pre><code>import asyncio\nimport websockets\nimport json\nimport random\n\n# Menyimpan semua client yang terhubung\nCONNECTED_CLIENTS = set()\n\nasync def stock_handler(websocket):\n    \"\"\"\n    Handler ini dijalankan setiap kali ada client baru connect\n    \"\"\"\n    # 1. Register Client\n    print(\"[NEW] Client bergabung.\")\n    CONNECTED_CLIENTS.add(websocket)\n\n    try:\n        # Kirim pesan selamat datang\n        await websocket.send(json.dumps({\"msg\": \"Welcome to Stock Ticker!\"}))\n\n        # Keep connection alive (looping listening)\n        # Sebenarnya server kita tipe BROADCASTER (satu arah), \n        # tapi kita perlu loop agar koneksi tidak putus.\n        async for message in websocket:\n            print(f\"Client sent: {message}\")\n\n    except websockets.exceptions.ConnectionClosed:\n        print(\"[CLOSED] Client terputus.\")\n    finally:\n        # 2. Unregister Client saat putus\n        CONNECTED_CLIENTS.remove(websocket)\n\nasync def broadcast_price():\n    \"\"\"\n    Fungsi latar belakang untuk generate harga palsu\n    \"\"\"\n    while True:\n        # Simulasi harga saham\n        price_data = {\n            \"symbol\": \"BBCA\",\n            \"price\": random.randint(8000, 8500),\n            \"timestamp\": \"Live\"\n        }\n\n        # Serialisasi ke JSON\n        message = json.dumps(price_data)\n\n        # Kirim ke SEMUA client yang ada di set\n        if CONNECTED_CLIENTS:\n            # websockets.broadcast butuh list/set client\n            websockets.broadcast(CONNECTED_CLIENTS, message)\n            print(f\"[BROADCAST] {message} -&gt; ke {len(CONNECTED_CLIENTS)} clients\")\n\n        await asyncio.sleep(1) # Update tiap 1 detik\n\nasync def main():\n    # Jalankan server di port 6789\n    async with websockets.serve(stock_handler, \"localhost\", 6789):\n        print(\"=== WebSocket Server running on ws://localhost:6789 ===\")\n\n        # Jalankan broadcaster di background\n        await broadcast_price() # Ini akan looping selamanya\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"Server Stopped.\")\n</code></pre>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#b-kode-client-dashboardhtml","title":"B. Kode Client (<code>dashboard.html</code>)","text":"<p>Simpan kode ini sebagai file HTML dan buka di browser (Double click).</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Live Stock Dashboard&lt;/title&gt;\n    &lt;style&gt;\n        body { font-family: sans-serif; text-align: center; padding: 50px; }\n        #price-box { font-size: 4em; font-weight: bold; color: green; }\n        .log { color: gray; font-size: 0.8em; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Pantauan Saham BBCA (Real-time)&lt;/h1&gt;\n    &lt;div id=\"price-box\"&gt;Waiting...&lt;/div&gt;\n    &lt;div id=\"status\" class=\"log\"&gt;Disconnected&lt;/div&gt;\n\n    &lt;script&gt;\n        // 1. Buka Koneksi ke Server Python\n        const socket = new WebSocket('ws://localhost:6789');\n\n        socket.onopen = function(e) {\n            document.getElementById(\"status\").textContent = \"Connected to Server \u2705\";\n        };\n\n        socket.onmessage = function(event) {\n            // 2. Terima Data JSON\n            const data = JSON.parse(event.data);\n\n            // Cek apakah ini data harga\n            if(data.price) {\n                const display = `Rp ${data.price}`;\n                document.getElementById(\"price-box\").textContent = display;\n\n                // Efek visual sederhana (Warna berubah acak)\n                document.getElementById(\"price-box\").style.color = \n                    data.price &gt; 8250 ? \"green\" : \"red\";\n            }\n        };\n\n        socket.onclose = function(event) {\n            document.getElementById(\"status\").textContent = \"Connection Lost \u274c\";\n        };\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#125-tugas-mandiri-chat-room-modern","title":"12.5 Tugas Mandiri (Chat Room Modern)","text":"<ol> <li>Jalankan Codingan: Jalankan server python. Buka file HTML di Dua Tab Berbeda. Lihat apakah keduanya berubah angkanya secara bersamaan? (Harusnya Ya).</li> <li>Challenge: Ubah kode di atas menjadi Chat Room.<ul> <li>Server: Saat menerima pesan dari Client A, broadcast pesan itu ke Client B, C, dst.</li> <li>Client HTML: Tambahkan <code>&lt;input&gt;</code> text dan button <code>Send</code> yang memanggil <code>socket.send()</code>.</li> <li>Ini adalah tugas besar yang menggabungkan semua logika Broadcasting dan WebSocket.</li> </ul> </li> </ol>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_12/Naskah_Bab_12/#126-catatan-keamanan","title":"12.6 Catatan Keamanan","text":"<p>Koneksi WebSocket (<code>ws://</code>) itu tidak terenkripsi, sama seperti HTTP. Data bisa diintip hacker. Di production, WAJIB menggunakan WSS (<code>wss://</code>) yang dilindungi SSL/TLS (Sertifikat HTTPS).</p> <p>Navigasi: Naskah_Bab_11 | [[00_Dashboard]] | Naskah_Bab_13</p>","tags":["WebSocket","RealTimeComm","PushTechnology","FullDuplex","PemrogramanJaringan","Python","Bab12"]},{"location":"Bab_13/Naskah_Bab_13/","title":"Bab 13 (Network Security)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#bab-13-keamanan-jaringan-network-security","title":"Bab 13: Keamanan Jaringan (Network Security)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menganalisis kerentanan komunikasi data plaintext terhadap serangan Sniffing dan Man-in-the-Middle. 2.  Membedakan mekanisme Symmetric Encryption dan Asymmetric Encryption. 3.  Mendemonstrasikan penggunaan modul <code>ssl</code> Python untuk mengenkripsi lalu lintas aplikasi Client-Server. 4.  Menerapkan pembuatan Self-Signed Certificate untuk lingkungan pengembangan lokal.</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#131-pendahuluan-jangan-kirim-kartu-pos","title":"13.1 Pendahuluan: Jangan Kirim Kartu Pos!","text":"<p>Bayangkan Anda ingin mengirim surat berisi password ATM kepada ibu Anda di kampung. *   Plaintext (Bab 1-12): Anda menuliskannya di Kartu Pos. Pak Pos bisa baca, tetangga bisa baca, siapapun yang memegang kartu itu bisa baca. Ini sangat berbahaya. *   Encrypted (Bab 13): Anda memasukkan surat itu ke dalam Amplop Baja yang terkunci rapat. Hanya ibu Anda yang memegang kuncinya. Pak Pos hanya bisa melihat alamat tujuan, tapi tidak bisa melihat isinya.</p> <p>Dalam jaringan komputer, \"Pak Pos\" adalah Router, ISP, dan hacker yang satu jaringan WiFi dengan Anda. Tanpa enkripsi, mereka bisa membaca semua data Anda menggunakan alat seperti Wireshark.</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#132-konsep-kriptografi-modern","title":"13.2 Konsep Kriptografi Modern","text":"<p>Bagaimana cara mengirim \"kotak besi\" lewat internet? Komputer menggunakan matematika tingkat tinggi.</p> <ol> <li> <p>Symmetric Key (Kunci Simetris):</p> <ul> <li>Kunci untuk mengunci = Kunci untuk membuka.</li> <li>Masalah: Bagaimana cara mengirim kunci itu ke penerima tanpa dicuri di jalan?</li> </ul> </li> <li> <p>Asymmetric Key (Public/Private Key):</p> <ul> <li>Setiap orang punya sepasang kunci.</li> <li>Public Key (Gembok): Disebar ke semua orang. Siapapun boleh pakai ini untuk mengunci kotak.</li> <li>Private Key (Kunci): Disimpan rahasia. Hanya ini yang bisa membuka kotak yang dikunci oleh Public Key pasangannya.</li> <li>Mekanisme: Saya kirim Gembok Terbuka (Public) ke Anda. Anda masukkan pesan, kunci pakai gembok itu, lalu kirim balik ke saya. Aman! Saya buka pakai Kunci Rahasia saya.</li> </ul> </li> </ol> <p>[Saran: Tambahkan Gambar/Diagram disini: Alice &amp; Bob - Public/Private Key Encryption Flow]</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#133-ssltls-standar-keamanan-internet","title":"13.3 SSL/TLS: Standar Keamanan Internet","text":"<p>Secure Sockets Layer (SSL), yang sekarang berevolusi menjadi Transport Layer Security (TLS), adalah protokol yang membungkus TCP biasa dengan lapisan enkripsi. Ini yang mengubah <code>http://</code> menjadi <code>https://</code>.</p> <p>Modul Python <code>ssl</code> memungkinkan kita melakukan \"Upgrade\" pada socket biasa agar menjadi Secure Socket.</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#134-praktikum-secure-chat","title":"13.4 Praktikum: Secure Chat","text":"<p>Kita akan membuat server yang WAJIB pakai SSL. Client yang tidak punya sertifikat tidak akan bisa connect (atau minimal tidak bisa baca datanya).</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#langkah-1-membuat-sertifikat-self-signed","title":"Langkah 1: Membuat Sertifikat (Self-Signed)","text":"<p>Di dunia nyata, sertifikat dibeli dari Certificate Authority (CA) seperti Verisign atau Let's Encrypt. Untuk latihan, kita jadi CA sendiri (Self-Signed).</p> <p>Buat file baru <code>generate_cert.py</code> dan jalankan SATU KALI SAJA:</p> <p><pre><code># generate_cert.py\nfrom cryptography import x509\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\nimport datetime\n\n# 1. Buat Private Key\nkey = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048,\n    backend=default_backend()\n)\n\n# 2. Buat Sertifikat (Self-Signed)\nsubject = issuer = x509.Name([\n    x509.NameAttribute(x509.NameOID.COUNTRY_NAME, u\"ID\"),\n    x509.NameAttribute(x509.NameOID.ORGANIZATION_NAME, u\"Fikom UIT\"),\n    x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\"),\n])\n\ncert = x509.CertificateBuilder().subject_name(\n    subject\n).issuer_name(\n    issuer\n).public_key(\n    key.public_key()\n).serial_number(\n    x509.random_serial_number()\n).not_valid_before(\n    datetime.datetime.utcnow()\n).not_valid_after(\n    datetime.datetime.utcnow() + datetime.timedelta(days=365)\n).add_extension(\n    x509.SubjectAlternativeName([x509.DNSName(u\"localhost\")]),\n    critical=False,\n).sign(key, hashes.SHA256(), default_backend())\n\n# 3. Simpan ke File\nwith open(\"server_key.pem\", \"wb\") as f:\n    f.write(key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.TraditionalOpenSSL,\n        encryption_algorithm=serialization.NoEncryption(),\n    ))\n\nwith open(\"server_cert.pem\", \"wb\") as f:\n    f.write(cert.public_bytes(serialization.Encoding.PEM))\n\nprint(\"Sertifikat berhasil dibuat: server_cert.pem &amp; server_key.pem\")\n</code></pre> Catatan: Anda perlu <code>pip install cryptography</code> dulu.</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#langkah-2-kode-server-aman-secure_serverpy","title":"Langkah 2: Kode Server Aman (<code>secure_server.py</code>)","text":"<pre><code>import socket\nimport ssl\n\ndef run_secure_server():\n    # 1. Konteks SSL\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    # Muat sertifikat &amp; private key yang kita buat tadi\n    context.load_cert_chain(certfile=\"server_cert.pem\", keyfile=\"server_key.pem\")\n\n    # 2. Socket Biasa\n    bindsocket = socket.socket()\n    bindsocket.bind(('localhost', 10023))\n    bindsocket.listen(5)\n    print(\"Secure Server listening on port 10023...\")\n\n    while True:\n        try:\n            newsocket, fromaddr = bindsocket.accept()\n            print(f\"[NEW] Koneksi TCP dari {fromaddr}\")\n\n            # 3. WRAP (Bungkus) Socket dengan SSL\n            # Di sinilah proses Handshake terjadi\n            conn = context.wrap_socket(newsocket, server_side=True)\n            print(f\"[SECURE] SSL Handshake sukses dengan {fromaddr}\")\n\n            # Komunikasi biasa (tapi terenkripsi otomatis)\n            data = conn.recv(1024)\n            print(f\"Pesan (Decrypted): {data.decode()}\")\n\n            conn.send(b\"Pesan Anda aman bersama kami.\")\n\n        except ssl.SSLError as e:\n            print(f\"[ERROR] Masalah SSL: {e}\")\n        except Exception as e:\n            print(f\"Error lain: {e}\")\n        finally:\n            # conn.close()\n            pass\n\nif __name__ == \"__main__\":\n    run_secure_server()\n</code></pre>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#langkah-3-kode-client-aman-secure_clientpy","title":"Langkah 3: Kode Client Aman (<code>secure_client.py</code>)","text":"<p>Perhatikan opsi <code>check_hostname=False</code> dan <code>CERT_NONE</code>. Ini karena sertifikat kita palsu (Self-Signed), jadi kita paksa client untuk \"percaya saja\".</p> <pre><code>import socket\nimport ssl\n\ndef run_secure_client():\n    # 1. Konteks SSL (Client)\n    # Gunakan create_default_context tapi matikan verifikasi karena sertifikat kita self-signed\n    context = ssl.create_default_context()\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE\n\n    # 2. Socket Biasa\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # 3. WRAP Socket SEBELUM connect\n    # Client membungkus socket dulu, baru connect\n    secure_sock = context.wrap_socket(sock, server_hostname='localhost')\n\n    try:\n        print(\"Menghubungkan ke Secure Server...\")\n        secure_sock.connect(('localhost', 10023))\n        print(f\"Terhubung dengan Cipher: {secure_sock.cipher()}\")\n\n        secure_sock.send(b\"Halo, ini pesan rahasia CIA.\")\n        response = secure_sock.recv(1024)\n        print(f\"Balasan Server: {response.decode()}\")\n\n    finally:\n        secure_sock.close()\n\nif __name__ == \"__main__\":\n    run_secure_client()\n</code></pre>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_13/Naskah_Bab_13/#135-tugas-mandiri-man-in-the-middle","title":"13.5 Tugas Mandiri (Man-in-the-Middle)","text":"<ol> <li>Jalankan Server &amp; Client: Pastikan komunikasi berjalan lancar.</li> <li>Percobaan Peretas: Buat script client biasa (tanpa SSL) dari Bab 2. Coba <code>connect()</code> ke port 10023 dan kirim pesan. Apa yang terjadi?<ul> <li>Hasil: Anda mungkin bisa connect secara TCP, tapi server akan memutus koneksi saat baris <code>context.wrap_socket</code> karena client tidak mengirim sinyal Handshake SSL. Server akan melempar <code>SSLError</code>.</li> </ul> </li> <li>Wireshark (Opsional): Jika Anda mengerti Wireshark, coba intip port 10023. Anda tidak akan melihat tulisan \"Halo\", melainkan sampah binary acak. Itulah enkripsi.</li> </ol> <p>Navigasi: Naskah_Bab_12 | [[00_Dashboard]] | Naskah_Bab_14</p>","tags":["NetworkSecurity","SSLTLS","Encryption","Cryptography","PemrogramanJaringan","Python","Bab13"]},{"location":"Bab_14/Naskah_Bab_14/","title":"Bab 14 (IoT MQTT)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#bab-14-arsitektur-sistem-terdistribusi-iot-mqtt","title":"Bab 14: Arsitektur Sistem Terdistribusi &amp; IoT (MQTT)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membedakan arsitektur Request-Response (HTTP) dengan Publish-Subscribe (MQTT) dalam konteks IoT. 2.  Menganalisis peran Broker sebagai perantara pesan dalam sistem terdistribusi. 3.  Mengimplementasikan komunikasi data sensor menggunakan protokol MQTT dan pustaka <code>paho-mqtt</code>. 4.  Mengevaluasi tingkat keandalan data menggunakan QoS (Quality of Service) Level 0, 1, dan 2.</p>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#141-pendahuluan-masalah-kabel-yang-semrawut","title":"14.1 Pendahuluan: Masalah Kabel yang Semrawut","text":"<p>Dalam 13 bab sebelumnya, kita selalu menghubungkan Client A langsung ke Server B. Bagaimana jika kita punya 1.000 Sensor di sebuah Pabrik Cerdas, dan data sensor itu harus dikirim ke: 1.  Dashboard Monitor Satpam. 2.  Database Server Pusat. 3.  Aplikasi HP Manajer.</p> <p>Jika setiap sensor harus melakukan <code>connect()</code> ke tiga tujuan itu, jaringan akan macet (Spaghetti Connection). Solusinya adalah arsitektur Publish-Subscribe (Pub/Sub).</p>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#142-konsep-pubsub-mqtt","title":"14.2 Konsep Pub/Sub &amp; MQTT","text":"<p>MQTT (Message Queuing Telemetry Transport) adalah protokol \"Ringan\" yang didesain untuk perangkat dengan baterai kecil dan sinyal internet lemah.</p> <p>Analogi Langganan Majalah: *   Publisher (Penulis): Sensor Suhu. Dia tidak peduli siapa yang baca tulisannya. Dia cuma kirim tulisan ke Penerbit. *   Broker (Penerbit/Tukang Pos): Server Pusat (misal: Mosquitto). Dia menerima tulisan, lalu menyebarkannya ke siapapun yang berlangganan. *   Subscriber (Pembaca): Aplikasi HP/Database. Mereka \"Langganan\" topik tertentu. Jika ada edisi baru, Broker akan mengantar ke rumah mereka.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Arsitektur Pub/Sub dimana Sensor (kiri) kirim ke Broker (tengah), dan Broker sebar ke Laptop/HP (kanan)]</p>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#143-quality-of-service-qos-seberapa-penting-data-anda","title":"14.3 Quality of Service (QoS): Seberapa Penting Data Anda?","text":"<p>MQTT punya 3 level jaminan pengiriman. Ini fitur unik yang tidak dimiliki HTTP.</p> <ol> <li>QoS 0 (At most once): \"Fire and Forget.\"<ul> <li>Kirim sekali, kalau hilang ya sudah.</li> <li>Guna: Data suhu yang dikirim tiap detik. Hilang satu tidak masalah.</li> </ul> </li> <li>QoS 1 (At least once): \"Confirmed.\"<ul> <li>Kirim terus sampai Broker bilang \"Diterima\". (Bisa duplikat).</li> <li>Guna: Sensor pintu terbuka (Alert maling).</li> </ul> </li> <li>QoS 2 (Exactly once): \"Perfect.\"<ul> <li>Dijamin sampai tepat satu kali.</li> <li>Guna: Transaksi pembayaran IoT.</li> </ul> </li> </ol>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#144-praktikum-simulasi-smart-home","title":"14.4 Praktikum: Simulasi Smart Home","text":"<p>Kita akan mensimulasikan sistem Rumah Cerdas. Kita butuh MQTT Broker Publik (gratisan) agar tidak perlu install server sendiri. Kita akan gunakan <code>broker.hivemq.com</code> atau <code>test.mosquitto.org</code>.</p> <p>Instalasi Pustaka: <code>pip install paho-mqtt</code></p>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#a-kode-subscriber-pusat-kontrolmonitor","title":"A. Kode Subscriber (Pusat Kontrol/Monitor)","text":"<p>Program ini akan \"mendengarkan\" topik <code>rumah/+/suhu</code>. Tanda <code>+</code> adalah wildcard, artinya dia menerima data dari ruang apa saja (tamu, tidur, dll).</p> <pre><code># latihan_14_mqtt_sub.py\nimport paho.mqtt.client as mqtt\n\n# 1. Konfigurasi\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC = \"kampus/iot/+\" # + adalah Wildcard satu level\n\ndef on_connect(client, userdata, flags, rc):\n    if rc == 0:\n        print(\"[SUKSES] Terhubung ke Broker!\")\n        # Langsung subscribe setelah connect\n        client.subscribe(TOPIC)\n    else:\n        print(f\"[GAGAL] Error Code: {rc}\")\n\ndef on_message(client, userdata, msg):\n    # msg.topic = \"kampus/iot/lab_komputer\"\n    # msg.payload = b\"25.5\"\n    lokasi = msg.topic.split(\"/\")[-1]\n    nilai = msg.payload.decode()\n\n    print(f\"\ud83d\udce1 Data Masuk dari [{lokasi}]: {nilai}\u00b0C\")\n\n# 2. Setup Client\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nprint(f\"Menghubungkan ke {BROKER}...\")\nclient.connect(BROKER, PORT, 60)\n\n# 3. Blocking Loop (Standby selamanya)\nclient.loop_forever()\n</code></pre>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#b-kode-publisher-sensor-dummy","title":"B. Kode Publisher (Sensor Dummy)","text":"<p>Program ini berpura-pura menjadi Sensor Suhu yang mengirim data setiap 2 detik.</p> <pre><code># latihan_14_mqtt_pub.py\nimport paho.mqtt.client as mqtt\nimport time\nimport random\n\nBROKER = \"broker.hivemq.com\"\nPORT = 1883\nTOPIC_BASE = \"kampus/iot\"\n\nclient = mqtt.Client()\nprint(f\"Publisher terhubung ke {BROKER}...\")\nclient.connect(BROKER, PORT, 60)\n\nclient.loop_start() # Jalankan background thread untuk networking\n\ntry:\n    while True:\n        # Simulasi 2 sensor berbeda\n        suhu_lab = random.uniform(20.0, 25.0)\n        suhu_kantin = random.uniform(28.0, 32.0)\n\n        # Publish ke topik spesifik\n        # QoS=1 berarti \"Pastikan sampai\"\n        client.publish(f\"{TOPIC_BASE}/lab_komputer\", f\"{suhu_lab:.2f}\", qos=1)\n        print(f\"Mengirim {suhu_lab:.2f} ke Lab Komputer\")\n\n        client.publish(f\"{TOPIC_BASE}/kantin\", f\"{suhu_kantin:.2f}\", qos=1)\n        print(f\"Mengirim {suhu_kantin:.2f} ke Kantin\")\n\n        time.sleep(2)\n\nexcept KeyboardInterrupt:\n    print(\"Stop Publisher\")\n    client.loop_stop()\n    client.disconnect()\n</code></pre>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#145-tugas-mandiri-smart-garden-system","title":"14.5 Tugas Mandiri (Smart Garden System)","text":"<ol> <li>Jalankan: Hidupkan Subscriber dulu, baru Publisher. Perhatikan di terminal Subscriber, data dari \"lab_komputer\" dan \"kantin\" masuk bergantian.</li> <li>Eksperimen Topik: Ubah <code>TOPIC</code> di Subscriber menjadi <code>kampus/#</code>. Tanda <code>#</code> adalah wildcard multi-level. Coba publish ke topik <code>kampus/satpam/pos_depan</code>. Apakah masuk?</li> <li>Pengendali Lampu:<ul> <li>Buat script <code>saklar.py</code> yang mengirim pesan \"ON\" atau \"OFF\" ke topik <code>rumah/lampu</code>.</li> <li>Buat script <code>lampu.py</code> yang subscribe ke topik tersebut. Jika terima \"ON\", print \"\ud83d\udca1 NYALA\". Jika \"OFF\", print \"\u26ab MATI\".</li> <li>Ini adalah dasar pengendalian perangkat jarak jauh via internet!</li> </ul> </li> </ol>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_14/Naskah_Bab_14/#146-catatan-security","title":"14.6 Catatan Security","text":"<p>Broker publik seperti HiveMQ/Mosquitto bersifat terbuka. Siapapun di dunia yang subscribe ke <code>kampus/iot/#</code> bisa melihat data Anda. JANGAN KIRIM DATA RAHASIA (PASSWORD/CREDENTIAL) KE BROKER PUBLIK. Untuk produksi, Anda harus menginstall broker sendiri (misal di VPS) dan mengaktifkan Username/Password authentication.</p> <p>Navigasi: Naskah_Bab_13 | [[00_Dashboard]] | Naskah_Bab_15</p>","tags":["IoT","MQTT","PubSub","DistributedSystems","PemrogramanJaringan","Python","Bab14"]},{"location":"Bab_15/Naskah_Bab_15/","title":"Bab 15 (Capstone Project)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#bab-15-penutup-proyek-akhir-capstone-project","title":"Bab 15: Penutup &amp; Proyek Akhir (Capstone Project)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Merancang arsitektur sistem jaringan berskala kompleks yang mengintegrasikan minimal 3 protokol berbeda (mis: HTTP, WebSocket, TCP). 2.  Membangun aplikasi Full-Stack Network yang aman, andal, dan scalable sebagai portofolio akhir. 3.  Mengevaluasi performa dan keamanan sistem jaringan yang telah dibangun. 4.  Menyusun rencana pengembangan diri (roadmap) untuk karier di bidang Network Engineering atau Backend Development.</p>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#151-refleksi-perjalanan-dari-bytes-ke-iot","title":"15.1 Refleksi Perjalanan: Dari Bytes ke IoT","text":"<p>Selamat! Anda telah menempuh perjalanan panjang dari Bab 1 hingga 14. Mari kita lihat kembali \"Peta Harta Karun\" yang telah Anda lewati:</p> <ol> <li>Fundamental (Bab 1-5): Anda belajar \"bicara\" bahasa mesin. Dari membedah IP Address, membuat Socket TCP/UDP mentah, hingga menangani error transmisi (Sticky Packet). Anda paham bedanya \"Telepon\" (TCP) dan \"Kartu Pos\" (UDP).</li> <li>Concurrency (Bab 6, 8, 9): Anda belajar multitasking. Dari merekrut banyak pelayan (Threading), menggunakan satu Super Satpam (Select), hingga teknik canggih Asyncio. Anda tahu cara menangani 1.000 user tanpa meledakkan RAM.</li> <li>Data &amp; Protocol (Bab 7, 10, 11): Anda tidak lagi mengirim string kosong. Anda mengirim JSON, membuat Web Server sendiri, dan mengonsumsi REST API cuaca. Anda paham bahwa HTTP hanyalah teks yang diformat rapi.</li> <li>Modern Apps (Bab 12, 13, 14): Anda memasuki era modern. Membuat Dashboard Real-time (WebSocket), mengamankan chat dengan Amplop Baja (SSL), dan menghubungkan Rumah Cerdas (MQTT).</li> </ol> <p>Anda bukan lagi sekadar Coder. Anda adalah Network Application Architect.</p>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#152-spesifikasi-final-project-pjbl","title":"15.2 Spesifikasi Final Project (PjBL)","text":"<p>Sebagai syarat kelulusan mata kuliah ini, Anda wajib mengerjakan Project Based Learning (PjBL) secara berkelompok (3-4 orang). Tujuan proyek ini adalah membuat Satu Aplikasi Terintegrasi yang menggabungkan minimal 3 konsep utama.</p>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#tema-distributed-smart-system","title":"Tema: \"Distributed Smart System\"","text":"<p>Buatlah sebuah sistem yang terdiri dari 3 komponen terpisah yang saling berkomunikasi.</p>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#komponen-1-the-agent-python-bab-2-4-14","title":"Komponen 1: The Agent (Python - Bab 2, 4, 14)","text":"<ul> <li>Sebuah script kecil yang berjalan di laptop/Raspberry Pi.</li> <li>Tugas: Membaca data (bisa CPU Usage, Suhu Palsu, atau Kamera).</li> <li>Protokol: Mengirim data via MQTT atau UDP ke Server Pusat.</li> </ul>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#komponen-2-the-core-server-python-bab-6-7-8-13","title":"Komponen 2: The Core Server (Python - Bab 6, 7, 8, 13)","text":"<ul> <li>Otak utama sistem.</li> <li>Tugas:<ul> <li>Menerima data dari Agent (Subscribe MQTT / Bind UDP).</li> <li>Menyimpan data ke File/Database (JSON/CSV).</li> <li>Menyediakan REST API sederhana untuk login user.</li> <li>(Opsional) Wajib menggunakan SSL/TLS untuk keamanan.</li> </ul> </li> </ul>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#komponen-3-the-monitor-htmljs-bab-10-12","title":"Komponen 3: The Monitor (HTML/JS - Bab 10, 12)","text":"<ul> <li>Antarmuka pengguna.</li> <li>Tugas: Menampilkan data secara Real-time (wajib pakai WebSocket, dilarang Refresh page).</li> <li>User harus bisa melakukan login sederhana sebelum melihat dashboard.</li> </ul> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram Arsitektur Sistem yang menghubungkan Agent -&gt; Server -&gt; Browser]</p>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#153-kriteria-penilaian-profesional","title":"15.3 Kriteria Penilaian Profesional","text":"<p>Proyek ini akan dinilai layaknya sebuah tender proyek IT profesional:</p> Kriteria Bobot Deskripsi Integrasi Protokol 30% Apakah WebSocket, REST, dan MQTT berjalan harmonis tanpa crash? Keandalan (Reliability) 25% Jalankan Agent, matikan Server, nyalakan lagi. Agent harus bisa reconnect otomatis (Error Handling). Keamanan 15% Data sensitif tidak boleh plaintext. Minimal ada Auth login. Plus poin jika pakai SSL. Kode &amp; Arsitektur 20% Kerapian kode, modularitas (fungsi terpisah), dan komentar penjelasan. Dokumen &amp; Demo 10% Readme.md yang jelas dan demo live yang lancar.","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#154-peta-jalan-masa-depan-career-path","title":"15.4 Peta Jalan Masa Depan (Career Path)","text":"<p>Mata kuliah ini adalah pondasi. Dunia jaringan sangat luas. Ke mana Anda harus melangkah selanjutnya?</p> <ol> <li> <p>Jalur DevOps / SRE (Site Reliability Engineer):</p> <ul> <li>Pelajari Docker &amp; Kubernetes: Bagaimana menjalankan script server Anda bukan di laptop, tapi di container.</li> <li>Pelajari CI/CD: Otomatisasi testing dan deployment.</li> </ul> </li> <li> <p>Jalur Backend Engineer:</p> <ul> <li>Pelajari Framework: FastAPI atau Django. Mereka membungkus socket, threading, dan security yang kita pelajari menjadi paket siap pakai.</li> <li>Pelajari Database: PostgreSQL atau Redis (untuk caching data socket).</li> </ul> </li> <li> <p>Jalur IoT Engineer:</p> <ul> <li>Pelajari Elektronika: Arduino, ESP32, Raspberry Pi.</li> <li>Pelajari Protokol Industri: CoAP, Modbus.</li> </ul> </li> </ol>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_15/Naskah_Bab_15/#155-kata-penutup","title":"15.5 Kata Penutup","text":"<p>Teknologi protokol akan terus berubah. Hari ini kita pakai HTTP/1.1, besok HTTP/2, lusa HTTP/3 (QUIC/UDP). Hari ini kita pakai Socket, besok mungkin gRPC atau WebAssembly.</p> <p>Namun, Fundamental tidak pernah berubah. *   IP Address tetaplah alamat. *   Port tetaplah pintu. *   Latency tetaplah musuh. *   Dan Security tetaplah prioritas.</p> <p>Pegang teguh pemahaman fundamental yang Anda dapatkan di buku ini, dan Anda akan siap menghadapi teknologi apapun di masa depan.</p> <p>Happy Networking, and Keep the Packet Flowing! \ud83d\ude80</p> <p>Navigasi: Naskah_Bab_14 | [[00_Dashboard]] | 16_Daftar_Pustaka</p>","tags":["FinalProject","PjBL","SystemIntegration","TeamWork","PemrogramanJaringan","Python","Bab15"]},{"location":"Bab_2/Naskah_Bab_2/","title":"Bab 2 (Socket API)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#bab-2-socket-api-dasar","title":"Bab 2: Socket API Dasar","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Mengoperasikan fungsi-fungsi utama dalam Socket API (<code>bind</code>, <code>listen</code>, <code>accept</code>, <code>connect</code>, <code>send</code>, <code>recv</code>). 2.  Mendemonstrasikan mekanisme pertukaran data sederhana antara Client dan Server. 3.  Menganalisis perbedaan perilaku antara Blocking I/O dan Non-Blocking I/O. 4.  Menerapkan encoding dan decoding yang tepat untuk transmisi data jaringan.</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#21-pengantar-jembatan-antara-aplikasi-dan-jaringan","title":"2.1 Pengantar: Jembatan antara Aplikasi dan Jaringan","text":"<p>Pada Bab 1, kita telah membedah lapisan-lapisan teoritis jaringan (OSI Layer). Di Bab ini, kita akan turun ke lapangan praktik. Pertanyaan mendasarnya adalah: Bagaimana cara kode program Python kita \"berbicara\" dengan kartu jaringan (Network Interface Card)?</p> <p>Jawabannya adalah Socket API.</p> <p>Bayangkan Socket API sebagai sebuah \"Pintu Elektrik\" atau \"Stopkontak\". *   Di dunia nyata, jika Anda ingin menyalakan TV, Anda tidak perlu tahu bagaimana listrik dibangkitkan di PLTU. Anda cukup colokkan kabel ke stopkontak standar. *   Di dunia pemrograman, jika Anda ingin mengirim data ke internet, Anda tidak perlu memprogram sinyal listrik di kabel LAN. Anda cukup \"mencolokkan\" aplikasi Anda ke Socket API yang disediakan oleh Sistem Operasi. Modul <code>socket</code> di Python adalah antarmuka standar tersebut.</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#22-anatomi-hubungan-client-server","title":"2.2 Anatomi Hubungan Client-Server","text":"<p>Sebagian besar aplikasi jaringan modern (Web, Email, Database) bekerja dengan arsitektur Client-Server. Memahami peran keduanya sangat krusial sebelum menulis baris kode pertama.</p> <p>Mari kita gunakan Analogi Resepsionis Hotel untuk memahami alur kerjanya:</p> <p>[Gambar: Ilustrasi kartun yang membandingkan alur Socket dengan alur tamu check-in di hotel]</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#a-sisi-server-the-passive-listener","title":"A. Sisi Server (The Passive Listener)","text":"<p>Server bertindak seperti sebuah Hotel yang harus siap sedia 24 jam. Ia bersifat pasif, artinya ia menunggu, bukan mencari. Langkah-langkah logis yang harus dilakukan Server:</p> <ol> <li><code>socket()</code> - Membangun Gedung: Server membuat objek socket. Ini seperti mendirikan bangunan hotel.</li> <li><code>bind()</code> - Mengklaim Alamat: Server menentukan di mana ia beroperasi (IP Address) dan di pintu nomor berapa (Port). Tanpa bind, tamu (client) tidak akan tahu ke mana harus datang.</li> <li><code>listen()</code> - Membuka Layanan: Server menyatakan dirinya \"BUKA\" dan siap menerima antrean tamu. Parameter backlog menentukan berapa panjang antrean yang diperbolehkan di lobi sebelum satpam menolak tamu baru.</li> <li><code>accept()</code> - Resepsionis Menjawab: Ini adalah momen kritis. Saat ada tamu datang, resepsionis (server) menyapanya.<ul> <li>Penting: Fungsi ini menghasilkan koneksi khusus (socket baru) untuk tamu tersebut. Jadi, resepsionis utama tetap standby di meja depan, sementara tamu tadi dilayani oleh pelayan khusus di koneksi yang baru terbentuk.</li> </ul> </li> <li><code>recv()</code> / <code>send()</code> - Percakapan: Terjadi pertukaran informasi (data).</li> <li><code>close()</code> - Tamu Pulang: Sesi berakhir, kamar dibersihkan.</li> </ol>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#b-sisi-client-the-active-initiator","title":"B. Sisi Client (The Active Initiator)","text":"<p>Client bertindak seperti Tamu Hotel. Ia bersifat aktif karena dialah yang memulai inisiatif untuk datang. Langkah-langkahnya lebih sederhana:</p> <ol> <li><code>socket()</code>: Tamu bersiap (keluar rumah).</li> <li><code>connect()</code>: Tamu mendatangi alamat hotel (IP Server) dan mengetuk pintu tertentu (Port Server).</li> <li><code>send()</code> / <code>recv()</code>: Tamu berbicara dengan resepsionis.</li> <li><code>close()</code>: Tamu pulang.</li> </ol>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#23-konsep-blocking-vs-non-blocking-io","title":"2.3 Konsep Blocking vs Non-Blocking I/O","text":"<p>Salah satu jebakan terbesar bagi pemula di pemrograman jaringan adalah sifat dasar socket yang Blocking.</p> <p>Apa itu Blocking? Bayangkan Anda menelepon Customer Service bank. Anda harus menunggu (holding) sambil mendengarkan musik sampai ada CS yang mengangkat. Selama menunggu, Anda tidak bisa melakukan hal lain. Anda terpaku di situ. *   Dalam kode: Saat program memanggil <code>accept()</code> atau <code>recv()</code>, program akan berhenti total (hang/freeze) di baris tersebut sampai ada data yang masuk. Jika tidak ada yang connect selama 1 jam, program diam selama 1 jam.</p> <p>Konteks Industri: Untuk server yang melayani jutaan user (seperti WhatsApp), sifat blocking ini berbahaya. Jika server sibuk melayani User A dan \"memblokir\" diri, maka User B, C, dan D tidak akan terlayani. Solusinya adalah Non-Blocking I/O atau Concurrency yang akan kita bahas mendalam di Bab 6 dan 8.</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#24-encoding-decoding-bahasa-data","title":"2.4 Encoding &amp; Decoding: Bahasa Data","text":"<p>Jaringan komputer tidak mengerti huruf 'A', 'B', atau emoji. Jaringan hanya mengerti arus listrik on/off yang direpresentasikan sebagai Bytes (urutan angka biner).</p> <p>Oleh karena itu, ada aturan wajib: \"String harus di-Encode sebelum dikirim, dan Bytes harus di-Decode setelah diterima.\"</p> <ul> <li>String (Human Readable): \"Halo Dunia\"</li> <li>Proses Encode (UTF-8): Mengubah \"Halo\" menjadi <code>b'\\x48\\x61\\x6c\\x6f'</code> (Bytes).</li> <li>Kabel Jaringan: Mengirim bytes tersebut.</li> <li>Proses Decode: Menerjemahkan kembali bytes menjadi \"Halo\".</li> </ul> <p>Jika Anda lupa melakukan ini, Python akan melempar <code>TypeError: a bytes-like object is required, not 'str'</code>.</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#25-studi-kasus-hello-world-socket","title":"2.5 Studi Kasus: Hello World Socket","text":"<p>Mari kita implementasikan teori di atas ke dalam kode nyata. Kita akan membuat sistem komunikasi satu arah sederhana.</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#strategi-kode","title":"Strategi Kode","text":"<p>Kita butuh dua terminal terpisah. 1.  Terminal 1 (Server): Dijalankan duluan. Ia akan stuck di posisi <code>accept()</code> menunggu tamu. 2.  Terminal 2 (Client): Dijalankan kemudian. Begitu ia jalan, Server akan \"bangun\", memproses pesan, lalu keduanya selesai.</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#implementasi-server-latihan_2_serverpy","title":"Implementasi Server (<code>latihan_2_server.py</code>)","text":"<p>Perhatikan komentar pada kode untuk memahami state program di tiap baris.</p> <pre><code>import socket\n\n# 1. Membuat Soket (Domain: IPv4, Tipe: TCP)\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 2. Binding (Mengikat ke alamat localhost port 12345)\n# localhost artinya server hanya bisa diakses dari komputer ini saja (aman untuk latihan)\nserver_socket.bind(('localhost', 12345))\n\n# 3. Listening (Mempersiapkan antrian, max 1 antrian)\nserver_socket.listen(1)\nprint(\"Server: Saya siap dan sedang menunggu tamu di port 12345...\")\n\n# 4. Accepting (BLOCKING CALL)\n# Program akan BERHENTI di sini sampai ada Client yang connect.\nconn, addr = server_socket.accept()\nprint(f\"Server: Tamu datang dari alamat {addr}\")\n\n# 5. Komunikasi Data\n# Terima data mentah (bytes), lalu decode ke string\nmsg = conn.recv(1024).decode('utf-8')\nprint(f\"Server: Tamu berkata '{msg}'\")\n\n# Kirim balasan (jangan lupa encode ke bytes)\nconn.send(\"Halo Tamu, salam kenal!\".encode('utf-8'))\n\n# 6. Menutup Koneksi\nconn.close()\nprint(\"Server: Sesi selesai.\")\n</code></pre>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#implementasi-client-latihan_2_clientpy","title":"Implementasi Client (<code>latihan_2_client.py</code>)","text":"<pre><code>import socket\n\n# 1. Membuat Soket\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 2. Connect (Mengetuk pintu server)\n# Pastikan IP dan Port SAMA PERSIS dengan server\nprint(\"Client: Mencoba menghubungi server...\")\nclient_socket.connect(('localhost', 12345))\n\n# 3. Kirim Pesan\npesan = \"Halo Server! Ini percobaan pertama saya.\"\nclient_socket.send(pesan.encode('utf-8')) # Encode string ke bytes\n\n# 4. Terima Balasan\nresponse = client_socket.recv(1024).decode('utf-8') # Decode bytes ke string\nprint(f\"Client: Mendapat balasan '{response}'\")\n\n# 5. Tutup\nclient_socket.close()\n</code></pre>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_2/Naskah_Bab_2/#26-tugas-mandiri-critical-thinking","title":"2.6 Tugas Mandiri (Critical Thinking)","text":"<p>Cobalah eksperimen berikut untuk menguji pemahaman Anda:</p> <ol> <li>Analisis Error: Jalankan <code>client.py</code> TANPA menjalankan <code>server.py</code> terlebih dahulu. Catat pesan error yang muncul. Mengapa error itu terjadi secara logis? (Refleksikan langkah <code>connect</code>).</li> <li>Modifikasi Protokol: Ubah kode agar Client bisa mengirim dua kali pesan sebelum Server membalas. Apakah Server perlu memanggil <code>recv()</code> dua kali juga? Apa yang terjadi jika Server hanya <code>recv()</code> satu kali?</li> <li>Investigasi Port: Coba ubah Port di server menjadi <code>80</code>. Kemungkinan besar akan gagal/acces denied (terutama di Linux/Mac/Windows Admin). Mengapa Port 80 spesial? (Hubungkan dengan materi Well-known Ports di Bab 1).</li> </ol> <p>Navigasi: Naskah_Bab_1 | [[00_Dashboard]] | Naskah_Bab_3</p>","tags":["SocketAPI","ClientServer","BlockingIO","PemrogramanJaringan","Python","Bab2"]},{"location":"Bab_3/Naskah_Bab_3/","title":"Bab 3 (TCP Chat)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#bab-3-protokol-tcp-aplikasi-chat","title":"Bab 3: Protokol TCP (Aplikasi Chat)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan karakteristik utama protokol TCP (Reliability, Ordering, Handshake) dan perbedaannya dengan komunikasi data biasa. 2.  Menerapkan logika perulangan (looping) dalam komunikasi socket untuk menciptakan koneksi persisten. 3.  Membangun aplikasi Chat Sederhana dua arah (Client-Server) menggunakan protokol TCP. 4.  Mendiagnosa keterbatasan model Blocking I/O pada komunikasi real-time.</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#31-pendahuluan-dari-kirim-surat-ke-telepon","title":"3.1 Pendahuluan: Dari \"Kirim Surat\" ke \"Telepon\"","text":"<p>Pada bab sebelumnya, aplikasi kita bekerja seperti mengirim surat: Client mengirim pesan, Server menerima, membalas, lalu koneksi ditutup (hang up). Selesai.</p> <p>Namun, komunikasi dunia nyata jarang sekali sesingkat itu. Bayangkan jika setiap kali Anda ingin bicara satu kalimat dengan teman, Anda harus menutup telepon dan menelepon ulang. Sangat tidak efisien, bukan?</p> <p>Di Bab 3 ini, kita akan meningkatkan level aplikasi kita dari sekadar \"Hello World\" menjadi Aplikasi Chat. Kuncinya adalah Persistensi: menjaga pintu komunikasi tetap terbuka sampai salah satu pihak benar-benar ingin berhenti.</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#32-karakteristik-inti-tcp","title":"3.2 Karakteristik Inti TCP","text":"<p>Transmission Control Protocol (TCP) adalah tulang punggung internet modern. Web (HTTP), Email (SMTP), dan Transfer File (FTP) semuanya berjalan di atas TCP. Mengapa? Karena TCP memiliki sifat Connection-Oriented.</p> <p>Analogi Panggilan Telepon: Sebelum kita bisa bicara (kirim data), nomor harus ditekan dan penerima harus mengangkat (Handshake). Selama pembicaraan, jika suara putus-putus, kita akan meminta lawan bicara mengulang (Retransmission). Data sampai secara berurutan.</p> <p>Empat Pilar TCP: 1.  Reliable (Andal): Menjamin paket sampai. Jika paket hilang di tengah jalan, TCP otomatis mengirim ulang tanpa programmer perlu menulis kode tambahan. Konteks Industri: Ini vital untuk aplikasi perbankan. Transfer uang Rp1 Miliar tidak boleh hilang 1 bit pun. 2.  Ordered (Berurutan): Paket <code>A, B, C</code> dikirim, maka akan diterima sebagai <code>A, B, C</code>. Bukan <code>C, A, B</code>. 3.  Stream-oriented: Data mengalir seperti air. Tidak ada batas jelas antar \"paket\", sehingga kita perlu teknik Framing (dibahas di Bab 5). 4.  Flow Control: Mencegah server overload dengan mengerem pengiriman jika penerima kewalahan.</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#33-mekanisme-koneksi-the-3-way-handshake","title":"3.3 Mekanisme Koneksi: The 3-Way Handshake","text":"<p>Bagaimana TCP memastikan koneksi siap? Ia menggunakan prosedur salaman 3 tahap yang terkenal:</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram Sequence 3-Way Handshake (SYN -&gt; SYN-ACK -&gt; ACK)]</p> <ul> <li>Langkah 1 (SYN): \"Halo, saya mau bicara, boleh?\" (Client -&gt; Server)</li> <li>Langkah 2 (SYN-ACK): \"Boleh, saya siap. Kamu siap?\" (Server -&gt; Client)</li> <li>Langkah 3 (ACK): \"Oke, kita mulai!\" (Client -&gt; Server)</li> </ul> <p>Proses ini terjadi di belakang layar saat kita memanggil fungsi <code>connect()</code> di Python dan <code>accept()</code> meresponsnya.</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#34-studi-kasus-membangun-aplikasi-chat-persistent-connection","title":"3.4 Studi Kasus: Membangun Aplikasi Chat (Persistent Connection)","text":"<p>Tantangan teknis terbesar dari aplikasi chat bukan pada pengiriman datanya, melainkan pada Logika Kontrol Alur (Control Flow).</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#strategi-algoritma","title":"Strategi Algoritma","text":"<p>Jika di Bab 2 kita hanya menggunakan <code>conn.recv()</code> sekali, sekarang kita harus membungkusnya dalam: 1.  Infinite Loop (<code>while True</code>): Agar Server dan Client terus menerus mendengarkan pesan baru. 2.  Exit Condition: Harus ada \"kata kunci\" (misal: \"bye\") untuk memecahkan loop tersebut dan keluar (break).</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#implementasi-server-chat-latihan_3_chat_serverpy","title":"Implementasi Server Chat (<code>latihan_3_chat_server.py</code>)","text":"<p>Dalam kode ini, perhatikan bagaimana blok <code>while True</code> menjaga koneksi tetap hidup.</p> <pre><code>import socket\n\n# Persiapan Socket (Sama seperti Bab 2)\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('localhost', 5000))\nserver.listen(1)\nprint(\"=== Chat Server Siap Berjalan ===\")\n\n# Menunggu tamu pertama\nconn, addr = server.accept()\nprint(f\"[!] Client {addr} bergabung ke dalam sesi chat.\")\n\n# INTI CHAT: Loop komunikasi\nwhile True:\n    try:\n        # 1. Terima Pesan (Akan BLOCKING/diam di sini sampai data masuk)\n        data = conn.recv(1024).decode('utf-8')\n\n        # 2. Cek Kondisi Keluar\n        # Jika data kosong (koneksi putus) atau user ketik 'bye'\n        if not data or data.lower() == 'bye':\n            print(\"[!] Client meminta mengakhiri sesi.\")\n            break\n\n        print(f\"Client &gt; {data}\")\n\n        # 3. Kirim Balasan\n        reply = input(\"Server (Anda) &gt; \")\n        conn.send(reply.encode('utf-8'))\n\n        # Cek jika Server yang ingin keluar\n        if reply.lower() == 'bye':\n            print(\"[!] Anda mengakhiri sesi.\")\n            break\n\n    except Exception as e:\n        print(f\"Error Terjadi: {e}\")\n        break\n\n# Bersih-bersih koneksi\nconn.close()\nserver.close()\nprint(\"=== Aplikasi Ditutup ===\")\n</code></pre>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#keterbatasan-efek-chat-walkie-talkie","title":"Keterbatasan: Efek Chat \"Walkie-Talkie\"","text":"<p>Jika Anda menjalankan kode di atas, Anda akan menyadari fenomena aneh: \"Anda tidak bisa mengirim pesan sebelum lawan bicara membalas pesan terakhir Anda.\"</p> <ul> <li> <p>Penyebab Logis: Fungsi <code>input()</code> dan <code>recv()</code> bersifat Blocking.</p> <ul> <li>Saat kode sampai di baris <code>input()</code>, program server diam menunggu ketikan Dosen. Ia tidak bisa mengeksekusi <code>recv()</code> untuk menerima pesan mahasiswa.</li> <li>Akibatnya, komunikasi menjadi seperti Walkie-Talkie (Gantian ngomong), bukan seperti Telepon/WhatsApp (Bisa ngomong barengan).</li> </ul> </li> <li> <p>Solusi Industri: Untuk membuat Real-time Chat yang sesungguhnya (Duplex), kita membutuhkan Concurrency (Threading) yang akan menjadi topik utama di Bab 6.</p> </li> </ul>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_3/Naskah_Bab_3/#35-tugas-mandiri-eksplorasi","title":"3.5 Tugas Mandiri (Eksplorasi)","text":"<p>Untuk memperdalam pemahaman, kerjakan tantangan berikut:</p> <ol> <li>Analisis Flow: Jalankan Server. Jalankan Client. Ketik pesan di Client, tapi JANGAN balas dulu di Server. Coba kirim pesan KEDUA dari Client. Apa yang terjadi? Pesan kedua tidak akan muncul di Server sampai pesan pertama dibalas. Mengapa? (Jelaskan berdasarkan konsep Buffer dan Blocking).</li> <li>Modifikasi Keamanan: Tambahkan logika autentikasi sederhana. Saat Client pertama kali connect, Server meminta \"Password\". Jika salah, Server langsung <code>conn.close()</code>. Jika benar, baru masuk <code>while True</code>.</li> <li>Implementasi Client: Kode di atas baru sisi Server. Tugas Anda adalah menulis ulang kode <code>latihan_3_chat_client.py</code> dengan logika <code>while True</code> yang serupa agar Client juga bisa membalas terus menerus.</li> </ol> <p>Navigasi: Naskah_Bab_2 | [[00_Dashboard]] | Naskah_Bab_4</p>","tags":["TCPProtocol","ChatApplication","ReliableTransport","ThreeWayHandshake","PemrogramanJaringan","Python","Bab3"]},{"location":"Bab_4/Naskah_Bab_4/","title":"Bab 4 (UDP Streaming)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#bab-4-protokol-udp-streaming-broadcasting","title":"Bab 4: Protokol UDP (Streaming &amp; Broadcasting)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membedakan karakteristik fundamental antara protokol TCP dan UDP dalam konteks keandalan dan kecepatan. 2.  Menganalisis skenario penggunaan yang tepat untuk UDP (Real-time Streaming, IoT, DNS). 3.  Mengimplementasikan aplikasi pengiriman data sensor menggunakan soket UDP (<code>SOCK_DGRAM</code>). 4.  Mendemonstrasikan perilaku connectionless dan fire-and-forget melalui pengujian kode.</p>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#41-pendahuluan-filosofi-fire-and-forget","title":"4.1 Pendahuluan: Filosofi \"Fire and Forget\"","text":"<p>Jika TCP adalah \"Panggilan Telepon\" yang membutuhkan persetujuan kedua belah pihak sebelum bicara, maka UDP (User Datagram Protocol) adalah seperti mengirim Kartu Pos atau Penyiar Radio.</p> <p>Dalam analogi Kartu Pos: *   Anda menulis pesan, menempel perangko, dan memasukkannya ke kotak pos. *   Anda tidak tahu apakah kartu pos itu sampai besok, lusa, atau hilang di jalan. *   Anda tidak menunggu balasan untuk mengirim kartu pos berikutnya. *   Penerima tidak perlu \"sign in\" (handshake) untuk menerima kiriman Anda.</p> <p>Filosofi ini disebut \"Fire and Forget\" (Tembak dan Lupakan). Mungkin terdengar ceroboh, tapi dalam dunia jaringan, kecepatan seringkali lebih berharga daripada kesempurnaan.</p>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#42-karakteristik-teknis-udp","title":"4.2 Karakteristik Teknis UDP","text":"<p>Mengapa kita membutuhkan protokol yang \"tidak bisa diandalkan\" (unreliable)? Karena TCP terlalu \"berat\" dan lambat untuk beberapa kasus.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Header TCP (Gemuk/Banyak Field) vs Header UDP (Kurus/Sedikit Field)]</p> <p>Karakteristik Utama: 1.  Connectionless: Tidak ada prosedur Handshake (SYN-ACK). Pengirim langsung menyemburkan data ke IP tujuan. 2.  Unreliable (Best Effort): Paket yang hilang tidak akan dikirim ulang. Paket yang datang rusak akan langsung dibuang. 3.  Low Overhead: Header UDP hanya 8 bytes, sedangkan TCP minimal 20 bytes. Ini membuat UDP sangat hemat bandwidth dan proses CPU. 4.  No Ordering: Paket ke-1 bisa saja sampai belakangan daripada Paket ke-2.</p>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#43-studi-kasus-industri-kapan-pakai-udp","title":"4.3 Studi Kasus Industri: Kapan Pakai UDP?","text":"<p>Keputusan menggunakan UDP biasanya didasarkan pada pertanyaan: \"Apakah fatal jika ada sedikit data yang hilang?\"</p> <ol> <li> <p>Video Streaming &amp; VoIP (Zoom/YouTube Live):</p> <ul> <li>Jika 1 frame video hilang, layar hanya berkedip sedikit (glitch). TCP akan memaksa video pause (buffering) untuk mengambil paket yang hilang itu. UDP membiarkannya lewat agar video tetap real-time.</li> <li>Prinsip: Latency (kelancaran) &gt; Completeness (kelengkapan).</li> </ul> </li> <li> <p>Game Online (FPS/MOBA):</p> <ul> <li>Posisi musuh harus diupdate 60 kali per detik. Jika posisi detik ke-5 hilang, tidak masalah karena posisi detik ke-6 segera datang.</li> </ul> </li> <li> <p>IoT (Internet of Things):</p> <ul> <li>Sensor suhu mengirim data tiap detik. Sensor bertenaga baterai butuh protokol yang hemat energi (paket kecil).</li> </ul> </li> </ol>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#44-perbedaan-implementasi-tcp-vs-udp","title":"4.4 Perbedaan Implementasi: TCP vs UDP","text":"<p>Mari bandingkan kode Python untuk kedua protokol ini. Perbedaan utamanya ada pada Tipe Socket dan Cara Mengirim.</p> Fitur TCP (Stream) UDP (Datagram) Konstanta Python <code>socket.SOCK_STREAM</code> <code>socket.SOCK_DGRAM</code> Koneksi Wajib <code>connect()</code> / <code>accept()</code> Tidak Ada (Langsung kirim) Fungsi Kirim <code>send()</code> (ke koneksi yang sudah ada) <code>sendto()</code> (wajib sebut alamat tujuan tiap kali kirim) Fungsi Terima <code>recv()</code> <code>recvfrom()</code> (mengembalikan data + alamat pengirim)","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#45-praktikum-simulasi-sensor-suhu-iot","title":"4.5 Praktikum: Simulasi Sensor Suhu IoT","text":"<p>Kita akan mensimulasikan lingkungan Industri 4.0. *   Sender (Client): Sebuah sensor suhu cerdas yang membaca data lingkungan dan menembakkannya ke server pusat setiap detik. *   Receiver (Server): Komputer pusat yang menampung data dari berbagai sensor.</p>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#a-kode-receiver-server","title":"A. Kode Receiver (Server)","text":"<p>Server UDP sangat sederhana karena tidak perlu memelihara status koneksi/antrean client.</p> <pre><code># latihan_4_udp_receiver.py\nimport socket\n\n# 1. Gunakan SOCK_DGRAM untuk UDP\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# 2. Bind ke IP/Port tertentu (Agar paket tahu mau masuk lewat pintu mana)\n# 0.0.0.0 berarti menerima dari semua IP (bukan cuma localhost)\nsock.bind(('0.0.0.0', 9999))\n\nprint(\"=== UDP Monitoring Server Berjalan ===\")\nprint(\"Menunggu data sensor...\")\n\nwhile True:\n    # 3. recvfrom: Menerima paket DARI SIAPA SAJA\n    # Return value: (bytes_data, (ip_pengirim, port_pengirim))\n    data, addr = sock.recvfrom(1024)\n\n    # Decoding dan Display\n    pesan = data.decode('utf-8')\n    print(f\"[Sensor {addr}] Melaporkan: {pesan}\")\n</code></pre>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#b-kode-sender-clientsensor","title":"B. Kode Sender (Client/Sensor)","text":"<p>Perhatikan bahwa Sensor tidak melakukan <code>connect</code>. Ia hanya butuh alamat tujuan.</p> <pre><code># latihan_4_udp_sender.py\nimport socket\nimport time\nimport random\n\n# PENTING: Gunakan SOCK_DGRAM\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Alamat Server Pusat\nTARGET_IP = 'localhost' # Ganti IP ini jika server ada di komputer lain\nTARGET_PORT = 9999\nTARGET_ADDR = (TARGET_IP, TARGET_PORT)\n\nprint(f\"=== Sensor Aktif. Mengirim data ke {TARGET_ADDR} ===\")\n\ntry:\n    while True:\n        # Simulasi pembacaan suhu (20-35 derajat Celcius)\n        suhu = random.randint(20, 35)\n        kelembaban = random.randint(40, 90)\n\n        # Format data: CSV sederhana atau JSON string\n        payload = f\"TEMP:{suhu}C|HUM:{kelembaban}%\"\n\n        # Kirim Paket (Fire!)\n        # Perhatikan kita harus menyertakan TARGET_ADDR di setiap pengiriman\n        sock.sendto(payload.encode('utf-8'), TARGET_ADDR)\n\n        print(f\"Mengirim -&gt; {payload}\")\n\n        # Sensor tidur sejenak untuk hemat baterai\n        time.sleep(1) \n\nexcept KeyboardInterrupt:\n    print(\"\\nSensor dimatikan.\")\n    sock.close()\n</code></pre>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_4/Naskah_Bab_4/#46-tugas-mandiri-eksperimen-fire-and-forget","title":"4.6 Tugas Mandiri (Eksperimen \"Fire and Forget\")","text":"<p>Lakukan percobaan berikut untuk membuktikan sifat UDP:</p> <ol> <li> <p>Pengujian Connectionless:</p> <ul> <li>Jalankan <code>sender.py</code> DULUAN tanpa menjalankan <code>receiver.py</code>.</li> <li>Apakah sender error? (Berbeda dengan TCP Client yang akan kena <code>ConnectionRefused</code>).</li> <li>Analisis: Ke mana perginya paket-paket tersebut?</li> </ul> </li> <li> <p>Broadcast/Multi-sensor:</p> <ul> <li>Jalankan satu <code>receiver.py</code>.</li> <li>Buka 3 terminal baru, jalankan <code>sender.py</code> di ketiganya secara bersamaan.</li> <li>Perhatikan output server. Apakah server bingung? Atau ia bisa menerima data dari ketiga sensor secara bergantian? Inilah kelebihan UDP dalam menangani many-to-one communication tanpa threading yang rumit (walaupun tetap antre di buffer).</li> </ul> </li> <li> <p>Cross-Machine:</p> <ul> <li>Jika ada teman satu jaringan WiFi, minta dia jalankan Receiver (ganti bind ke <code>0.0.0.0</code>). Cek IP-nya.</li> <li>Di laptop Anda, ubah <code>TARGET_IP</code> di Sender ke IP teman Anda.</li> <li>Lihat apakah data sensor Anda muncul di layarnya.</li> </ul> </li> </ol> <p>Navigasi: Naskah_Bab_3 | [[00_Dashboard]] | Naskah_Bab_5</p>","tags":["UDPProtocol","Streaming","Broadcasting","Connectionless","PemrogramanJaringan","Python","Bab4"]},{"location":"Bab_5/Naskah_Bab_5/","title":"Bab 5 (Framing & Error)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#bab-5-error-handling-framing-data","title":"Bab 5: Error Handling &amp; Framing Data","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Mendiagnosa fenomena Sticky Packet dan Packet Fragmentation dalam komunikasi TCP. 2.  Menerapkan teknik Framing (Delimiter dan Length-Prefixed) untuk menjamin integritas data. 3.  Mengimplementasikan mekanisme Error Handling yang robust (Timeout, Try-Except) untuk menangani kegagalan jaringan. 4.  Memperbaiki kode komunikasi socket yang rentan terhadap putus koneksi tiba-tiba.</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#51-pendahuluan-ilusi-kesempurnaan-tcp","title":"5.1 Pendahuluan: Ilusi Kesempurnaan TCP","text":"<p>Di Bab 3, kita belajar bahwa TCP itu reliable (dijamin sampai). Namun, ada satu jebakan besar: TCP menjamin Bytes sampai, tapi tidak menjamin Pesan sampai sebagai satu kesatuan utuh.</p> <p>Banyak programmer pemula berasumsi: *   \"Jika saya <code>send('Hello')</code> lalu <code>send('World')</code>, maka penerima akan <code>recv()</code> dapat 'Hello' lalu <code>recv()</code> dapat 'World'.\"</p> <p>Kenyataan Pahit: Penerima bisa saja mendapatkan: 1.  <code>HelloWorld</code> (Digabung/Sticky Packet) 2.  <code>He</code>, <code>lloWor</code>, <code>ld</code> (Terpecah/Fragmented)</p> <p>Mengapa? Karena TCP adalah Stream Oriented.</p> <p>Analogi Pipa Air: Bayangkan Anda menuangkan segelas air merah (Pesan A) dan segelas air biru (Pesan B) ke dalam satu pipa panjang. Di ujung pipa, air merah dan biru akan bercampur atau mengalir berkesinambungan. Penerima di ujung pipa tidak tahu mana batas antara gelas pertama dan kedua. Tugas kitalah sebagai programmer untuk memberi \"sekat\" atau wadah pada air tersebut. Sekat inilah yang disebut Framing.</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#52-fenomena-sticky-packet-tcp-coalescing","title":"5.2 Fenomena \"Sticky Packet\" (TCP Coalescing)","text":"<p>Sticky Packet terjadi karena efisiensi jaringan. Algoritma TCP (seperti Nagle's Algorithm) menahan pengiriman data-data kecil dan menggumpalkannya menjadi satu paket besar agar hemat bandwidth.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Sender mengirim [A] [B] [C], tapi Receiver menerima [ABC] atau [AB] [C]]</p> <p>Dampak fatal jika tidak ditangani: *   Aplikasi Chat: Pesan user menumpuk jadi satu kalimat panjang tak terbaca. *   Game: Perintah \"Maju\" dan \"Tembak\" lumer jadi satu, karakter game diam saja.</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#53-solusi-teknik-framing","title":"5.3 Solusi: Teknik Framing","text":"<p>Framing adalah seni membungkus data agar penerima tahu: \"Oh, pesan dimulai di sini dan berakhir di sini.\" </p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#strategi-1-delimiter-tanda-pemisah","title":"Strategi 1: Delimiter (Tanda Pemisah)","text":"<p>Kita menyepakati karakter khusus sebagai tanda \"Stop\". Contoh paling umum adalah <code>\\n</code> (Enter/Newline). *   Format: <code>Pesan1\\nPesan2\\n</code> *   Cara Kerja: Penerima membaca byte demi byte sampai ketemu <code>\\n</code>. *   Kelemahan: Pesan itu sendiri tidak boleh mengandung <code>\\n</code> (bisa bikin bingung).</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#strategi-2-length-prefixed-header-panjang","title":"Strategi 2: Length-Prefixed (Header Panjang)","text":"<p>Kita mengirimkan panjang data (angka) sebelum mengirim datanya. *   Format: <code>[4 BYTE BUFFER SIZE][DATA ASLI]</code> *   Contoh: Kirim \"Halo\" (4 huruf).     *   Header: <code>0004</code> (integer 4 byte)     *   Body: <code>Halo</code> *   Kelebihan: Sangat robust, bisa mengirim data binary (foto/suara).</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#54-praktikum-mengatasi-sticky-packet-dengan-delimiter","title":"5.4 Praktikum: Mengatasi Sticky Packet dengan Delimiter","text":"<p>Dalam Python, kita bisa menggunakan fitur <code>makefile()</code> pada objek socket untuk mengubahnya menjadi objek file. Ini memungkinkan kita menggunakan metode <code>readline()</code> yang otomatis membaca sampai karakter <code>\\n</code>. Sangat praktis!</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#a-kode-server-robust-framing","title":"A. Kode Server (Robust Framing)","text":"<p>Perhatikan penggunaan blok <code>with conn</code> dan <code>makefile</code>.</p> <pre><code># latihan_5_sticky_server.py\nimport socket\n\ndef run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    # SO_REUSEADDR agar port bisa langsung dipaka ulang setelah server mati\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n    server.bind(('localhost', 5555))\n    server.listen(5)\n    print(\"=== Server Framing Siap (Port 5555) ===\")\n\n    while True:\n        try:\n            conn, addr = server.accept()\n            print(f\"[!] Koneksi dari {addr}\")\n\n            # MEMBUAT FILE OBJECT DARI SOCKET\n            # Mode 'r' = Read, encoding utf-8\n            # Ini memungkinkan kita pakai 'for line in stream'\n            with conn:\n                stream = conn.makefile('r', encoding='utf-8')\n\n                # Loop ini otomatis membaca per baris (\\n)\n                # Jika tidak ada \\n, dia menunggu (buffer)\n                for line in stream:\n                    line = line.strip() # Hapus \\n di ujung\n                    if not line: break\n\n                    print(f\"Terima Pesan Utuh: {line}\")\n\n                    # Balas juga dengan framing \\n\n                    conn.send(f\"ACK: {line}\\n\".encode('utf-8'))\n\n            print(f\"[!] {addr} terputus.\")\n\n        except Exception as e:\n            print(f\"Error Server: {e}\")\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#b-kode-client-sticky-simulator","title":"B. Kode Client (Sticky Simulator)","text":"<p>Kita akan sengaja mengirim banyak pesan dengan sangat cepat untuk memaksa terjadinya Sticky Packet.</p> <pre><code># latihan_5_sticky_client.py\nimport socket\nimport time\n\ndef run_client():\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('localhost', 5555))\n\n    print(\"=== Uji Coba Sticky Packet ===\")\n    print(\"Mengirim 10 pesan secepat kilat...\")\n\n    # Payload pesan diakhiri \\n sebagai delimiter\n    pesan = \"HaloServer\\n\"\n\n    # Kirim 10x berturut-turut tanpa jeda\n    # Tanpa framing di server, ini pasti akan diterima sebagai satu blob raksasa\n    for i in range(10):\n        data = f\"PesanKe-{i+1}|{pesan}\"\n        client.send(data.encode('utf-8'))\n\n    print(\"Selesai mengirim. Cek terminal Server!\")\n    client.close()\n\nif __name__ == \"__main__\":\n    run_client()\n</code></pre>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#55-error-handling-yang-wajib-ada","title":"5.5 Error Handling yang Wajib Ada","text":"<p>Selain framing, aplikasi jaringan harus tahan banting (Resilient). 1.  Timeout: Apa yang terjadi jika server hang?     *   Solusi: <code>sock.settimeout(10.0)</code> -&gt; Jika 10 detik diam, raise Exception. 2.  Connection Reset: Apa yang terjadi jika kabel client dicabut paksa?     *   Solusi: Wajib bungkus <code>send/recv</code> dalam blok <code>try...except (ConnectionResetError, BrokenPipeError)</code>.</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_5/Naskah_Bab_5/#56-tugas-mandiri-debugging-network","title":"5.6 Tugas Mandiri (Debugging Network)","text":"<ol> <li>Analisis Log: Jalankan Server dan Client di atas. Perhatikan output Server. Apakah pesan tercetak satu per satu dengan rapi?<ul> <li>Tantangan: Coba hapus <code>\\n</code> di kode Client, lalu jalankan. Lihat apa yang terjadi di server (Server akan diam menunggu/hang karena <code>readline</code> tidak pernah menemukan \"Enter\").</li> </ul> </li> <li>Implementasi Timeout: Tambahkan <code>client.settimeout(2.0)</code> pada kode client, lalu buat server tidur (<code>time.sleep(3)</code>) sebelum membalas. Tangkap error timeout tersebut dengan <code>try-except</code>.</li> <li>Studi Kasus: Mengapa protokol HTTP menggunakan Content-Length di headernya? Diskusikan hubungannya dengan materi Framing Length-Prefixed.</li> </ol> <p>Navigasi: Naskah_Bab_4 | [[00_Dashboard]] | Naskah_Bab_6</p>","tags":["ErrorHandling","StickyPacket","Framing","SocketProgramming","PemrogramanJaringan","Python","Bab5"]},{"location":"Bab_6/Naskah_Bab_6/","title":"Bab 6 (Threading)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#bab-6-concurrency-part-i-threading","title":"Bab 6: Concurrency Part I - Threading","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membandingkan arsitektur Iterative Server (Single Thread) dengan Concurrent Server (Multi-threaded). 2.  Menerapkan modul <code>threading</code> Python untuk menangani multiple clients secara simultan. 3.  Mengidentifikasi potensi bahaya Race Condition pada sumber daya bersama (Shared Resources). 4.  Membangun aplikasi Chat Room yang stabil dengan mekanisme sinkronisasi data (Locking).</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#61-limitasi-server-single-thread","title":"6.1 Limitasi Server Single-Thread","text":"<p>Bayangkan sebuah restoran yang hanya memiliki satu pelayan. 1.  Tamu A datang, pelayan mencatat pesanan, ke dapur, masak, lalu menyajikan. 2.  Selama proses itu, Tamu B, C, dan D harus mengantre di luar pintu. Pelayan tidak bisa menyapa mereka sebelum Tamu A selesai makan dan pulang.</p> <p>Inilah gambaran server yang kita buat di Bab 1-5. Disebut Iterative Server. Model ini aman dan mudah, tapi tidak scalable. Di dunia nyata, user tidak mau menunggu user lain selesai chatting baru bisa login.</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#62-solusi-concurrency-dengan-threading","title":"6.2 Solusi Concurrency dengan Threading","text":"<p>Concurrency adalah seni mengerjakan banyak hal \"sekaligus\". Dalam Python, cara termudah adalah menggunakan Threading.</p> <p>Analogi Dapur Restoran (Multi-thread): *   Process (Restoran): Adalah wadah utamanya. Punya memori (bahan makanan) yang sama. *   Main Thread (Manager): Tugasnya hanya berdiri di pintu depan, menyambut tamu (<code>accept()</code>), dan memanggil pelayan baru. *   Worker Thread (Pelayan Tambahan): Setiap kali ada tamu masuk, Manager mempekerjakan satu pelayan khusus untuk melayani tamu itu sampai pulang. *   Jika ada 100 tamu, akan ada 100 pelayan yang bekerja berbarengan dalam satu restoran.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Main Thread yang melakukan spawn Worker Thread untuk setiap Client 1, 2, 3]</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#63-bahaya-laten-race-condition","title":"6.3 Bahaya Laten: Race Condition","text":"<p>Kekuatan Threading adalah memori bersama (Shared Memory), tapi itu juga kelemahan terbesarnya. Jika dua thread mencoba mengubah data yang sama secara bersamaan, data bisa rusak. Ini disebut Race Condition.</p> <p>Contoh Kasus Rekening Bank: *   Saldo Awal: Rp 100.000. *   Thread A (Topup) membaca saldo: 100rb. *   Thread B (Tarik Tunai) membaca saldo: 100rb (karena A belum selesai update). *   Thread A menambah 50rb -&gt; Simpan 150rb. *   Thread B menarik 20rb -&gt; Simpan 80rb (Menimpa hasil kerja A!). *   Hasil Akhir: Saldo jadi 80rb. Padahal seharusnya 130rb.</p> <p>Solusinya? Locking (Gembok). Sebelum menyentuh data sensitif, thread harus mengunci data tersebut agar thread lain menunggu.</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#64-praktikum-chat-room-multi-client-broadcast-system","title":"6.4 Praktikum: Chat Room Multi-Client (Broadcast System)","text":"<p>Kita akan membuat server \"WhatsApp Group\" sederhana. *   Fitur: Setiap pesan dari Client A akan diteruskan (broadcast) ke Client B, C, dan D. *   Tantangan: Daftar <code>clients</code> adalah Shared Resource. Kita harus hati-hati saat menambah/menghapus anggota agar tidak tabrakan dengan proses broadcast.</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#kode-server-latihan_6_thread_serverpy","title":"Kode Server (<code>latihan_6_thread_server.py</code>)","text":"<p>Pelajari bagaimana kita memisahkan logika <code>handle_client</code> ke fungsi sendiri.</p> <pre><code>import socket\nimport threading\n\n# List global untuk menampung semua koneksi aktif\n# Ini adalah SHARED RESOURCE\nclients = []\nclients_lock = threading.Lock() # Gembok pengaman\n\ndef broadcast(message, sender_conn):\n    \"\"\"Mengirim pesan ke semua client KECUALI pengirimnya sendiri\"\"\"\n    # Kita kunci dulu sebelum iterasi agar list tidak berubah di tengah jalan\n    with clients_lock:\n        for client in clients:\n            if client != sender_conn:\n                try:\n                    client.send(message)\n                except:\n                    # Jika gagal kirim, anggap putus (akan dibersihkan nanti)\n                    client.close()\n                    # Menghapus di sini agak tricky saat iterasi, \n                    # jadi biasanya kita skip dulu.\n                    pass\n\ndef handle_client(conn, addr):\n    \"\"\"Fungsi Tugas untuk setiap Worker Thread\"\"\"\n    print(f\"[NEW CONNECTION] {addr} connected.\")\n\n    # Masukkan tamu baru ke buku tamu (dengan aman)\n    with clients_lock:\n        clients.append(conn)\n\n    try:\n        conn.send(\"Selamat datang di Chat Room!\".encode('utf-8'))\n\n        while True:\n            # Tunggu pesan (Blocking di thread ini saja, tidak ganggu thread lain)\n            message = conn.recv(1024)\n            if not message:\n                break\n\n            # Format pesan: \"[IP]: Isi Pesan\"\n            msg_decoded = message.decode('utf-8')\n            output = f\"[{addr[1]}]: {msg_decoded}\"\n            print(output)\n\n            # Sebarkan pesan\n            broadcast(output.encode('utf-8'), conn)\n\n    except Exception as e:\n        print(f\"[ERROR] {addr}: {e}\")\n    finally:\n        # Bersih-bersih saat tamu pulang\n        print(f\"[DISCONNECT] {addr} keluar.\")\n        with clients_lock:\n            if conn in clients:\n                clients.remove(conn)\n        conn.close()\n\ndef start_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 5555))\n    server.listen()\n    print(\"[SERVER STARTED] Menunggu di port 5555...\")\n\n    while True:\n        # 1. Main Thread standby di sini\n        conn, addr = server.accept()\n\n        # 2. Begitu ada tamu, buat Thread baru\n        thread = threading.Thread(target=handle_client, args=(conn, addr))\n\n        # 3. Jalankan Thread (Start dan lupakan)\n        # Daemon=True artinya thread ini akan mati otomatis jika program utama mati\n        thread.daemon = True \n        thread.start()\n\n        print(f\"[ACTIVE CONNECTIONS] {threading.active_count() - 1}\")\n\nif __name__ == \"__main__\":\n    start_server()\n</code></pre>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#kode-client","title":"Kode Client","text":"<p>Anda bisa menggunakan kembali kode Client Chat Bab 3 atau Client Telnet (Putty). Keduanya kompatibel karena protokolnya hanya TCP raw text.</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_6/Naskah_Bab_6/#65-tugas-mandiri-critical-analysis","title":"6.5 Tugas Mandiri (Critical Analysis)","text":"<ol> <li>Observasi Thread: Jalankan Server. Buka 3 Client. Lihat output di server <code>[ACTIVE CONNECTIONS]</code>. Apakah angkanya sesuai?</li> <li>Stress Test: Apa yang terjadi jika 1000 client masuk bersamaan?<ul> <li>Analisis: Python Threading punya batas (overhead memori OS). Untuk skala masif (10.000+ user), Threading tidak efisien. Di sinilah kita nanti membutuhkan Asynchronous I/O (Bab 8).</li> </ul> </li> <li>Identifikasi Race Condition: Coba hapus semua baris <code>with clients_lock:</code> di kode server. Jalankan script \"bomber\" yang menyambungkan dan memutus 100 koneksi secepat mungkin. Kemungkinan besar program akan crash dengan error seperti <code>RuntimeError: dictionary changed size during iteration</code>. Ini bukti nyata Race Condition!</li> </ol> <p>Navigasi: Naskah_Bab_5 | [[00_Dashboard]] | Naskah_Bab_7</p>","tags":["Concurrency","Multithreading","ThreadSafety","RaceCondition","PemrogramanJaringan","Python","Bab6"]},{"location":"Bab_7/Naskah_Bab_7/","title":"Bab 7 (Serialisasi JSON)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#bab-7-serialisasi-data-json-pickle","title":"Bab 7: Serialisasi Data (JSON &amp; Pickle)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan konsep Serialization dan Deserialization serta urgensinya dalam pertukaran data jaringan. 2.  Membandingkan format data JSON (Universal) dan Pickle (Python-Specific) berdasarkan kelebihan dan risiko keamanannya. 3.  Menerapkan modul <code>json</code> untuk mengirim dan menerima struktur data kompleks (Dictionary, List). 4.  Merancang protokol aplikasi berbasis Request-Response sederhana.</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#71-pendahuluan-masalah-bahasa-antar-komputer","title":"7.1 Pendahuluan: Masalah \"Bahasa\" Antar Komputer","text":"<p>Sampai sejauh ini, kita hanya mengirim data berupa string mentah (<code>\"Hello World\"</code>). Namun, aplikasi nyata membutuhkan data yang terstruktur. Bagaimana jika kita ingin mengirim data Mahasiswa yang berisi <code>Nama</code>, <code>NIM</code>, <code>Nilai</code>, dan <code>Daftar Mata Kuliah</code> sekaligus?</p> <p>Socket tidak mengerti apa itu \"List\", \"Dictionary\", atau \"Object Class\". Socket hanya mengerti Bytes. Jika kita memaksakan mengirim objek Python <code>{'nama': 'Budi'}</code>, socket akan menolak dengan error <code>TypeError</code>.</p> <p>Analogi Furniture IKEA (Flat-pack): *   Objek Python (Lemari Jadi): Sebuah struktur data yang utuh, memakan tempat, dan kompleks. Tidak bisa dimasukkan ke dalam kotak pengiriman (kabel jaringan) begitu saja. *   Serialisasi (Pembongkaran): Lemari dibongkar menjadi papan-papan datar (bytes/string) dan dimasukkan ke kardus. Sekarang ia bisa dikirim lewat kurir (jaringan). *   Deserialisasi (Perakitan): Di rumah penerima, papan-papan datar tadi dirakit kembali menjadi Lemari utuh sesuai petunjuk manual.</p> <p>Proses mengubah Objek menjadi Bytes disebut Marshalling/Serialization. Kebalikannya disebut Unmarshalling/Deserialization.</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#72-format-data-json-vs-pickle","title":"7.2 Format Data: JSON vs Pickle","text":"<p>Ada dua cara populer di Python untuk melakukan \"packing\" ini.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Bagan alur Serialisasi (Objek -&gt; JSON String -&gt; Bytes) dan Deserialisasi]</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#a-json-javascript-object-notation","title":"A. JSON (JavaScript Object Notation)","text":"<p>Ini adalah standar emas dunia web modern. Hampir semua bahasa (Java, PHP, Go, C#) mengerti JSON. *   Karakteristik: Berbasis Teks, Terbaca Manusia (Human Readable). *   Tipe Data: Terbatas pada String, Number, Boolean, List, dan Dictionary (Object). Tidak bisa menyimpan fungsi atau class khusus. *   Penggunaan: Pertukaran data antar aplikasi berbeda (misal: Backend Python dengan Frontend Web React).</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#b-pickle-python-object-serialization","title":"B. Pickle (Python Object Serialization)","text":"<p>Format eksklusif milik Python. *   Karakteristik: Berbasis Biner (Binary), Tidak terbaca manusia, Sangat Kuat. *   Tipe Data: Bisa menyimpan hampir APA SAJA di Python (Custom Classes, Functions, bahkan object Socket itu sendiri - walau tidak disarankan). *   Peringatan Keamanan (CRITICAL):     &gt; JANGAN PERNAH melakukan <code>pickle.load()</code> pada data yang dikirim oleh pihak yang tidak dikenal. File pickle yang jahat bisa berisi kode untuk menghapus harddisk Anda saat dibuka.</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#73-studi-kasus-protokol-database-mahasiswa","title":"7.3 Studi Kasus: Protokol Database Mahasiswa","text":"<p>Mari kita bangun server database sederhana. Protokolnya adalah sebagai berikut: 1.  Request: Client mengirim JSON berisi <code>{ \"command\": \"CARI\", \"nim\": \"101\" }</code>. 2.  Response: Server mencari di dictionary, lalu membalas dengan JSON <code>{ \"status\": \"OK\", \"data\": { ... } }</code> atau <code>{ \"status\": \"ERROR\", \"pesan\": \"Tidak ditemukan\" }</code>.</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#kode-server-latihan_7_json_serverpy","title":"Kode Server (<code>latihan_7_json_server.py</code>)","text":"<p>Perhatikan bagaimana kita menggunakan <code>json.loads</code> untuk membaca perintah dan <code>json.dumps</code> untuk membalas.</p> <pre><code>import socket\nimport json\n\n# Database dummy dalam memori\nDATABASE = {\n    \"101\": {\"nama\": \"Budi Santoso\", \"prodi\": \"Teknik Informatika\", \"ipk\": 3.75},\n    \"102\": {\"nama\": \"Siti Aminah\", \"prodi\": \"Sistem Informasi\", \"ipk\": 3.90},\n    \"103\": {\"nama\": \"Andi Wijaya\", \"prodi\": \"Teknik Komputer\", \"ipk\": 3.50}\n}\n\ndef run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 6000))\n    server.listen(5)\n    print(\"=== Database Server (JSON) Berjalan di Port 6000 ===\")\n\n    while True:\n        client, addr = server.accept()\n        print(f\"[!] Koneksi dari {addr}\")\n\n        try:\n            # 1. Terima data byte\n            request_bytes = client.recv(4096)\n            if not request_bytes: break\n\n            # 2. Deserialisasi (Bytes -&gt; String -&gt; Dict)\n            request_str = request_bytes.decode('utf-8')\n            print(f\"DEBUG REQ: {request_str}\")\n\n            # Parsing JSON (Bisa error jika format salah)\n            request_data = json.loads(request_str)\n\n            # 3. Logika Bisnis (Cek Command)\n            command = request_data.get('command')\n            nim = request_data.get('nim')\n\n            response = {}\n\n            if command == 'GET_MHS':\n                if nim in DATABASE:\n                    response = {\n                        \"status\": \"SUKSES\", \n                        \"data\": DATABASE[nim]\n                    }\n                else:\n                    response = {\"status\": \"GAGAL\", \"pesan\": \"NIM tidak ditemukan\"}\n            else:\n                response = {\"status\": \"ERROR\", \"pesan\": \"Perintah tidak dikenali\"}\n\n            # 4. Serialisasi (Dict -&gt; String JSON -&gt; Bytes)\n            response_bytes = json.dumps(response).encode('utf-8')\n            client.send(response_bytes)\n\n        except json.JSONDecodeError:\n            error_msg = json.dumps({\"status\": \"ERROR\", \"pesan\": \"Format JSON Invalid\"}).encode()\n            client.send(error_msg)\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            client.close()\n\nif __name__ == \"__main__\":\n    run_server()\n</code></pre>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#kode-client-latihan_7_json_clientpy","title":"Kode Client (<code>latihan_7_json_client.py</code>)","text":"<pre><code>import socket\nimport json\n\ndef cek_mahasiswa(nim):\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('localhost', 6000))\n\n    # 1. Persiapkan Request (Dict)\n    request = {\n        \"command\": \"GET_MHS\",\n        \"nim\": nim\n    }\n\n    # 2. Serialisasi &amp; Kirim\n    print(f\"Mengirim Request untuk NIM: {nim}...\")\n    client.send(json.dumps(request).encode('utf-8'))\n\n    # 3. Terima &amp; Deserialisasi\n    response_bytes = client.recv(4096)\n    response = json.loads(response_bytes.decode('utf-8'))\n\n    # 4. Tampilkan Hasil\n    print(\"Respon Server:\", json.dumps(response, indent=2))\n    client.close()\n\nif __name__ == \"__main__\":\n    # Test cases\n    cek_mahasiswa(\"101\") # Ada\n    cek_mahasiswa(\"999\") # Tidak ada\n</code></pre>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_7/Naskah_Bab_7/#74-tugas-mandiri-eksplorasi-format","title":"7.4 Tugas Mandiri (Eksplorasi Format)","text":"<ol> <li>Tambah Fitur: Modifikasi Server dan Client agar bisa menjalankan perintah <code>ADD_MHS</code> untuk menambah data baru ke dictionary <code>DATABASE</code>.</li> <li>Eksperimen Pickle: Buat script terpisah yang mencoba mengirimkan objek Class Python (misal <code>class Mahasiswa</code>) menggunakan modul <code>pickle</code>. Buktikan bahwa server yang menggunakan <code>pickle.loads</code> bisa membaca objek tersebut beserta method-methodnya.</li> <li>Analisis Keamanan: Mengapa JSON lebih disukai daripada Pickle untuk Public API? (Hubungkan dengan fakta bahwa JSON adalah teks murni yang pasif, sedangkan Pickle adalah eksekusi kode).</li> </ol> <p>Navigasi: Naskah_Bab_6 | [[00_Dashboard]] | Naskah_Bab_8</p>","tags":["DataSerialization","JSONFormat","Pickle","DataExchange","PemrogramanJaringan","Python","Bab7"]},{"location":"Bab_8/Naskah_Bab_8/","title":"Bab 8 (Async IO)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#bab-8-asynchronous-io-concurrency-part-ii","title":"Bab 8: Asynchronous I/O (Concurrency Part II)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Membandingkan efisiensi Multi-threading vs Asynchronous I/O dalam menangani beban kerja tinggi (C10k Problem). 2.  Menjelaskan arsitektur Event Loop dan peran Coroutines (<code>async</code>/<code>await</code>) dalam manajemen tugas. 3.  Mengimplementasikan server non-blocking menggunakan pustaka <code>asyncio</code> Python. 4.  Mendiagnosa kesalahan umum dalam pemrograman async seperti Blocking Code yang mematikan Event Loop.</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#81-pendahuluan-mengapa-threading-saja-tidak-cukup","title":"8.1 Pendahuluan: Mengapa Threading Saja Tidak Cukup?","text":"<p>Di Bab 6, kita menggunakan Threading untuk melayani banyak klien. Setiap tamu diberi satu pelayan khusus. Cara ini efektif, namun mahal. Bayangkan jika tamu yang datang ada 10.000 orang. *   Apakah restoran sanggup menggaji 10.000 pelayan? *   Apakah dapur muat menampung 10.000 pelayan?</p> <p>Dalam komputer, setiap Thread membutuhkan memori (Stack) sekitar 8MB. <code>10.000 thread x 8MB = 80.000MB (80GB) RAM</code>. Server akan langsung crash sebelum sempat melayani. Masalah ini dikenal sebagai C10k Problem (Problem 10.000 Koneksi).</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#82-konsep-asynchronous-the-super-tuner","title":"8.2 Konsep Asynchronous: The Super Tuner","text":"<p>Asynchronous I/O menawarkan pendekatan berbeda: Single Thread, tapi Super Cepat.</p> <p>Analogi Grandmaster Catur (Simultan): Bayangkan seorang Juara Dunia Catur (Server) melawan 50 orang amatir (Clients) sekaligus. 1.  Grandmaster mendatangi Meja 1, melangkah, lalu langsung pindah ke Meja 2. 2.  Ia tidak menunggu Lawan 1 berpikir. Ia memanfaatkan waktu \"mikikirnya\" Lawan 1 untuk melayani Lawan 2, 3, dst. 3.  Dalam waktu singkat, ia bisa melayani 50 langkah tanpa diam sama sekali.</p> <p>Dalam analogi ini: *   Grandmaster = Event Loop (Prosesor Utama). *   Waktu Lawan Berpikir = I/O Latency (Menunggu database/network). *   Langkah Catur = Task kecil yang dieksekusi CPU.</p> <p>Dengan model ini, Satu Thread bisa melayani ribuan koneksi selama ia tidak pernah \"menunggu\" (blocking).</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#83-arsitektur-asyncio-python","title":"8.3 Arsitektur Asyncio Python","text":"<p>Sejak Python 3.5, kita memiliki sintaks <code>async</code> dan <code>await</code>.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Ilustrasi Event Loop yang berputar mengambil task dari antrian, menjalankannya sebentar, lalu menaruhnya kembali jika task itu butuh I/O]</p> <p>Tiga Istilah Kunci: 1.  Event Loop: Manajer yang tidak kenal lelah. Dia berteriak: \"Siapa yang datanya sudah siap? Oke kamu! Sekarang kamu!\" 2.  Coroutine (<code>async def</code>): Fungsi yang bisa di-pause. Jika dia butuh data jaringan, dia bilang ke Event Loop: \"Bro, saya mau tunggu data dulu, saya pause ya. Lanjutin kerjaan lain gih.\" 3.  Await (<code>await</code>): Titik di mana fungsi menyerahkan kontrol kembali ke Event Loop.</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#84-praktikum-high-performance-async-server","title":"8.4 Praktikum: High-Performance Async Server","text":"<p>Kita akan menulis server yang mampu menangani ribuan koneksi dengan RAM sangat kecil. Kita akan menggunakan API level tinggi <code>asyncio.start_server</code> yang jauh lebih bersih daripada menggunakan socket mentah.</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#kode-server-latihan_8_async_serverpy","title":"Kode Server (<code>latihan_8_async_server.py</code>)","text":"<pre><code>import asyncio\n\nasync def handle_client(reader, writer):\n    \"\"\"\n    Coroutine ini akan dijalankan untuk SETIAP client yang connect.\n    Bayangkan ini sebagai 'Langkah Catur' untuk satu meja.\n    \"\"\"\n    addr = writer.get_extra_info('peername')\n    print(f\"[BARU] Koneksi dari {addr}\")\n\n    try:\n        while True:\n            # 1. Baca Data (Non-Blocking)\n            # keyword 'await' artinya: \"Tunggu data masuk, tapi JANGAN BLOKIR server.\"\n            # \"Silakan server urus client lain dulu. Kalau data sudah ada, bangunkan saya.\"\n            data = await reader.read(100) # Baca maksimal 100 byte\n\n            if not data:\n                print(f\"[PUTUS] {addr} menutup koneksi.\")\n                break\n\n            message = data.decode().strip()\n            print(f\"[{addr}] Mengirim: {message}\")\n\n            # 2. Proses &amp; Balas\n            response = f\"Echo: {message}\\n\"\n            writer.write(response.encode())\n\n            # 3. Pastikan data terkirim (Drain buffer)\n            await writer.drain()\n\n    except Exception as e:\n        print(f\"[ERROR] {addr}: {e}\")\n    finally:\n        writer.close()\n        await writer.wait_closed() # Pastikan socket benar-benar tutup\n\nasync def main():\n    # Membuat Server Async\n    server = await asyncio.start_server(\n        handle_client, '127.0.0.1', 8888)\n\n    addrs = ', '.join(str(sock.getsockname()) for sock in server.sockets)\n    print(f'=== Async Server Berjalan di {addrs} ===')\n\n    # Biarkan server berjalan selamanya\n    async with server:\n        await server.serve_forever()\n\nif __name__ == '__main__':\n    # Memulai Event Loop\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print(\"\\nServer Dimatikan.\")\n</code></pre>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#85-analisis-kode","title":"8.5 Analisis Kode","text":"<p>Perhatikan bedanya dengan Bab 6 (Threading): *   Tidak ada <code>threading.Thread</code>: Kita tidak membuat thread baru. Semua berjalan di Main Thread. *   Magic Keyword <code>await</code>: Inilah kuncinya. Setiap kali ada <code>await</code>, fungsi itu \"mengalah\" dan membiarkan Event Loop mengerjakan hal lain. *   Reader/Writer: Asyncio membungkus socket mentah menjadi objek Stream yang lebih mudah dikelola.</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#86-bahaya-blocking-code-di-dunia-async","title":"8.6 Bahaya: Blocking Code di Dunia Async","text":"<p>Apa yang terjadi jika Anda memasukkan kode ini di dalam fungsi <code>handle_client</code>? <pre><code>import time\ntime.sleep(5)  # BAHAYA!!! \n</code></pre> BENCANA. <code>time.sleep</code> adalah fungsi Blocking. Dia akan memberhentikan seluruh Event Loop. Artinya, selama 5 detik itu, TIDAK ADA SATUPUN dari 10.000 client yang bisa dilayani. Server mati total. Solusi: Gunakan <code>await asyncio.sleep(5)</code>. Ini versi non-blocking yang ramah event loop.</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_8/Naskah_Bab_8/#87-tugas-mandiri-stress-test","title":"8.7 Tugas Mandiri (Stress Test)","text":"<ol> <li>Jalankan Server Async.</li> <li>Buktikan Konsep: Buka dua terminal Client. Kirim pesan dari Client A, lalu Client B. Keduanya harusnya lancar tanpa jeda.</li> <li>Hancurkan Server: Sisipkan <code>time.sleep(10)</code> di dalam Loop <code>handle_client</code>. Coba connect pakai Client A. Lalu coba connect Client B. Client B tidak akan bisa connect selama 10 detik. Ini membuktikan bahwa Asyncio itu Single Threaded.</li> <li>Eksplorasi: Bandingkan penggunaan RAM antara <code>latihan_6_thread_server.py</code> dan <code>latihan_8_async_server.py</code> saat menghadapi 100 koneksi (gunakan Task Manager/htop). Asyncio harusnya jauh lebih hemat.</li> </ol> <p>Navigasi: Naskah_Bab_7 | [[00_Dashboard]] | Naskah_Bab_9</p>","tags":["AsyncIO","AsynchronousProgramming","EventLoop","HighPerformance","PemrogramanJaringan","Python","Bab8"]},{"location":"Bab_9/Naskah_Bab_9/","title":"Bab 9 (IO Multiplexing)","text":"<p>Matakuliah: Pemrograman Jaringan Dosen: Ucok, S.Kom., MT</p>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#bab-9-io-multiplexing-select-poll","title":"Bab 9: I/O Multiplexing (<code>select</code> &amp; <code>poll</code>)","text":"<p>Capaian Pembelajaran (Sub-CPMK):</p> <p>Setelah menyelesaikan bab ini, mahasiswa diharapkan mampu: 1.  Menjelaskan mekanisme dasar kernel OS dalam memantau deskriptor file (file descriptors) menggunakan <code>select</code>. 2.  Membedakan antara Blocking I/O, Non-Blocking I/O, dan I/O Multiplexing. 3.  Mengimplementasikan server konkruen hemat memori menggunakan modul <code>select</code> tanpa threading. 4.  Mendiagnosa batasan skalabilitas <code>select</code> dibanding mekanisme modern seperti <code>epoll</code> (Linux) atau IOCP (Windows).</p>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#91-pendahuluan-membongkar-magic-asyncio","title":"9.1 Pendahuluan: Membongkar \"Magic\" Asyncio","text":"<p>Di Bab 8, kita menggunakan <code>asyncio</code> yang terasa \"ajaib\". Satu orang (thread) bisa menangani ribuan tugas. Tapi bagaimana caranya? Di Bab ini, kita akan membongkar mesin di balik layar tersebut. Kita akan belajar cara kerja \"Manual\"-nya. Teknik ini disebut I/O Multiplexing.</p> <p>Analogi Satpam CCTV: *   Blocking (Bab 2): Satpam berdiri di depan Pintu 1. Jika ada orang di Pintu 10, dia tidak tahu. *   Threading (Bab 6): Anda merekrut 100 Satpam untuk menjaga 100 pintu. Mahal dan ruangan penuh sesak. *   I/O Multiplexing (Bab 9): Hanya ada Satu Satpam, tapi dia duduk di ruang kontrol dengan 100 Layar CCTV. Dia diam saja sampai melihat ada gerakan di salah satu layar. Jika Pintu 5 bergerak, dia merespons Pintu 5. Jika Pintu 80 bergerak, dia ke Pintu 80.</p> <p>Inilah inti dari fungsi <code>select()</code>: Sebuah syscall (panggilan sistem) yang meminta OS untuk \"Tolong awasi 100 socket ini, dan bangunkan saya hanya jika ada yang datanya siap.\"</p>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#92-arsitektur-select","title":"9.2 Arsitektur <code>select</code>","text":"<p>Fungsi <code>select</code> menerima tiga daftar socket: 1.  Readable (<code>rlist</code>): Daftar socket yang ingin dipantau apakah \"Ada data masuk?\" 2.  Writable (<code>wlist</code>): Daftar socket yang ingin dipantau apakah \"Buffer kosong/siap dikirimi data?\" 3.  Exceptional (<code>xlist</code>): Daftar socket yang error.</p> <p>[Saran: Tambahkan Gambar/Diagram disini: Diagram blok fungsi select() yang menerima input list socket dan mengeluarkan output list socket yang aktif]</p>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#93-praktikum-chat-server-low-level","title":"9.3 Praktikum: Chat Server \"Low Level\"","text":"<p>Kita akan membangun ulang Chat Server Bab 6 (Threading), tapi kali ini tanpa Thread sama sekali. Kita akan melihat betapa efisiennya kode ini dari segi penggunaan Memori (RAM), karena tidak ada overhead stack per-thread.</p>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#logika-algoritma","title":"Logika Algoritma","text":"<ol> <li>Buat List <code>SOCKET_LIST</code> yang awalnya hanya berisi Server Socket utama.</li> <li>Masuk Infinite Loop:<ul> <li>Panggil <code>read_sockets, _, _ = select(SOCKET_LIST, [], [])</code>.</li> <li>Looping <code>read_sockets</code>:<ul> <li>Jika itu Server Socket Master: Berarti ada tamu baru (<code>accept</code>). Tambahkan tamu ke <code>SOCKET_LIST</code>.</li> <li>Jika itu Client Socket: Berarti ada pesan (<code>recv</code>).<ul> <li>Jika pesan ada: Broadcast ke yang lain.</li> <li>Jika pesan kosong: Client putus, hapus dari <code>SOCKET_LIST</code>.</li> </ul> </li> </ul> </li> </ul> </li> </ol>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#kode-server-latihan_9_select_serverpy","title":"Kode Server (<code>latihan_9_select_server.py</code>)","text":"<pre><code>import socket\nimport select\nimport sys\n\ndef run_chat_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.bind(('0.0.0.0', 9000))\n    server_socket.listen(10)\n\n    # List untuk menampung semua socket yang sedang dipantau oleh 'Satpam'\n    socket_list = [server_socket]\n\n    # Dictionary opsional untuk menyimpan nama user (jika mau)\n    clients = {} \n\n    print(f\"=== Select Server (Single Thread) berjalan di port 9000 ===\")\n\n    while True:\n        # Panggilan ke OS: \"Tolong pantau socket_list ini\"\n        # Fungsi ini akan BLOCKING sampai minimal ada satu socket yang aktif\n        read_sockets, _, exception_sockets = select.select(socket_list, [], socket_list)\n\n        for sock in read_sockets:\n            # KASUS 1: Ada tamu baru mengetuk pintu Server Utama\n            if sock == server_socket:\n                sockfd, addr = server_socket.accept()\n                socket_list.append(sockfd) # Daftarkan tamu baru ke CCTV\n                clients[sockfd] = addr\n                print(f\"[BARU] Client {addr} bergabung\")\n\n            # KASUS 2: Ada pesan dari salah satu Client\n            else:\n                try:\n                    data = sock.recv(1024)\n                    if data:\n                        # Ada pesan, sebarkan (Broadcast)\n                        pesan = f\"[{clients[sock]}]: {data.decode()}\\n\"\n                        # Kirim ke semua orang kecuali server dan pengirimnya sendiri\n                        for client_sock in socket_list:\n                            if client_sock != server_socket and client_sock != sock:\n                                try:\n                                    client_sock.send(pesan.encode())\n                                except:\n                                    client_sock.close()\n                                    if client_sock in socket_list:\n                                        socket_list.remove(client_sock)\n                    else:\n                        # Data kosong artinya koneksi diputus normal (FIN)\n                        if sock in socket_list:\n                            socket_list.remove(sock)\n                        print(f\"[KELUAR] Client {clients[sock]} pergi\")\n                        sock.close()\n                        del clients[sock]\n\n                except:\n                    # Error koneksi (Force Close)\n                    if sock in socket_list:\n                        socket_list.remove(sock)\n                    sock.close()\n                    continue\n\n        # Handle Exception sockets (Error)\n        for sock in exception_sockets:\n            socket_list.remove(sock)\n            sock.close()\n\nif __name__ == \"__main__\":\n    sys.exit(run_chat_server())\n</code></pre>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#94-perbandingan-performa","title":"9.4 Perbandingan Performa","text":"Fitur Threading (Bab 6) Select (Bab 9) Asyncio (Bab 8) Logic Mudah (Sequential) Sulit (Event Driven) Menengah (Async/Await) RAM Boros (Stack/Thread) Sangat Hemat Hemat CPU Context Switching Cost Efficient Efficient Limit OS Thread Limit <code>FD_SETSIZE</code> (biasanya 1024) Hampir Unlimited","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#batasan-select","title":"Batasan <code>select</code>","text":"<p>Meskipun cepat, <code>select</code> punya kelemahan klasik: ia hanya sanggup memantau maksimal 1024 koneksi di Windows (dan beberapa Linux lama). Inilah alasan mengapa <code>asyncio</code> modern menggunakan <code>epoll</code> (Linux) atau <code>IOCP</code> (Windows) di balik layar, bukan <code>select</code>. Namun, <code>select</code> adalah dasar pemahamannya.</p>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]},{"location":"Bab_9/Naskah_Bab_9/#95-tugas-mandiri-analisis-skalabilitas","title":"9.5 Tugas Mandiri (Analisis Skalabilitas)","text":"<ol> <li>Jalankan Server.</li> <li>Koneksikan 5 Client. Chatting seperti biasa. Rasanya sama persis dengan versi Threading, bukan?</li> <li>Critical Thinking: Apa yang terjadi jika kode <code>select</code> di atas, saat memproses pesan dari Client A, kita melakukan proses berat (misal: loop 1 juta kali) sebelum kembali ke <code>select()</code>?<ul> <li>Jawab: Seluruh server akan macet (Lag). Client B, C, D tidak akan terlayani. Ini membuktikan bahwa <code>select</code> server juga bersifat Single Threaded Blockable. Server tidak boleh melakukan operasi CPU berat di dalam loop ini.</li> </ul> </li> <li>Tugas: Tambahkan fitur \"Private Message\". Jika client mengetik <code>@ip_tujuan pesan</code>, server hanya meneruskan pesan ke socket dengan IP tersebut.</li> </ol> <p>Navigasi: Naskah_Bab_8 | [[00_Dashboard]] | Naskah_Bab_10</p>","tags":["IOMultiplexing","SelectSystemCall","NonBlockingIO","PemrogramanJaringan","Python","Bab9"]}]}